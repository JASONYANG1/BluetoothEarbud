/*!
\copyright  Copyright (c) 2015 - 2017 Qualcomm Technologies International, Ltd.
            All Rights Reserved.
            Qualcomm Technologies International, Ltd. Confidential and Proprietary.
\version    Part of 6.2
\file       av_headset_peer_signalling.c
\brief	    Implementation of module providing signalling to headset peer device.
*/

#include "av_headset.h"
#include "av_headset_peer_signalling.h"
#include "av_headset_device.h"
#include "av_headset_config.h"
#include "av_headset_scan_manager.h"
#include "av_headset_log.h"

#include <panic.h>
#include <message.h>
#include <bdaddr.h>

/******************************************************************************
 * General Definitions
 ******************************************************************************/

/*! Macro to make a message. */
#define MAKE_MESSAGE(TYPE) TYPE##_T *message = PanicUnlessNew(TYPE##_T);
/*! Macro to make message with variable length for array fields. */
#define MAKE_PEER_SIG_MESSAGE_WITH_LEN(TYPE, LEN) \
    TYPE##_T *message = (TYPE##_T *) PanicUnlessMalloc(sizeof(TYPE##_T) + LEN);

/******************************************************************************
 * Peer Signalling Message Definitions
 ******************************************************************************/
/*
 * AVRCP_PEER_CMD_ADD_LINK_KEY
 */
/*! OPID for sending handset link key to peer headset. */
#define AVRCP_PEER_CMD_ADD_LINK_KEY                     0x34
/*! Size of message to send link key to peer in bytes. */
#define AVRCP_PEER_CMD_ADD_LINK_KEY_SIZE                24
/*! Byte offset to address type field. */
#define AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_TYPE_OFFSET    0
/*! Byte offset to address. */
#define AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_OFFSET         1
/*! Byte offset to key type field. */
#define AVRCP_PEER_CMD_ADD_LINK_KEY_KEY_TYPE_OFFSET     7
/*! Byte offset to link key field. */
#define AVRCP_PEER_CMD_ADD_LINK_KEY_KEY_OFFSET          8

/*! BR/EDR address type. */
#define AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_TYPE_BREDR     0
/*! BR/EDR link key, generated by key H6/H7 deriviation process. */
#define AVRCP_PEER_CMD_ADD_LINK_KEY_KEY_TYPE_0          0

/*! Link key size of 16-bit words */
#define SIZE_LINK_KEY_16BIT_WORDS   8

/*
 * AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS
 */
/*! OPID for sending pair handset address msg to peer. */
#define AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS                     0x33
/*! Size of AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS message. */
#define AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_SIZE                7
/*! Byte offset to address type field. */
#define AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_ADDR_TYPE_OFFSET    0
/*! Byte offset to address field. */
#define AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_ADDR_OFFSET         1


/*!* AVRCP_PEER_CMD_EARBUD_STARTUP_SYNC
  Defines used to define the link message sent to the peer.
*/
/*!@{ */
#define AVRCP_PEER_CMD_STARTUP_SYNC                      0x40       /*!< Message ID */
#define AVRCP_PEER_CMD_STARTUP_SYNC_SIZE                 13         /*!< Message length */
#define AVRCP_PEER_CMD_STARTUP_SYNC_BATT_OFFSET          0
#define AVRCP_PEER_CMD_STARTUP_SYNC_ADDR_TYPE_OFFSET     2
#define AVRCP_PEER_CMD_STARTUP_SYNC_ADDR_OFFSET          3
#define AVRCP_PEER_CMD_STARTUP_SYNC_TWS_VERSION_OFFSET   9
#define AVRCP_PEER_CMD_STARTUP_SYNC_STATE_OFFSET         11
#define AVRCP_PEER_CMD_STARTUP_SYNC_PAIRING_OFFSET       12

#define AVRCP_PEER_CMD_STARTUP_SYNC_STATE_A2DP_CONNECTED    (1 << 0)
#define AVRCP_PEER_CMD_STARTUP_SYNC_STATE_A2DP_STREAMING    (1 << 1)
#define AVRCP_PEER_CMD_STARTUP_SYNC_STATE_AVRCP_CONNECTED   (1 << 2)
#define AVRCP_PEER_CMD_STARTUP_SYNC_STATE_HFP_CONNECTED     (1 << 3)
#define AVRCP_PEER_CMD_STARTUP_SYNC_STATE_IN_CASE           (1 << 4)
#define AVRCP_PEER_CMD_STARTUP_SYNC_STATE_IN_EAR            (1 << 5)
#define AVRCP_PEER_CMD_STARTUP_SYNC_STATE_STARTUP           (1 << 7)

#define AVRCP_PEER_CMD_STARTUP_SYNC_PAIRING_HANDSET_COMPLETE    (1 << 0)
#define AVRCP_PEER_CMD_STARTUP_SYNC_PAIRING_HANDSET_IN_PROGRESS (1 << 1)
/*!@} */


static void appPeerSigMsgChannelInd(peerSigStatus status);
static void appPeerSigStartInactivityTimer(void);
static void appPeerSigCancelInactivityTimer(void);
static void appPeerSigCancelInProgressOperation(void);



static void appPeerSigEnterConnectingAcl(void)
{
    DEBUG_LOG("appPeerSigEnterConnectingAcl");
}

static void appPeerSigExitConnectingAcl(void)
{
    DEBUG_LOG("appPeerSigExitConnectingAcl");
}

static void appPeerSigEnterConnectingLocal(void)
{
    DEBUG_LOG("appPeerSigEnterConnectingLocal");
}

static void appPeerSigExitConnectingLocal(void)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    DEBUG_LOG("appPeerSigExitConnectingLocal");

    /* We have finished (successfully or not) attempting to connect, so
     * we can relinquish our lock on the ACL.  Bluestack will then close
     * the ACL when there are no more L2CAP connections */
    appConManagerReleaseAcl(&peer_sig->peer_addr);
}

static void appPeerSigEnterConnectingRemote(void)
{
    DEBUG_LOG("appPeerSigEnterConnectingRemote");
}

static void appPeerSigExitConnectingRemote(void)
{
    DEBUG_LOG("appPeerSigExitConnectingRemote");
}

static void appPeerSigEnterConnected(void)
{
    DEBUG_LOG("appPeerSigEnterConnected");

    /* Cancel any other startup requests */
    MessageCancelAll(&appGetPeerSig()->task, PEER_SIG_INTERNAL_STARTUP_REQ);

    /* If we have any clients inform them of peer signalling channel connection */
    appPeerSigMsgChannelInd(peerSigStatusChannelConnected);

    appPeerSigStartInactivityTimer();
}

static void appPeerSigExitConnected(void)
{
    DEBUG_LOG("appPeerSigExitConnected");

    appPeerSigCancelInactivityTimer();
}

static void appPeerSigEnterDisconnected(void)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    DEBUG_LOG("appPeerSigEnterDisconnected");

    /* Cancel any other startup requests */
    MessageCancelAll(&peer_sig->task, PEER_SIG_INTERNAL_STARTUP_REQ);

    /* Cancel any operation in progress */
    appPeerSigCancelInProgressOperation();

    /* Clear peer address, as we use that to detect if we've previously reject a peer connection */
    BdaddrSetZero(&peer_sig->peer_addr);

    /* If we have any clients inform them of peer signalling channel disconnection */
    appPeerSigMsgChannelInd(peerSigStatusChannelDisconnected);

    appScanManagerEnablePageScan(SCAN_MAN_USER_PEERSIG, SCAN_MAN_PARAMS_TYPE_SLOW);
}

static void appPeerSigExitDisconnected(void)
{
    DEBUG_LOG("appPeerSigExitDisconnected");

    appScanManagerDisablePageScan(SCAN_MAN_USER_PEERSIG);
}

static appPeerSigState appPeerSigGetState(void)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    return peer_sig->state;
}

static void appPeerSigSetState(appPeerSigState state)
{
    peerSigTaskData *peer_sig = appGetPeerSig();

    appPeerSigState old_state = appPeerSigGetState();
    DEBUG_LOGF("appPeerSigSetState, state %x", state);

    /* Handle state exit functions */
    switch (old_state)
    {
        case PEER_SIG_STATE_DISCONNECTED:
            appPeerSigExitDisconnected();
            break;
        case PEER_SIG_STATE_CONNECTING_ACL:
            appPeerSigExitConnectingAcl();
            break;
        case PEER_SIG_STATE_CONNECTING_LOCAL:
            appPeerSigExitConnectingLocal();
            break;
        case PEER_SIG_STATE_CONNECTING_REMOTE:
            appPeerSigExitConnectingRemote();
            break;
        case PEER_SIG_STATE_CONNECTED:
            appPeerSigExitConnected();
            break;
        default:
            break;
    }

    /* Set new state */
    peer_sig->state = state;

    /* Update lock according to state */
    if (state & PEER_SIG_STATE_LOCK)
        peer_sig->lock |= 0x01;
    else
        peer_sig->lock &= ~0x01;

    /* Handle state entry functions */
    switch (state)
    {
        case PEER_SIG_STATE_DISCONNECTED:
            appPeerSigEnterDisconnected();
            break;
        case PEER_SIG_STATE_CONNECTING_ACL:
            appPeerSigEnterConnectingAcl();
            break;
        case PEER_SIG_STATE_CONNECTING_LOCAL:
            appPeerSigEnterConnectingLocal();
            break;
        case PEER_SIG_STATE_CONNECTING_REMOTE:
            appPeerSigEnterConnectingRemote();
            break;
        case PEER_SIG_STATE_CONNECTED:
            appPeerSigEnterConnected();
            break;
        default:
            break;
    }
}



static void appPeerSigError(MessageId id)
{
    UNUSED(id);
    DEBUG_LOGF("appPeerSigError, state %u, id %u", appPeerSigGetState(), id);
    Panic();
}


/******************************************************************************
 * Messages sent to API clients
 ******************************************************************************/
/*! @brief Send PEER_SIG_LINK_KEY_TX_CFM message. */
static void appPeerSigMsgLinkKeyConfirmation(Task task, peerSigStatus status, bdaddr* addr)
{
    MAKE_MESSAGE(PEER_SIG_LINK_KEY_TX_CFM);
    message->status = status;
    message->handset_addr = *addr;
    MessageSend(task, PEER_SIG_LINK_KEY_TX_CFM, message);
}

/*! \brief Send PEER_SIG_PAIR_HANDSET_CFM message. */
static void appPeerSigMsgPairHandsetConfirmation(Task task, peerSigStatus status, bdaddr* addr)
{
    MAKE_MESSAGE(PEER_SIG_PAIR_HANDSET_CFM);
    message->status = status;
    message->handset_addr = *addr;
    MessageSend(task, PEER_SIG_PAIR_HANDSET_CFM, message);
}

/*! \brief Send PEER_SIG_PAIR_HANDSET_CFM message. */
static void appPeerSigMsgStartupSyncConfirmation(Task task, peerSigStatus status)
{
    MAKE_MESSAGE(PEER_SIG_SYNC_CFM);
    message->status = status;
    MessageSend(task, PEER_SIG_SYNC_CFM, message);
}

/*! @brief Send indication of channel state to registered clients. */
static void appPeerSigMsgChannelInd(peerSigStatus status)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    Task next_client = 0;

    while (appTaskListIterate(peer_sig->client_tasks, &next_client))
    {
        MAKE_MESSAGE(PEER_SIG_CHANNEL_IND);
        message->status = status;
        MessageSend(next_client, PEER_SIG_CHANNEL_IND, message);
    }
}

/******************************************************************************
 * Internal Peer Signalling management functions
 ******************************************************************************/

/*! @brief Cancel any already in progress operations that were waiting for responses from peer.
 */
static void appPeerSigCancelInProgressOperation(void)
{
    peerSigTaskData *peer_sig = appGetPeerSig();

    /* Work out what operation is in progress and inform client of failure */
    switch (peer_sig->current_op)
    {
        case AVRCP_PEER_CMD_ADD_LINK_KEY:
            appPeerSigMsgLinkKeyConfirmation(peer_sig->client_task, peerSigStatusLinkKeyTxFail,
                                             &peer_sig->handset_addr);
            break;
        case AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS:
            appPeerSigMsgPairHandsetConfirmation(peer_sig->client_task, peerSigStatusPairHandsetTxFail,
                                                 &peer_sig->handset_addr);
            break;
        case AVRCP_PEER_CMD_STARTUP_SYNC:            
            appPeerSigMsgStartupSyncConfirmation(peer_sig->client_task, peerSigStatusStartupSyncTxFail);
            break;

        default:
            break;
    }

    /* Clear up, no operation in progress now */
    peer_sig->client_task = NULL;
    peer_sig->current_op = 0;

    /* Clear lock, this may result in the next message being delivered */
    peer_sig->lock &= ~0x02;
}

/*! @brief Start AVRCP if required.

    Must be called by all peer signalling message request APIs, see #appPeerSigTxLinkKeyToPeerReq().

    @return uint16 Lock with which to conditionally post messages requests against.
*/
static uint16 *appPeerSigStartup(const bdaddr *peer_addr)
{
    peerSigTaskData *peer_sig = appGetPeerSig();

    MAKE_MESSAGE(PEER_SIG_INTERNAL_STARTUP_REQ);
    message->peer_addr = *peer_addr;
    message->attempts = 1;
    MessageSendConditionally(&peer_sig->task, PEER_SIG_INTERNAL_STARTUP_REQ, message, &peer_sig->lock);
    return &peer_sig->lock;
}

/*! @brief Set the inactivity timer.
 */
static void appPeerSigStartInactivityTimer(void)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    DEBUG_LOG("appPeerSigStartInactivityTimer");

    if (appConfigPeerSignallingChannelTimeoutSecs())
    {
        MessageCancelAll(&peer_sig->task, PEER_SIG_INTERNAL_INACTIVITY_TIMER);
        MessageSendLater(&peer_sig->task, PEER_SIG_INTERNAL_INACTIVITY_TIMER, NULL,
                         appConfigPeerSignallingChannelTimeoutSecs() * 1000);
    }
}

/*! @brief Stop the inactivity timer.
 */
static void appPeerSigCancelInactivityTimer(void)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    DEBUG_LOG("appPeerSigCancelInactivityTimer");

    MessageCancelAll(&peer_sig->task, PEER_SIG_INTERNAL_INACTIVITY_TIMER);
}

/*! @brief Handle inactivity timer, teardown signalling channel.
 */
static void appPeerSigInactivityTimeout(void)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    DEBUG_LOGF("appPeerSigInactivityTimeout, state %u", appPeerSigGetState());

    /* Both earbuds have an inactivity timeout, protect against race where
     * the AVRCP link may have just been disconnected by the other earbud */
    switch (appPeerSigGetState())
    {
        case PEER_SIG_STATE_CONNECTED:
        {
            /* Start disconnection and move into 'disconnected' state */
            appAvAvrcpDisconnectRequest(&peer_sig->task, peer_sig->av_inst);
            appPeerSigSetState(PEER_SIG_STATE_DISCONNECTED);
        }
        break;

        default:
            break;
    }
}

/******************************************************************************
 * Handlers for connection related messages from AV
 ******************************************************************************/
/*! @brief Take action on connection of AVRCP to peer.
 */
static void appPeerSigHandleAvAvrcpConnectCfm(AV_AVRCP_CONNECT_CFM_T *cfm)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    DEBUG_LOGF("appPeerSigHandleAvAvrcpConnectCfm, state %u, status %u, av %p",
               peer_sig->state, cfm->status, cfm->av_instance);

    switch (appPeerSigGetState())
    {
        case PEER_SIG_STATE_CONNECTING_LOCAL:
        case PEER_SIG_STATE_CONNECTING_REMOTE:
        {
            if (cfm->status == avrcp_success)
            {
                /* Save AV instance for AVRCP comms with peer */
                peer_sig->av_inst = cfm->av_instance;

                /* Register peer signalling task with AV to receive vendor unique AVRCP
                   messages */
                appAvrcpVendorPassthroughRegister(peer_sig->av_inst, &peer_sig->task);

                /* Move to 'connected' state */
                appPeerSigSetState(PEER_SIG_STATE_CONNECTED);
            }
            else
            {
                /* Decrement number of attempts to connect */
                peer_sig->attempts -= 1;

                /* Check if we should retry */
                if (peer_sig->attempts && appAvAvrcpConnectRequest(&peer_sig->task, &peer_sig->peer_addr))
                {
                    DEBUG_LOG("appPeerSigHandleAvAvrcpConnectCfm, retrying");

                    /* Move to 'connecting local' state */
                    appPeerSigSetState(PEER_SIG_STATE_CONNECTING_LOCAL);
                }
                else
                {
                    /* Move to 'Disconnected' state */
                    appPeerSigSetState(PEER_SIG_STATE_DISCONNECTED);
                }
            }
        }
        break;

        default:
            appPeerSigError(AV_AVRCP_CONNECT_CFM);
            break;
    }
}


/*! @brief Handle indication we now have an AVRCP connection to peer.
 */
static void appPeerSigHandleAvAvrcpConnectInd(const AV_AVRCP_CONNECT_IND_T *ind)
{
    peerSigTaskData * peer_sig = appGetPeerSig();
    DEBUG_LOGF("appPeerSigHandleAvAvrcpConnectInd, state %u", appPeerSigGetState());

    switch (appPeerSigGetState())
    {
        case PEER_SIG_STATE_DISCONNECTED:
        {
            /* only accept AVRCP connections from paired peer devices. */
            if (appDeviceIsPeer(&ind->bd_addr))
            {
                DEBUG_LOG("appPeerSigHandleAvAvrcpConnectInd, accepted");

                /* Move to 'connecting local' state */
                appPeerSigSetState(PEER_SIG_STATE_CONNECTING_REMOTE);

                /* Accept connection */
                appAvAvrcpConnectResponse(&peer_sig->task, &ind->bd_addr,
                                          ind->connection_id, ind->signal_id, AV_AVRCP_ACCEPT);

                /* Done, so exit */
                return;
            }
            else
            {
                /* Not a known peer, rememeber it just in case we're in the middle of pairing */
                peer_sig->peer_addr = ind->bd_addr;
            }
        }

        default:
        {
            DEBUG_LOG("appPeerSigHandleAvAvrcpConnectInd, rejected");

            /* Reject connection */
            appAvAvrcpConnectResponse(&peer_sig->task, &ind->bd_addr,
                                      ind->connection_id, ind->signal_id, AV_AVRCP_REJECT);
        }
        break;
    }
}

/*! @brief Handle AVRCP to peer disconnection event.
 */
static void appPeerSigHandleAvAvrcpDisconnectInd(AV_AVRCP_DISCONNECT_IND_T *ind)
{
    peerSigTaskData * peer_sig = appGetPeerSig();
    DEBUG_LOGF("appPeerSigHandleAvAvrcpDisconnectInd, status %u, state %u", ind->status, appPeerSigGetState());

    /* Attempt to re-startup if link loss */
    if (ind->status == avrcp_link_loss)
        appPeerSigStartup(&peer_sig->peer_addr);

    /* Move to 'disconnected' state */
    appPeerSigSetState(PEER_SIG_STATE_DISCONNECTED);
}


static uint16 appPeerSigReadUint16(const uint8 *data)
{
    return data[0] + ((uint16)data[1] << 8);
}

static uint24 appPeerSigReadUint24(const uint8 *data)
{
    return data[0] + ((uint16)data[1] << 8) + ((uint32)data[2] << 16);
}

//static uint32 appPeerSigReadUint32(const uint8 *data)
//{
//    return data[0] + (data[1] << 8) + ((uint32)data[2] << 16) + ((uint32)data[3] << 24);
//}



static void appPeerSigHandleInternalStartupRequest(PEER_SIG_INTERNAL_STARTUP_REQ_T *req)
{
    peerSigTaskData * peer_sig = appGetPeerSig();
    DEBUG_LOGF("appPeerSigHandleInternalStartupRequest, state %u, bdaddr %04x,%02x,%06lx",
               appPeerSigGetState(),
               req->peer_addr.nap, req->peer_addr.uap, req->peer_addr.lap);

    switch (appPeerSigGetState())
    {
        case PEER_SIG_STATE_CONNECTING_ACL:
        case PEER_SIG_STATE_DISCONNECTED:
        {
            /* Check if ACL is now up */
            if (appConManagerIsConnected(&req->peer_addr))
            {
                DEBUG_LOG("appPeerSigHandleInternalStartupRequest, ACL connected");

                /* Check if ACL was locally initiated, or was previously rejected (peer_addr is not zero) */
                if (appConManagerIsAclLocal(&req->peer_addr) || BdaddrIsSame(&peer_sig->peer_addr, &req->peer_addr))
                {
                    DEBUG_LOG("appPeerSigHandleInternalStartupRequest, ACL locally initiated");

                    /* Initate outgoing AVRCP connection */
                    peer_sig->peer_addr = req->peer_addr;
                    if (appAvAvrcpConnectRequest(&peer_sig->task, &peer_sig->peer_addr))
                    {
                        peer_sig->attempts = req->attempts;
                        appPeerSigSetState(PEER_SIG_STATE_CONNECTING_LOCAL);
                    }
                }
                else
                {
                    DEBUG_LOG("appPeerSigHandleInternalStartupRequest, ACL remotely initiated");

                    /* Not locally initiated ACL, move to 'Disconnected' state */
                    appPeerSigSetState(PEER_SIG_STATE_DISCONNECTED);
                }
            }
            else
            {
                DEBUG_LOG("appPeerSigHandleInternalStartupRequest, ACL not connected");

                if (appPeerSigGetState() == PEER_SIG_STATE_DISCONNECTED)
                {
                    /* Post message back to ourselves, blocked on creating ACL */
                    MAKE_MESSAGE(PEER_SIG_INTERNAL_STARTUP_REQ);
                    message->peer_addr = req->peer_addr;
                    message->attempts = req->attempts;
                    MessageSendConditionally(&peer_sig->task, PEER_SIG_INTERNAL_STARTUP_REQ, message, appConManagerCreateAcl(&req->peer_addr));

                    /* Wait in 'Connecting ACL' state for ACL to open */
                    appPeerSigSetState(PEER_SIG_STATE_CONNECTING_ACL);
                    return;
                }
                else
                {
                    /* ACL failed to open, move to 'Disconnected' state */
                    appPeerSigSetState(PEER_SIG_STATE_DISCONNECTED);
                }
            }
        }
        break;

        case PEER_SIG_STATE_CONNECTED:
            /* Already connected, just ignore startup request */
            break;

        default:
            appPeerSigError(PEER_SIG_INTERNAL_STARTUP_REQ);
            break;
    }

    /* Cancel any other startup requests */
    MessageCancelAll(&peer_sig->task, PEER_SIG_INTERNAL_STARTUP_REQ);
}

static void appPeerSigHandleInternalShutdownReq(void)
{
    peerSigTaskData *peer_sig = appGetPeerSig();

    switch (appPeerSigGetState())
    {
        case PEER_SIG_STATE_CONNECTED:
            if (peer_sig->av_inst)
            {
                appAvAvrcpDisconnectRequest(&peer_sig->task, peer_sig->av_inst);
            }
            appPeerSigSetState(PEER_SIG_STATE_DISCONNECTED);
            break;
        default:
            break;
    }
}

/******************************************************************************
 * Handlers for peer messaging from AV
 ******************************************************************************/
/*! @brief Receive handset link key for peer.
 
    External interface for link keys is 16 bytes packed into 8 16-bit words,
    do the conversion from 16 8-bit words here.
 */
static bool appPeerSigHandleRxLinkKey(AV_AVRCP_VENDOR_PASSTHROUGH_IND_T *ind)
{
    peerSigTaskData* peer_sig = appGetPeerSig();
    uint16 key_len_words = SIZE_LINK_KEY_16BIT_WORDS * sizeof(uint16);

    DEBUG_LOGF("appPeerSigHandleRxLinkKey size:%d", ind->size_payload);

    /* validate message:
     * message length not correct OR
     * we don't have a task registered to receive it OR
     * handset address type not supported OR
     * link key type not support */
    if (   (ind->size_payload != AVRCP_PEER_CMD_ADD_LINK_KEY_SIZE)
        || (peer_sig->link_key_task == NULL)
        || (ind->payload[AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_TYPE_OFFSET] !=
                   AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_TYPE_BREDR)
        || (ind->payload[AVRCP_PEER_CMD_ADD_LINK_KEY_KEY_TYPE_OFFSET] !=
                    AVRCP_PEER_CMD_ADD_LINK_KEY_KEY_TYPE_0)
        || !peer_sig->link_key_task)
    {
        /* we don't like this message format, indicate failure to sender */
        return FALSE;
    }
    else
    {
        MAKE_PEER_SIG_MESSAGE_WITH_LEN(PEER_SIG_LINK_KEY_RX_IND, key_len_words);
        int index = AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_OFFSET;

        message->status = peerSigStatusSuccess;
        message->handset_addr.lap = (uint32)(((uint32)ind->payload[index]) | 
                                             ((uint32)ind->payload[index+1]) << 8 |
                                             ((uint32)ind->payload[index+2]) << 16);
        message->handset_addr.uap = ind->payload[index+3];
        message->handset_addr.nap = (uint16)(((uint16)ind->payload[index+4]) |
                                             ((uint16)ind->payload[index+5]) << 8);
        index = AVRCP_PEER_CMD_ADD_LINK_KEY_KEY_OFFSET;
        memcpy(message->key, &ind->payload[index], key_len_words);
        message->key_len = SIZE_LINK_KEY_16BIT_WORDS;
    
        /* send to registered client */
        MessageSend(peer_sig->link_key_task, PEER_SIG_LINK_KEY_RX_IND, message);

        /* indicate we succeeded */
        return TRUE;
    }
}

/*! \brief Receive pair handset command. */
static bool appPeerSigHandlePairHandsetCommand(AV_AVRCP_VENDOR_PASSTHROUGH_IND_T *ind)
{
    peerSigTaskData* peer_sig = appGetPeerSig();

    /* validate message */
    if (   (ind->size_payload != AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_SIZE)
        || (ind->payload[AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_ADDR_TYPE_OFFSET] !=
                    AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_TYPE_BREDR)
        || !peer_sig->pair_handset_task)
    {
        return FALSE;
    }
    else
    {
        /* tell pairing module to pair with specific handset */
        MAKE_MESSAGE(PEER_SIG_PAIR_HANDSET_IND);
        int index = AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_ADDR_OFFSET;
        message->handset_addr.lap = (uint32)(((uint32)ind->payload[index]) | 
                                             ((uint32)ind->payload[index+1]) << 8 |
                                             ((uint32)ind->payload[index+2]) << 16);
        message->handset_addr.uap = ind->payload[index+3];
        message->handset_addr.nap = (uint16)(((uint16)ind->payload[index+4]) |
                                             ((uint16)ind->payload[index+5]) << 8);
        MessageSend(peer_sig->pair_handset_task, PEER_SIG_PAIR_HANDSET_IND, message);
        DEBUG_LOGF("appPeerSigHandlePairHandsetCommand %lx %x %x", message->handset_addr.lap, message->handset_addr.uap, message->handset_addr.nap);
        return TRUE;
    }
}


static bool appPeerSigHandleSyncCommand(AV_AVRCP_VENDOR_PASSTHROUGH_IND_T *ind)
{
    peerSigTaskData *peer_sig = appGetPeerSig();

    if (ind->size_payload == AVRCP_PEER_CMD_STARTUP_SYNC_SIZE)
    {
        if (ind->payload[AVRCP_PEER_CMD_STARTUP_SYNC_ADDR_TYPE_OFFSET] ==
            AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_TYPE_BREDR)
        {
            if (peer_sig->sync_task)
            {
                const uint8 state   = ind->payload[AVRCP_PEER_CMD_STARTUP_SYNC_STATE_OFFSET];
                const uint8 pairing = ind->payload[AVRCP_PEER_CMD_STARTUP_SYNC_PAIRING_OFFSET];

                MAKE_MESSAGE(PEER_SIG_SYNC_IND);
                message->battery_level = appPeerSigReadUint16(&ind->payload[AVRCP_PEER_CMD_STARTUP_SYNC_BATT_OFFSET]);
                message->handset_addr.lap = appPeerSigReadUint24(&ind->payload[AVRCP_PEER_CMD_STARTUP_SYNC_ADDR_OFFSET]);
                message->handset_addr.uap = ind->payload[AVRCP_PEER_CMD_STARTUP_SYNC_ADDR_OFFSET + 3];
                message->handset_addr.nap = appPeerSigReadUint16(&ind->payload[AVRCP_PEER_CMD_STARTUP_SYNC_ADDR_OFFSET + 4]);
                message->tws_version = appPeerSigReadUint16(&ind->payload[AVRCP_PEER_CMD_STARTUP_SYNC_TWS_VERSION_OFFSET]);
                message->peer_a2dp_connected      = (state & AVRCP_PEER_CMD_STARTUP_SYNC_STATE_A2DP_CONNECTED) ? 1 : 0;
                message->peer_a2dp_streaming      = (state & AVRCP_PEER_CMD_STARTUP_SYNC_STATE_A2DP_STREAMING) ? 1 : 0;
                message->peer_avrcp_connected     = (state & AVRCP_PEER_CMD_STARTUP_SYNC_STATE_AVRCP_CONNECTED) ? 1 : 0;
                message->peer_hfp_connected       = (state & AVRCP_PEER_CMD_STARTUP_SYNC_STATE_HFP_CONNECTED) ? 1 : 0;
                message->startup                  = (state & AVRCP_PEER_CMD_STARTUP_SYNC_STATE_STARTUP) ? 1 : 0;
                message->peer_in_case             = (state & AVRCP_PEER_CMD_STARTUP_SYNC_STATE_IN_CASE) ? 1 : 0;
                message->peer_in_ear              = (state & AVRCP_PEER_CMD_STARTUP_SYNC_STATE_IN_EAR) ? 1 : 0;
                message->peer_is_pairing          = (pairing & AVRCP_PEER_CMD_STARTUP_SYNC_PAIRING_HANDSET_IN_PROGRESS) ? 1 : 0;
                message->peer_has_handset_pairing = (pairing & AVRCP_PEER_CMD_STARTUP_SYNC_PAIRING_HANDSET_COMPLETE) ? 1 : 0;

                DEBUG_LOGF("appPeerSigHandleSyncCommand, battery %u, bdaddr %04x,%02x,%06lx, version %u.%02u, state %x, peer_startup %u, peer_in_case %u, peer_in_ear %u",
                           message->battery_level, message->handset_addr.nap, message->handset_addr.uap, message->handset_addr.lap,
                           message->tws_version >> 8, message->tws_version & 0xFF, state, message->startup,
                           message->peer_in_case, message->peer_in_ear);
                DEBUG_LOGF("appPeerSigHandleSyncCommand, peer_is_pairing %u, peer_has_handset_pairing %u",
                           message->peer_is_pairing, message->peer_has_handset_pairing);

                MessageSend(peer_sig->sync_task, PEER_SIG_SYNC_IND, message);
                return TRUE;
            }
        }
    }

    DEBUG_LOG("appPeerSigHandleSyncCommand, rejected");
    return FALSE;
}

/*! @brief Unsolicited messages received from peer.
 */
static void appPeerSigHandleAvAvrcpVendorPassthroughInd(AV_AVRCP_VENDOR_PASSTHROUGH_IND_T *ind)
{
    bool rc = FALSE;

    switch (ind->opid)
    {
        case AVRCP_PEER_CMD_ADD_LINK_KEY:
            rc = appPeerSigHandleRxLinkKey(ind);
            break;

        case AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS:
            rc = appPeerSigHandlePairHandsetCommand(ind);
            break;

        case AVRCP_PEER_CMD_STARTUP_SYNC:
            rc = appPeerSigHandleSyncCommand(ind);
            break;

        /* add handlers for new incoming peer signalling message types here */

        default:
        break;
    }

    /* Restart in-activity timer */
    appPeerSigStartInactivityTimer();

    /* Reply to the indication */
    appAvrcpVendorPassthroughResponse(ind->av_instance,
                                      rc ? avctp_response_accepted : avctp_response_rejected);
}

/*! @brief Confirmation of messages we've sent to the peer.
 */
static void appPeerSigHandleAvAvrcpVendorPassthroughConfirm(AV_AVRCP_VENDOR_PASSTHROUGH_CFM_T *cfm)
{
    peerSigTaskData* peer_sig = appGetPeerSig();

    DEBUG_LOGF("appPeerSigHandleAvAvrcpVendorPassthroughConfirm %d opid:%x", cfm->status, cfm->opid);

    switch (cfm->opid)
    {
        case AVRCP_PEER_CMD_ADD_LINK_KEY:
            appPeerSigMsgLinkKeyConfirmation(peer_sig->client_task, cfm->status == avrcp_success ?
                                             peerSigStatusSuccess : peerSigStatusLinkKeyTxFail,
                                             &peer_sig->handset_addr);
            break;

        case AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS:
            appPeerSigMsgPairHandsetConfirmation(peer_sig->client_task, cfm->status == avrcp_success ?
                                                 peerSigStatusSuccess : peerSigStatusPairHandsetTxFail,
                                                 &peer_sig->handset_addr);
            break;

        case AVRCP_PEER_CMD_STARTUP_SYNC:
            appPeerSigMsgStartupSyncConfirmation(peer_sig->client_task, cfm->status == avrcp_success ?
                                                 peerSigStatusSuccess : peerSigStatusStartupSyncTxFail);
            break;

        /* add handlers for new outgoing peer signalling message confirmations here */

        default:
            DEBUG_LOGF("appPeerSigHandleAvAvrcpVendorPassthroughConfirm unknown opid:%x", cfm->opid);
            break;
    }

    /* Clear up, no operation in progress now */
    peer_sig->client_task = NULL;
    peer_sig->current_op = 0;

    /* Clear lock, this may result in the next message being delivered */
    peer_sig->lock &= ~0x02;

    /* Completed current operation, restart the inactivity timer */
    if (appPeerSigGetState() == PEER_SIG_STATE_CONNECTED)
        appPeerSigStartInactivityTimer();
}

static void appPeerSigVendorPassthroughRequest(Task client_task,
                                               avc_operation_id op_id,
                                               uint16 size_payload, const uint8 *payload)
{
    peerSigTaskData *peer_sig = appGetPeerSig();

    /* Store task for rsponse and oepration ID, so when confirmation comes back we can send
     * message to correct task */
    peer_sig->client_task = client_task;
    peer_sig->current_op = op_id;

    /* Set lock to prevent any other operations */
    peer_sig->lock |= 0x02;

    /* Request vendor passthrough */
    appAvrcpVendorPassthroughRequest(peer_sig->av_inst, op_id, size_payload, payload);

    /* Cancel inactivity timer, it will be restarted when response is received */
    appPeerSigCancelInactivityTimer();
}

/******************************************************************************
 * Handlers for peer signalling internal messages
 ******************************************************************************/
/*! @brief Send link key to peer earbud.
 */
static void appPeerSigHandleInternalLinkKeyRequest(PEER_SIG_INTERNAL_LINK_KEY_REQ_T *req)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    DEBUG_LOGF("appPeerSigHandleInternalLinkKeyRequest, state %u", appPeerSigGetState());

    switch (appPeerSigGetState())
    {
        case PEER_SIG_STATE_CONNECTED:
        {
            uint8 message[AVRCP_PEER_CMD_ADD_LINK_KEY_SIZE];
            int index;

            /* Remember handset address */
            peer_sig->handset_addr = req->handset_addr;

            /* Build data for message, handset address and key */
            index = AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_TYPE_OFFSET;
            message[index] = AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_TYPE_BREDR;
            index = AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_OFFSET;
            message[index++] =  req->handset_addr.lap & 0xFF;
            message[index++] = (req->handset_addr.lap >> 8) & 0xFF;
            message[index++] = (req->handset_addr.lap >> 16) & 0xFF;
            message[index++] =  req->handset_addr.uap;
            message[index++] =  req->handset_addr.nap & 0xFF;
            message[index++] = (req->handset_addr.nap >> 8) & 0xFF;
            index = AVRCP_PEER_CMD_ADD_LINK_KEY_KEY_TYPE_OFFSET;
            message[index] = AVRCP_PEER_CMD_ADD_LINK_KEY_KEY_TYPE_0;
            index = AVRCP_PEER_CMD_ADD_LINK_KEY_KEY_OFFSET;
            memcpy(&message[index], req->key, req->key_len);

            /* Send the link key over AVRCP */
            appPeerSigVendorPassthroughRequest(req->client_task, AVRCP_PEER_CMD_ADD_LINK_KEY,
                                               AVRCP_PEER_CMD_ADD_LINK_KEY_SIZE, message);
        }
        break;

        default:
        {
            appPeerSigMsgLinkKeyConfirmation(req->client_task, peerSigStatusLinkKeyTxFail,
                                             &req->handset_addr);
        }
        break;
    }
}

/*! \brief Send handset pair command to peer earbud. */
static void appPeerSigHandleInternalPairHandsetRequest(PEER_SIG_INTERNAL_PAIR_HANDSET_REQ_T *req)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    DEBUG_LOGF("appPeerSigHandleInternalPairHandsetRequest, state %u", appPeerSigGetState());

    switch (appPeerSigGetState())
    {
        case PEER_SIG_STATE_CONNECTED:
        {
            uint8 message[AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_SIZE];
            int index;

            /* Remember handset address */
            peer_sig->handset_addr = req->handset_addr;

            /* Build data for message and handset address */
            index = AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_ADDR_TYPE_OFFSET;
            message[index] = AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_TYPE_BREDR;
            index = AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_ADDR_OFFSET;
            message[index++] =  req->handset_addr.lap & 0xFF;
            message[index++] = (req->handset_addr.lap >> 8) & 0xFF;
            message[index++] = (req->handset_addr.lap >> 16) & 0xFF;
            message[index++] =  req->handset_addr.uap;
            message[index++] =  req->handset_addr.nap & 0xFF;
            message[index++] = (req->handset_addr.nap >> 8) & 0xFF;

            /* Send the handset address over AVRCP */
            appPeerSigVendorPassthroughRequest(req->client_task, AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS,
                                               AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_SIZE, message);
        }
        break;

        default:
        {
            appPeerSigMsgPairHandsetConfirmation(req->client_task, peerSigStatusLinkKeyTxFail,
                                                 &req->handset_addr);
        }
        break;
    }
}


/*! \brief Send startup sync command to peer earbud. */
static void appPeerSigHandleInternalSyncRequest(PEER_SIG_INTERNAL_SYNC_REQ_T* req)
{
    DEBUG_LOGF("appPeerSigHandleInternalSyncRequest, state %u", appPeerSigGetState());

    switch (appPeerSigGetState())
    {
        case PEER_SIG_STATE_CONNECTED:
        {
            uint8 message[AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS_SIZE];
            int index;
            const uint8 state = (req->a2dp_connected  ? AVRCP_PEER_CMD_STARTUP_SYNC_STATE_A2DP_CONNECTED  : 0) +
                                (req->a2dp_streaming  ? AVRCP_PEER_CMD_STARTUP_SYNC_STATE_A2DP_STREAMING  : 0) +
                                (req->avrcp_connected ? AVRCP_PEER_CMD_STARTUP_SYNC_STATE_AVRCP_CONNECTED : 0) +
                                (req->hfp_connected   ? AVRCP_PEER_CMD_STARTUP_SYNC_STATE_HFP_CONNECTED   : 0) +
                                (req->is_startup      ? AVRCP_PEER_CMD_STARTUP_SYNC_STATE_STARTUP : 0) +
                                (req->in_case         ? AVRCP_PEER_CMD_STARTUP_SYNC_STATE_IN_CASE : 0) +
                                (req->in_ear          ? AVRCP_PEER_CMD_STARTUP_SYNC_STATE_IN_EAR : 0);

            const uint8 pairing = (req->is_pairing           ? AVRCP_PEER_CMD_STARTUP_SYNC_PAIRING_HANDSET_IN_PROGRESS : 0) +
                                  (req->have_handset_pairing ? AVRCP_PEER_CMD_STARTUP_SYNC_PAIRING_HANDSET_COMPLETE : 0);

            DEBUG_LOGF("appPeerSigHandleInternalSyncReq, battery %u, bdaddr %04x,%02x,%06lx, version %u.%02u, state %x, startup %u, in_case %u, in_ear %u",
                       req->battery_level, req->handset_addr.nap, req->handset_addr.uap, req->handset_addr.lap,
                       req->handset_tws_version >> 8, req->handset_tws_version & 0xFF, state, req->is_startup,
                       req->in_case, req->in_ear);
            DEBUG_LOGF("appPeerSigHandleInternalSyncReq, is_pairing %u, have_handset_pairing %u",
                       req->is_pairing, req->have_handset_pairing);

            index = AVRCP_PEER_CMD_STARTUP_SYNC_BATT_OFFSET;
            message[index++] = req->battery_level & 0xFF;
            message[index] = (req->battery_level >> 8) & 0xFF;

            index = AVRCP_PEER_CMD_STARTUP_SYNC_ADDR_TYPE_OFFSET;
            message[index] = AVRCP_PEER_CMD_ADD_LINK_KEY_ADDR_TYPE_BREDR;

            index = AVRCP_PEER_CMD_STARTUP_SYNC_ADDR_OFFSET;
            message[index++] =  req->handset_addr.lap & 0xFF;
            message[index++] = (req->handset_addr.lap >> 8) & 0xFF;
            message[index++] = (req->handset_addr.lap >> 16) & 0xFF;
            message[index++] =  req->handset_addr.uap;
            message[index++] =  req->handset_addr.nap & 0xFF;
            message[index] = (req->handset_addr.nap >> 8) & 0xFF;

            index = AVRCP_PEER_CMD_STARTUP_SYNC_TWS_VERSION_OFFSET;
            message[index++] = req->handset_tws_version & 0xFF;
            message[index] = (req->handset_tws_version >> 8) & 0xFF;

            index = AVRCP_PEER_CMD_STARTUP_SYNC_STATE_OFFSET;
            message[index] = state;

            index = AVRCP_PEER_CMD_STARTUP_SYNC_PAIRING_OFFSET;
            message[index] = pairing;

            /* Send the sync data over AVRCP */
            appPeerSigVendorPassthroughRequest(req->client_task, AVRCP_PEER_CMD_STARTUP_SYNC,
                                               AVRCP_PEER_CMD_STARTUP_SYNC_SIZE, message);
        }
        break;

        default:
        {
            appPeerSigMsgStartupSyncConfirmation(req->client_task, peerSigStatusStartupSyncTxFail);
        }
        break;
    }
}

/*! @brief Peer signalling task message handler.
 */
static void appPeerSigHandleMessage(Task task, MessageId id, Message message)
{
    UNUSED(task);

    switch (id)
    {
        /* AV module peer connection related messages */
        case AV_AVRCP_CONNECT_CFM:
            appPeerSigHandleAvAvrcpConnectCfm((AV_AVRCP_CONNECT_CFM_T *)message);
            break;

        case AV_AVRCP_CONNECT_IND:
            appPeerSigHandleAvAvrcpConnectInd((AV_AVRCP_CONNECT_IND_T *)message);
            break;

        case AV_AVRCP_DISCONNECT_IND:
            appPeerSigHandleAvAvrcpDisconnectInd((AV_AVRCP_DISCONNECT_IND_T *)message);
            break;

        /* AV module peer comms related messages */
        case AV_AVRCP_VENDOR_PASSTHROUGH_IND:
            appPeerSigHandleAvAvrcpVendorPassthroughInd((AV_AVRCP_VENDOR_PASSTHROUGH_IND_T*)message);
            break;

        case AV_AVRCP_VENDOR_PASSTHROUGH_CFM:
            appPeerSigHandleAvAvrcpVendorPassthroughConfirm((AV_AVRCP_VENDOR_PASSTHROUGH_CFM_T*)message);
            break;            

        /* Internal Peer Signalling Messages */
        case PEER_SIG_INTERNAL_STARTUP_REQ:
            appPeerSigHandleInternalStartupRequest((PEER_SIG_INTERNAL_STARTUP_REQ_T *)message);
            break;

        case PEER_SIG_INTERNAL_INACTIVITY_TIMER:
            appPeerSigInactivityTimeout();
            break;

        case PEER_SIG_INTERNAL_LINK_KEY_REQ:
            appPeerSigHandleInternalLinkKeyRequest((PEER_SIG_INTERNAL_LINK_KEY_REQ_T *)message);
            break;

        case PEER_SIG_INTERNAL_PAIR_HANDSET_REQ:
            appPeerSigHandleInternalPairHandsetRequest((PEER_SIG_INTERNAL_PAIR_HANDSET_REQ_T *)message);
            break;

        case PEER_SIG_INTERNAL_SYNC_REQ:
            appPeerSigHandleInternalSyncRequest((PEER_SIG_INTERNAL_SYNC_REQ_T *)message);
            break;

        case PEER_SIG_INTERNAL_SHUTDOWN_REQ:
            appPeerSigHandleInternalShutdownReq();
            break;

        default:
            DEBUG_LOGF("appPeerSigHandleMessage. Unhandled message 0x%04x (%d)",id,id);
            break;
    }
}

/******************************************************************************
 * PUBLIC API
 ******************************************************************************/
/* Initialise the peer signalling module. 
 */
void appPeerSigInit(void)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    memset(peer_sig, 0, sizeof(*peer_sig));

    /* Set task's message handler */
    peer_sig->task.handler = appPeerSigHandleMessage;

    /* Set initial state and ensure lock is cleared */
    peer_sig->state = PEER_SIG_STATE_NULL;
    peer_sig->lock = 0;

    /* Create the list client task list */
    peer_sig->client_tasks = appTaskListInit();

    /* Move to 'disconnected' state */
    appPeerSigSetState(PEER_SIG_STATE_DISCONNECTED);
}

/* Send handset link key to peer headset.
 
    External API for link keys is 8 packed 16-bit words, internally and over
    AVRCP we use 8-bit words, make the conversion now.
 */
void appPeerSigLinkKeyToPeerRequest(Task task, const bdaddr *peer_addr, const bdaddr *handset_addr,
                                    const uint16 *key, uint16 key_len)
{
    peerSigTaskData* peer_sig = appGetPeerSig();
    uint16 size_key_bytes = key_len * 2;
    MAKE_PEER_SIG_MESSAGE_WITH_LEN(PEER_SIG_INTERNAL_LINK_KEY_REQ, size_key_bytes-1);

    DEBUG_LOGF("appPeerSigLinkKeyToPeerRequest, bdaddr %04x,%02x,%06lx",
               handset_addr->nap, handset_addr->uap, handset_addr->lap);

    /* Build message to trigger TX of link key to peer, will wait for peer AVRCP
     * connection if none exists yet, or another operation if one already in
     * progress */
    message->client_task = task;
    message->handset_addr = *handset_addr;
    message->key_len = size_key_bytes;
    memcpy(message->key, key, size_key_bytes);
    MessageSendConditionally(&peer_sig->task, PEER_SIG_INTERNAL_LINK_KEY_REQ,
                             message, appPeerSigStartup(peer_addr));
}

/* Inform peer earbud of address of handset with which it should pair.
*/
void appPeerSigTxPairHandsetRequest(Task task, const bdaddr *peer_addr, const bdaddr *handset_addr)
{
    peerSigTaskData* peer_sig = appGetPeerSig();
    MAKE_MESSAGE(PEER_SIG_INTERNAL_PAIR_HANDSET_REQ);

    DEBUG_LOGF("appPeerSigTxPairHandsetRequest, bdaddr %04x,%02x,%06lx",
               handset_addr->nap, handset_addr->uap, handset_addr->lap);

    message->client_task = task;
    message->handset_addr = *handset_addr;
    MessageSendConditionally(&peer_sig->task, PEER_SIG_INTERNAL_PAIR_HANDSET_REQ,
                             message, appPeerSigStartup(peer_addr));
}

/* Send sync message to peer earbud.
*/
void appPeerSigSyncRequest(Task task, const bdaddr *peer_addr, const bdaddr *handset_addr,
                           uint16 battery_level, uint16 handset_tws_version,
                           bool a2dp_connected, bool a2dp_streaming,
                           bool avrcp_connected, bool hfp_connected, bool is_startup,
                           bool in_case, bool in_ear, bool is_pairing, bool have_handset_pairing)
{
    peerSigTaskData* peer_sig = appGetPeerSig();
    MAKE_MESSAGE(PEER_SIG_INTERNAL_SYNC_REQ);

    DEBUG_LOGF("appPeerSigSyncRequest, battery %u, bdaddr %04x,%02x,%06lx, version %u.%02u",
               battery_level, handset_addr->nap, handset_addr->uap, handset_addr->lap,
               handset_tws_version >> 8, handset_tws_version & 0xFF);
    DEBUG_LOGF("appPeerSigSyncRequest, a2dp_connected %u, avrcp_connected %u, hfp_connected %u, a2dp_streaming %u",
                a2dp_connected, avrcp_connected, hfp_connected, a2dp_streaming);
    DEBUG_LOGF("appPeerSigSyncRequest, is_startup %u, in_case %u, in_ear %u, is_pairing %u, have_handset_pairing %u",
                is_startup, in_case, in_ear, is_pairing, have_handset_pairing);

    /* Populate message */
    message->client_task = task;
    if (handset_addr)
        message->handset_addr = *handset_addr;
    else
        BdaddrSetZero(&message->handset_addr);
    message->battery_level = battery_level;
    message->handset_tws_version = handset_tws_version;
    message->a2dp_connected = a2dp_connected;
    message->a2dp_streaming = a2dp_streaming;
    message->avrcp_connected = avrcp_connected;
    message->hfp_connected = hfp_connected;
    message->is_startup = is_startup;
    message->in_case = in_case;
    message->in_ear = in_ear;
    message->is_pairing = is_pairing;
    message->have_handset_pairing = have_handset_pairing;

    /* Send to task, potentially blocked on bringing up AVRCP */
    MessageCancelAll(&peer_sig->task, PEER_SIG_INTERNAL_SYNC_REQ);
    MessageSendConditionally(&peer_sig->task, PEER_SIG_INTERNAL_SYNC_REQ,
                             message, appPeerSigStartup(peer_addr));
}

/* Register task with peer signalling for Link Key TX/RX operations.
 */
void appPeerSigLinkKeyTaskRegister(Task client_task)
{
    peerSigTaskData *peer_sig = appGetPeerSig();

    DEBUG_LOG("appPeerSigLinkKeyTaskRegister");
    
    /* remember client task for when AVRCP connects */
    peer_sig->link_key_task = client_task;

    /* tell AV we want notification when an AVRCP connection occurs */
    appAvAvrcpClientRegister(&peer_sig->task, 0);
}

/* Unregister task with peer signalling for Link Key TX/RX operations.
 */
void appPeerSigLinkKeyTaskUnregister(void)
{
    peerSigTaskData* peer_sig = appGetPeerSig();

    DEBUG_LOG("appPeerSigLinkKeyTaskUnregister");
    
    /* remember client task for when AVRCP connects */
    peer_sig->link_key_task = NULL;
}

/* Try and connect peer signalling channel with specified peer earbud.
 */
void appPeerSigConnect(bdaddr* peer_addr)
{
    DEBUG_LOGF("appPeerSigConnect %lx %x %x", peer_addr->lap, peer_addr->uap, peer_addr->nap);

    /* get AVRCP channel to peer if required */
    appPeerSigStartup(peer_addr);
}

/* Register to receive peer signalling notifications. */
void appPeerSigClientRegister(Task client_task)
{
    peerSigTaskData* peer_sig = appGetPeerSig();
    appTaskListAddTask(peer_sig->client_tasks, client_task);
}

/* Unregister to stop receiving peer signalling notifications. */
void appPeerSigClientUnregister(Task client_task)
{
    peerSigTaskData* peer_sig = appGetPeerSig();
    appTaskListRemoveTask(peer_sig->client_tasks, client_task);
}

/* Register task to receive AVRCP_PEER_CMD_PAIR_HANDSET_ADDRESS. */
void appPeerSigPairHandsetTaskRegister(Task pair_handset_task)
{
    peerSigTaskData* peer_sig = appGetPeerSig();
    peer_sig->pair_handset_task = pair_handset_task;
}

/* Register task to receive AVRCP_PEER_CMD_STARTUP_SYNC. */
void appPeerSigStartupSyncTaskRegister(Task startup_sync_task)
{
    peerSigTaskData* peer_sig = appGetPeerSig();
    peer_sig->sync_task = startup_sync_task;
}

/* Force peer signalling to disconnect AVRCP if it is up. */
void appPeerSigForceDisconnect(void)
{
    peerSigTaskData *peer_sig = appGetPeerSig();
    MessageSendConditionally(&peer_sig->task, PEER_SIG_INTERNAL_SHUTDOWN_REQ, NULL, &peer_sig->lock);
}

/******************************************************************************
 * TEST FUNCTIONS
 ******************************************************************************/
void appPeerSigForceLinkToPeer(void)
{
    appDeviceAttributes attr;
    bdaddr peer_addr;

    if (appDeviceGetPeerAttributes(&peer_addr, &attr))
    {
        appPeerSigConnect(&peer_addr);
    }
    else
        DEBUG_LOG("No peer earbud paired");
}
