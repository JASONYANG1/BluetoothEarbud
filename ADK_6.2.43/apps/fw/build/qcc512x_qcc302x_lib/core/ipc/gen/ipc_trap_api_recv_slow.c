/*
 * This file is autogenerated from api.xml by api_codegen.py
 */
#include "memory_map.h"
#if TRAPSET_MICBIAS
    case IPC_SIGNAL_ID_MICBIAS_CONFIGURE:
    {
        const IPC_MICBIAS_CONFIGURE *ipc_prim = (const IPC_MICBIAS_CONFIGURE *)prim;
        vm_trap_MicbiasConfigure
        (
            ipc_prim->mic,
            ipc_prim->key,
            ipc_prim->value
        );
    }
        break;
#endif /* TRAPSET_MICBIAS */


#if TRAPSET_USB
    case IPC_SIGNAL_ID_USB_ATTACHED_STATUS:
    {
        rsp_prim.ipc_usb_attached_status_rsp.ret = vm_trap_UsbAttachedStatus
        (
        );
        ipc_send(IPC_SIGNAL_ID_USB_ATTACHED_STATUS_RSP,
                 &rsp_prim.ipc_usb_attached_status_rsp,
                 sizeof(rsp_prim.ipc_usb_attached_status_rsp));
    }
        break;
    case IPC_SIGNAL_ID_USB_ADD_INTERFACE:
    {
        const IPC_USB_ADD_INTERFACE *ipc_prim = (const IPC_USB_ADD_INTERFACE *)prim;
        vm_trap_UsbAddInterface
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->codes, const UsbCodes *)
#else
            ipc_prim->codes
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->type,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->if_descriptor, const uint8 *)
#else
            ipc_prim->if_descriptor
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->descriptor_length
        );
    }
        break;
    case IPC_SIGNAL_ID_USB_ADD_END_POINTS:
    {
        const IPC_USB_ADD_END_POINTS *ipc_prim = (const IPC_USB_ADD_END_POINTS *)prim;
        vm_trap_UsbAddEndPoints
        (
            ipc_prim->interface,
            ipc_prim->num_end_points,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->end_point_info, const EndPointInfo *)
#else
            ipc_prim->end_point_info
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            
        );
    }
        break;
    case IPC_SIGNAL_ID_USB_ADD_DESCRIPTOR:
    {
        const IPC_USB_ADD_DESCRIPTOR *ipc_prim = (const IPC_USB_ADD_DESCRIPTOR *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_UsbAddDescriptor
        (
            ipc_prim->interface,
            ipc_prim->type,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->descriptor, const uint8 *)
#else
            ipc_prim->descriptor
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->descriptor_length
        );
        ipc_send(IPC_SIGNAL_ID_USB_ADD_DESCRIPTOR_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_USB_ADD_STRING_DESCRIPTOR:
    {
        const IPC_USB_ADD_STRING_DESCRIPTOR *ipc_prim = (const IPC_USB_ADD_STRING_DESCRIPTOR *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_UsbAddStringDescriptor
        (
            ipc_prim->string_index,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->string_descriptor, const uint16 *)
#else
            ipc_prim->string_descriptor
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            
        );
        ipc_send(IPC_SIGNAL_ID_USB_ADD_STRING_DESCRIPTOR_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_USB_ADD_INTERFACE_ASSOCIATION_DESCRIPTOR:
    {
        const IPC_USB_ADD_INTERFACE_ASSOCIATION_DESCRIPTOR *ipc_prim = (const IPC_USB_ADD_INTERFACE_ASSOCIATION_DESCRIPTOR *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_UsbAddInterfaceAssociationDescriptor
        (
            ipc_prim->if_num,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->ia_descriptor, const uint8 *)
#else
            ipc_prim->ia_descriptor
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->descriptor_length
        );
        ipc_send(IPC_SIGNAL_ID_USB_ADD_INTERFACE_ASSOCIATION_DESCRIPTOR_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_USB_CLASS_SINK:
    {
        const IPC_STREAM_USB_CLASS_SINK *ipc_prim = (const IPC_STREAM_USB_CLASS_SINK *)prim;
        rsp_prim.ipc_sink_rsp.ret = vm_trap_StreamUsbClassSink
        (
            ipc_prim->interface
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_USB_CLASS_SINK_RSP,
                 &rsp_prim.ipc_sink_rsp,
                 sizeof(rsp_prim.ipc_sink_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_USB_END_POINT_SINK:
    {
        const IPC_STREAM_USB_END_POINT_SINK *ipc_prim = (const IPC_STREAM_USB_END_POINT_SINK *)prim;
        rsp_prim.ipc_sink_rsp.ret = vm_trap_StreamUsbEndPointSink
        (
            ipc_prim->end_point
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_USB_END_POINT_SINK_RSP,
                 &rsp_prim.ipc_sink_rsp,
                 sizeof(rsp_prim.ipc_sink_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_USB_VENDOR_SINK:
    {
        rsp_prim.ipc_sink_rsp.ret = vm_trap_StreamUsbVendorSink
        (
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_USB_VENDOR_SINK_RSP,
                 &rsp_prim.ipc_sink_rsp,
                 sizeof(rsp_prim.ipc_sink_rsp));
    }
        break;
    case IPC_SIGNAL_ID_USB_ADD_CONFIGURATION:
    {
        const IPC_USB_ADD_CONFIGURATION *ipc_prim = (const IPC_USB_ADD_CONFIGURATION *)prim;
        vm_trap_UsbAddConfiguration
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->desc_info, const ConfigDescriptorInfo *)
#else
            ipc_prim->desc_info
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            
        );
    }
        break;
    case IPC_SIGNAL_ID_USB_DEVICE_STATE:
    {
        rsp_prim.ipc_usb_device_state_rsp.ret = vm_trap_UsbDeviceState
        (
        );
        ipc_send(IPC_SIGNAL_ID_USB_DEVICE_STATE_RSP,
                 &rsp_prim.ipc_usb_device_state_rsp,
                 sizeof(rsp_prim.ipc_usb_device_state_rsp));
    }
        break;
#endif /* TRAPSET_USB */


#if TRAPSET_RFCOMM
    case IPC_SIGNAL_ID_STREAM_RFCOMM_SINK:
    {
        const IPC_STREAM_RFCOMM_SINK *ipc_prim = (const IPC_STREAM_RFCOMM_SINK *)prim;
        rsp_prim.ipc_sink_rsp.ret = vm_trap_StreamRfcommSink
        (
            ipc_prim->conn_id
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_RFCOMM_SINK_RSP,
                 &rsp_prim.ipc_sink_rsp,
                 sizeof(rsp_prim.ipc_sink_rsp));
    }
        break;
    case IPC_SIGNAL_ID_SINK_GET_RFCOMM_CONN_ID:
    {
        const IPC_SINK_GET_RFCOMM_CONN_ID *ipc_prim = (const IPC_SINK_GET_RFCOMM_CONN_ID *)prim;
        rsp_prim.ipc_uint16_rsp.ret = vm_trap_SinkGetRfcommConnId
        (
            ipc_prim->sink
        );
        ipc_send(IPC_SIGNAL_ID_SINK_GET_RFCOMM_CONN_ID_RSP,
                 &rsp_prim.ipc_uint16_rsp,
                 sizeof(rsp_prim.ipc_uint16_rsp));
    }
        break;
#endif /* TRAPSET_RFCOMM */


#if TRAPSET_AUDIO_MCLK
    case IPC_SIGNAL_ID_AUDIO_MASTER_CLOCK_CONFIGURE:
    {
        const IPC_AUDIO_MASTER_CLOCK_CONFIGURE *ipc_prim = (const IPC_AUDIO_MASTER_CLOCK_CONFIGURE *)prim;
        vm_trap_AudioMasterClockConfigure
        (
            ipc_prim->use_external,
            ipc_prim->frequency
        );
    }
        break;
    case IPC_SIGNAL_ID_SOURCE_MASTER_CLOCK_ENABLE:
    {
        const IPC_SOURCE_MASTER_CLOCK_ENABLE *ipc_prim = (const IPC_SOURCE_MASTER_CLOCK_ENABLE *)prim;
        vm_trap_SourceMasterClockEnable
        (
            ipc_prim->source,
            ipc_prim->enable
        );
    }
        break;
    case IPC_SIGNAL_ID_SINK_MASTER_CLOCK_ENABLE:
    {
        const IPC_SINK_MASTER_CLOCK_ENABLE *ipc_prim = (const IPC_SINK_MASTER_CLOCK_ENABLE *)prim;
        vm_trap_SinkMasterClockEnable
        (
            ipc_prim->sink,
            ipc_prim->enable
        );
    }
        break;
#endif /* TRAPSET_AUDIO_MCLK */


#if TRAPSET_CHARGER
    case IPC_SIGNAL_ID_CHARGER_CONFIGURE:
    {
        const IPC_CHARGER_CONFIGURE *ipc_prim = (const IPC_CHARGER_CONFIGURE *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_ChargerConfigure
        (
            ipc_prim->key,
            ipc_prim->value
        );
        ipc_send(IPC_SIGNAL_ID_CHARGER_CONFIGURE_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_CHARGER_STATUS:
    {
        rsp_prim.ipc_charger_status_rsp.ret = vm_trap_ChargerStatus
        (
        );
        ipc_send(IPC_SIGNAL_ID_CHARGER_STATUS_RSP,
                 &rsp_prim.ipc_charger_status_rsp,
                 sizeof(rsp_prim.ipc_charger_status_rsp));
    }
        break;
#endif /* TRAPSET_CHARGER */


#if TRAPSET_ATT
    case IPC_SIGNAL_ID_STREAM_ATT_SOURCE:
    {
        const IPC_STREAM_ATT_SOURCE *ipc_prim = (const IPC_STREAM_ATT_SOURCE *)prim;
        rsp_prim.ipc_source_rsp.ret = vm_trap_StreamAttSource
        (
            ipc_prim->cid,
            ipc_prim->handle
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_ATT_SOURCE_RSP,
                 &rsp_prim.ipc_source_rsp,
                 sizeof(rsp_prim.ipc_source_rsp));
    }
        break;
    case IPC_SIGNAL_ID_VM_CLEAR_ADVERTISING_REPORT_FILTER:
    {
        vm_trap_VmClearAdvertisingReportFilter
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_ADD_ADVERTISING_REPORT_FILTER:
    {
        const IPC_VM_ADD_ADVERTISING_REPORT_FILTER *ipc_prim = (const IPC_VM_ADD_ADVERTISING_REPORT_FILTER *)prim;
        vm_trap_VmAddAdvertisingReportFilter
        (
            ipc_prim->operation,
            ipc_prim->ad_type,
            ipc_prim->interval,
            ipc_prim->pattern_length,
            ipc_prim->pattern_addr
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_ATT_SOURCE_ADD_HANDLE:
    {
        const IPC_STREAM_ATT_SOURCE_ADD_HANDLE *ipc_prim = (const IPC_STREAM_ATT_SOURCE_ADD_HANDLE *)prim;
        rsp_prim.ipc_source_rsp.ret = vm_trap_StreamAttSourceAddHandle
        (
            ipc_prim->cid,
            ipc_prim->handle
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_ATT_SOURCE_ADD_HANDLE_RSP,
                 &rsp_prim.ipc_source_rsp,
                 sizeof(rsp_prim.ipc_source_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_ATT_SOURCE_REMOVE_ALL_HANDLES:
    {
        const IPC_STREAM_ATT_SOURCE_REMOVE_ALL_HANDLES *ipc_prim = (const IPC_STREAM_ATT_SOURCE_REMOVE_ALL_HANDLES *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_StreamAttSourceRemoveAllHandles
        (
            ipc_prim->cid
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_ATT_SOURCE_REMOVE_ALL_HANDLES_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_ATT_SINK:
    {
        const IPC_STREAM_ATT_SINK *ipc_prim = (const IPC_STREAM_ATT_SINK *)prim;
        rsp_prim.ipc_sink_rsp.ret = vm_trap_StreamAttSink
        (
            ipc_prim->cid
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_ATT_SINK_RSP,
                 &rsp_prim.ipc_sink_rsp,
                 sizeof(rsp_prim.ipc_sink_rsp));
    }
        break;
#endif /* TRAPSET_ATT */


#if TRAPSET_FILE
    case IPC_SIGNAL_ID_FILE_FIND:
    {
        const IPC_FILE_FIND *ipc_prim = (const IPC_FILE_FIND *)prim;
        vm_trap_FileFind
        (
            ipc_prim->start,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->name, const char *)
#else
            ipc_prim->name
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->length
        );
    }
        break;
    case IPC_SIGNAL_ID_FILE_TYPE:
    {
        const IPC_FILE_TYPE *ipc_prim = (const IPC_FILE_TYPE *)prim;
        rsp_prim.ipc_file_type_rsp.ret = vm_trap_FileType
        (
            ipc_prim->index
        );
        ipc_send(IPC_SIGNAL_ID_FILE_TYPE_RSP,
                 &rsp_prim.ipc_file_type_rsp,
                 sizeof(rsp_prim.ipc_file_type_rsp));
    }
        break;
    case IPC_SIGNAL_ID_FILE_PARENT:
    {
        const IPC_FILE_PARENT *ipc_prim = (const IPC_FILE_PARENT *)prim;
        rsp_prim.ipc_file_index_rsp.ret = vm_trap_FileParent
        (
            ipc_prim->item
        );
        ipc_send(IPC_SIGNAL_ID_FILE_PARENT_RSP,
                 &rsp_prim.ipc_file_index_rsp,
                 sizeof(rsp_prim.ipc_file_index_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_FILE_SOURCE:
    {
        const IPC_STREAM_FILE_SOURCE *ipc_prim = (const IPC_STREAM_FILE_SOURCE *)prim;
        vm_trap_StreamFileSource
        (
            ipc_prim->index
        );
    }
        break;
    case IPC_SIGNAL_ID_FILE_CREATE:
    {
        const IPC_FILE_CREATE *ipc_prim = (const IPC_FILE_CREATE *)prim;
        vm_trap_FileCreate
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->name, const char *)
#else
            ipc_prim->name
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->length
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_FILE_SINK:
    {
        const IPC_STREAM_FILE_SINK *ipc_prim = (const IPC_STREAM_FILE_SINK *)prim;
        vm_trap_StreamFileSink
        (
            ipc_prim->index
        );
    }
        break;
    case IPC_SIGNAL_ID_FILE_DELETE:
    {
        const IPC_FILE_DELETE *ipc_prim = (const IPC_FILE_DELETE *)prim;
        vm_trap_FileDelete
        (
            ipc_prim->index
        );
    }
        break;
    case IPC_SIGNAL_ID_FILE_RENAME:
    {
        const IPC_FILE_RENAME *ipc_prim = (const IPC_FILE_RENAME *)prim;
        vm_trap_FileRename
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->old_path, const char *)
#else
            ipc_prim->old_path
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->old_path_len,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->new_path, const char *)
#else
            ipc_prim->new_path
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->new_path_len
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_FILESYSTEM_SOURCE:
    {
        const IPC_STREAM_FILESYSTEM_SOURCE *ipc_prim = (const IPC_STREAM_FILESYSTEM_SOURCE *)prim;
        vm_trap_StreamFilesystemSource
        (
            ipc_prim->filesystem_id
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_FILESYSTEM_SINK:
    {
        const IPC_STREAM_FILESYSTEM_SINK *ipc_prim = (const IPC_STREAM_FILESYSTEM_SINK *)prim;
        vm_trap_StreamFilesystemSink
        (
            ipc_prim->filesystem_id
        );
    }
        break;
    case IPC_SIGNAL_ID_FILE_SYSTEM_UNMOUNT:
    {
        const IPC_FILE_SYSTEM_UNMOUNT *ipc_prim = (const IPC_FILE_SYSTEM_UNMOUNT *)prim;
        vm_trap_FileSystemUnmount
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->mount_path, const char *)
#else
            ipc_prim->mount_path
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            
        );
    }
        break;
#endif /* TRAPSET_FILE */


#if TRAPSET_IMAGEUPGRADE
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_GET_INFO:
    {
        const IPC_IMAGE_UPGRADE_GET_INFO *ipc_prim = (const IPC_IMAGE_UPGRADE_GET_INFO *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_ImageUpgradeGetInfo
        (
            ipc_prim->qspi,
            ipc_prim->image_section,
            ipc_prim->key,
            ipc_prim->value
        );
        ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_GET_INFO_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_STREAM_GET_SINK:
    {
        const IPC_IMAGE_UPGRADE_STREAM_GET_SINK *ipc_prim = (const IPC_IMAGE_UPGRADE_STREAM_GET_SINK *)prim;
        rsp_prim.ipc_sink_rsp.ret = vm_trap_ImageUpgradeStreamGetSink
        (
            ipc_prim->qspi,
            ipc_prim->image_section,
            ipc_prim->first_word
        );
        ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_STREAM_GET_SINK_RSP,
                 &rsp_prim.ipc_sink_rsp,
                 sizeof(rsp_prim.ipc_sink_rsp));
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_SINK_GET_POSITION:
    {
        const IPC_IMAGE_UPGRADE_SINK_GET_POSITION *ipc_prim = (const IPC_IMAGE_UPGRADE_SINK_GET_POSITION *)prim;
        vm_trap_ImageUpgradeSinkGetPosition
        (
            ipc_prim->sink,
            ipc_prim->offset
        );
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_ERASE:
    {
        vm_trap_ImageUpgradeErase
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_SWAP_TRY:
    {
        vm_trap_ImageUpgradeSwapTry
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_SWAP_TRY_STATUS:
    {
        rsp_prim.ipc_bool_rsp.ret = vm_trap_ImageUpgradeSwapTryStatus
        (
        );
        ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_SWAP_TRY_STATUS_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_SWAP_COMMIT:
    {
        vm_trap_ImageUpgradeSwapCommit
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_INITIALISE:
    {
        const IPC_IMAGE_UPGRADE_HASH_INITIALISE *ipc_prim = (const IPC_IMAGE_UPGRADE_HASH_INITIALISE *)prim;
        rsp_prim.ipc_hash_context_t_rsp.ret = vm_trap_ImageUpgradeHashInitialise
        (
            ipc_prim->algo
        );
        ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_INITIALISE_RSP,
                 &rsp_prim.ipc_hash_context_t_rsp,
                 sizeof(rsp_prim.ipc_hash_context_t_rsp));
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_SECTION_UPDATE:
    {
        const IPC_IMAGE_UPGRADE_HASH_SECTION_UPDATE *ipc_prim = (const IPC_IMAGE_UPGRADE_HASH_SECTION_UPDATE *)prim;
        vm_trap_ImageUpgradeHashSectionUpdate
        (
            ipc_prim->context,
            ipc_prim->image_section
        );
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_MSG_UPDATE:
    {
        const IPC_IMAGE_UPGRADE_HASH_MSG_UPDATE *ipc_prim = (const IPC_IMAGE_UPGRADE_HASH_MSG_UPDATE *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_ImageUpgradeHashMsgUpdate
        (
            ipc_prim->context,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->msg, const uint8 *)
#else
            ipc_prim->msg
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->msg_len_bytes
        );
        ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_MSG_UPDATE_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_FINALISE:
    {
        const IPC_IMAGE_UPGRADE_HASH_FINALISE *ipc_prim = (const IPC_IMAGE_UPGRADE_HASH_FINALISE *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_ImageUpgradeHashFinalise
        (
            ipc_prim->context,
            ipc_prim->hash,
            ipc_prim->hash_len_bytes
        );
        ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_FINALISE_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_COPY:
    {
        vm_trap_ImageUpgradeCopy
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_ABORT_COMMAND:
    {
        rsp_prim.ipc_bool_rsp.ret = vm_trap_ImageUpgradeAbortCommand
        (
        );
        ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_ABORT_COMMAND_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_AUDIO:
    {
        vm_trap_ImageUpgradeAudio
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_ALL_SECTIONS_UPDATE:
    {
        const IPC_IMAGE_UPGRADE_HASH_ALL_SECTIONS_UPDATE *ipc_prim = (const IPC_IMAGE_UPGRADE_HASH_ALL_SECTIONS_UPDATE *)prim;
        vm_trap_ImageUpgradeHashAllSectionsUpdate
        (
            ipc_prim->context
        );
    }
        break;
#endif /* TRAPSET_IMAGEUPGRADE */


#if TRAPSET_IICSTREAM
    case IPC_SIGNAL_ID_STREAM_I2C_SOURCE:
    {
        const IPC_STREAM_I2C_SOURCE *ipc_prim = (const IPC_STREAM_I2C_SOURCE *)prim;
        rsp_prim.ipc_source_rsp.ret = vm_trap_StreamI2cSource
        (
            ipc_prim->slave_addr,
            ipc_prim->array_addr,
            ipc_prim->size
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_I2C_SOURCE_RSP,
                 &rsp_prim.ipc_source_rsp,
                 sizeof(rsp_prim.ipc_source_rsp));
    }
        break;
#endif /* TRAPSET_IICSTREAM */


#if TRAPSET_CSB
    case IPC_SIGNAL_ID_STREAM_CSB_SINK:
    {
        const IPC_STREAM_CSB_SINK *ipc_prim = (const IPC_STREAM_CSB_SINK *)prim;
        rsp_prim.ipc_sink_rsp.ret = vm_trap_StreamCsbSink
        (
            ipc_prim->lt_addr
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_CSB_SINK_RSP,
                 &rsp_prim.ipc_sink_rsp,
                 sizeof(rsp_prim.ipc_sink_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_CSB_SOURCE:
    {
        const IPC_STREAM_CSB_SOURCE *ipc_prim = (const IPC_STREAM_CSB_SOURCE *)prim;
        rsp_prim.ipc_source_rsp.ret = vm_trap_StreamCsbSource
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->remote_addr, const BD_ADDR_T *)
#else
            ipc_prim->remote_addr
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->lt_addr
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_CSB_SOURCE_RSP,
                 &rsp_prim.ipc_source_rsp,
                 sizeof(rsp_prim.ipc_source_rsp));
    }
        break;
    case IPC_SIGNAL_ID_CSB_RECEIVER_SET_AFH_MAP:
    {
        const IPC_CSB_RECEIVER_SET_AFH_MAP *ipc_prim = (const IPC_CSB_RECEIVER_SET_AFH_MAP *)prim;
        vm_trap_CsbReceiverSetAfhMap
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->remote_addr, const BD_ADDR_T *)
#else
            ipc_prim->remote_addr
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->lt_addr,
            ipc_prim->afh_map,
            ipc_prim->afh_instant
        );
    }
        break;
    case IPC_SIGNAL_ID_CSB_TRANSMITTER_SET_AFH_MAP:
    {
        const IPC_CSB_TRANSMITTER_SET_AFH_MAP *ipc_prim = (const IPC_CSB_TRANSMITTER_SET_AFH_MAP *)prim;
        vm_trap_CsbTransmitterSetAfhMap
        (
            ipc_prim->lt_addr,
            ipc_prim->afh_map,
            ipc_prim->afh_instant
        );
    }
        break;
    case IPC_SIGNAL_ID_CSB_ENABLE_NEW_AFH_MAP_EVENT:
    {
        const IPC_CSB_ENABLE_NEW_AFH_MAP_EVENT *ipc_prim = (const IPC_CSB_ENABLE_NEW_AFH_MAP_EVENT *)prim;
        vm_trap_CsbEnableNewAfhMapEvent
        (
            ipc_prim->enable
        );
    }
        break;
#endif /* TRAPSET_CSB */


#if TRAPSET_STREAM
    case IPC_SIGNAL_ID_STREAM_MOVE:
    {
        const IPC_STREAM_MOVE *ipc_prim = (const IPC_STREAM_MOVE *)prim;
        rsp_prim.ipc_uint16_rsp.ret = vm_trap_StreamMove
        (
            ipc_prim->sink,
            ipc_prim->source,
            ipc_prim->count
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_MOVE_RSP,
                 &rsp_prim.ipc_uint16_rsp,
                 sizeof(rsp_prim.ipc_uint16_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_CONNECT:
    {
        const IPC_STREAM_CONNECT *ipc_prim = (const IPC_STREAM_CONNECT *)prim;
        vm_trap_StreamConnect
        (
            ipc_prim->source,
            ipc_prim->sink
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_CONNECT_DISPOSE:
    {
        const IPC_STREAM_CONNECT_DISPOSE *ipc_prim = (const IPC_STREAM_CONNECT_DISPOSE *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_StreamConnectDispose
        (
            ipc_prim->source
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_CONNECT_DISPOSE_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_DISCONNECT:
    {
        const IPC_STREAM_DISCONNECT *ipc_prim = (const IPC_STREAM_DISCONNECT *)prim;
        vm_trap_StreamDisconnect
        (
            ipc_prim->source,
            ipc_prim->sink
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_CONFIGURE:
    {
        const IPC_STREAM_CONFIGURE *ipc_prim = (const IPC_STREAM_CONFIGURE *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_StreamConfigure
        (
            ipc_prim->key,
            ipc_prim->value
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_CONFIGURE_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_SOURCE_CONFIGURE:
    {
        const IPC_SOURCE_CONFIGURE *ipc_prim = (const IPC_SOURCE_CONFIGURE *)prim;
        vm_trap_SourceConfigure
        (
            ipc_prim->source,
            ipc_prim->key,
            ipc_prim->value
        );
    }
        break;
    case IPC_SIGNAL_ID_SINK_CONFIGURE:
    {
        const IPC_SINK_CONFIGURE *ipc_prim = (const IPC_SINK_CONFIGURE *)prim;
        vm_trap_SinkConfigure
        (
            ipc_prim->sink,
            ipc_prim->key,
            ipc_prim->value
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_SOURCE_FROM_SINK:
    {
        const IPC_STREAM_SOURCE_FROM_SINK *ipc_prim = (const IPC_STREAM_SOURCE_FROM_SINK *)prim;
        vm_trap_StreamSourceFromSink
        (
            ipc_prim->sink
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_SINK_FROM_SOURCE:
    {
        const IPC_STREAM_SINK_FROM_SOURCE *ipc_prim = (const IPC_STREAM_SINK_FROM_SOURCE *)prim;
        vm_trap_StreamSinkFromSource
        (
            ipc_prim->source
        );
    }
        break;
    case IPC_SIGNAL_ID_SOURCE_CLOSE:
    {
        const IPC_SOURCE_CLOSE *ipc_prim = (const IPC_SOURCE_CLOSE *)prim;
        vm_trap_SourceClose
        (
            ipc_prim->source
        );
    }
        break;
    case IPC_SIGNAL_ID_SINK_CLOSE:
    {
        const IPC_SINK_CLOSE *ipc_prim = (const IPC_SINK_CLOSE *)prim;
        vm_trap_SinkClose
        (
            ipc_prim->sink
        );
    }
        break;
    case IPC_SIGNAL_ID_SINK_ALIAS:
    {
        const IPC_SINK_ALIAS *ipc_prim = (const IPC_SINK_ALIAS *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_SinkAlias
        (
            ipc_prim->sink1,
            ipc_prim->sink2
        );
        ipc_send(IPC_SIGNAL_ID_SINK_ALIAS_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_SINK_SYNCHRONISE:
    {
        const IPC_SINK_SYNCHRONISE *ipc_prim = (const IPC_SINK_SYNCHRONISE *)prim;
        vm_trap_SinkSynchronise
        (
            ipc_prim->sink1,
            ipc_prim->sink2
        );
    }
        break;
    case IPC_SIGNAL_ID_SOURCE_SYNCHRONISE:
    {
        const IPC_SOURCE_SYNCHRONISE *ipc_prim = (const IPC_SOURCE_SYNCHRONISE *)prim;
        vm_trap_SourceSynchronise
        (
            ipc_prim->source1,
            ipc_prim->source2
        );
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_START:
    {
        const IPC_TRANSFORM_START *ipc_prim = (const IPC_TRANSFORM_START *)prim;
        vm_trap_TransformStart
        (
            ipc_prim->transform
        );
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_STOP:
    {
        const IPC_TRANSFORM_STOP *ipc_prim = (const IPC_TRANSFORM_STOP *)prim;
        vm_trap_TransformStop
        (
            ipc_prim->transform
        );
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_DISCONNECT:
    {
        const IPC_TRANSFORM_DISCONNECT *ipc_prim = (const IPC_TRANSFORM_DISCONNECT *)prim;
        vm_trap_TransformDisconnect
        (
            ipc_prim->transform
        );
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_POLL_TRAFFIC:
    {
        const IPC_TRANSFORM_POLL_TRAFFIC *ipc_prim = (const IPC_TRANSFORM_POLL_TRAFFIC *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_TransformPollTraffic
        (
            ipc_prim->transform
        );
        ipc_send(IPC_SIGNAL_ID_TRANSFORM_POLL_TRAFFIC_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_FROM_SOURCE:
    {
        const IPC_TRANSFORM_FROM_SOURCE *ipc_prim = (const IPC_TRANSFORM_FROM_SOURCE *)prim;
        rsp_prim.ipc_transform_rsp.ret = vm_trap_TransformFromSource
        (
            ipc_prim->source
        );
        ipc_send(IPC_SIGNAL_ID_TRANSFORM_FROM_SOURCE_RSP,
                 &rsp_prim.ipc_transform_rsp,
                 sizeof(rsp_prim.ipc_transform_rsp));
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_FROM_SINK:
    {
        const IPC_TRANSFORM_FROM_SINK *ipc_prim = (const IPC_TRANSFORM_FROM_SINK *)prim;
        rsp_prim.ipc_transform_rsp.ret = vm_trap_TransformFromSink
        (
            ipc_prim->sink
        );
        ipc_send(IPC_SIGNAL_ID_TRANSFORM_FROM_SINK_RSP,
                 &rsp_prim.ipc_transform_rsp,
                 sizeof(rsp_prim.ipc_transform_rsp));
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_CONFIGURE:
    {
        const IPC_TRANSFORM_CONFIGURE *ipc_prim = (const IPC_TRANSFORM_CONFIGURE *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_TransformConfigure
        (
            ipc_prim->transform,
            ipc_prim->key,
            ipc_prim->value
        );
        ipc_send(IPC_SIGNAL_ID_TRANSFORM_CONFIGURE_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_REGION_SOURCE:
    {
        const IPC_STREAM_REGION_SOURCE *ipc_prim = (const IPC_STREAM_REGION_SOURCE *)prim;
        rsp_prim.ipc_source_rsp.ret = vm_trap_StreamRegionSource
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->data, const uint8 *)
#else
            ipc_prim->data
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->length
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_REGION_SOURCE_RSP,
                 &rsp_prim.ipc_source_rsp,
                 sizeof(rsp_prim.ipc_source_rsp));
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_CHUNK:
    {
        const IPC_TRANSFORM_CHUNK *ipc_prim = (const IPC_TRANSFORM_CHUNK *)prim;
        rsp_prim.ipc_transform_rsp.ret = vm_trap_TransformChunk
        (
            ipc_prim->source,
            ipc_prim->sink
        );
        ipc_send(IPC_SIGNAL_ID_TRANSFORM_CHUNK_RSP,
                 &rsp_prim.ipc_transform_rsp,
                 sizeof(rsp_prim.ipc_transform_rsp));
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_SLICE:
    {
        const IPC_TRANSFORM_SLICE *ipc_prim = (const IPC_TRANSFORM_SLICE *)prim;
        rsp_prim.ipc_transform_rsp.ret = vm_trap_TransformSlice
        (
            ipc_prim->source,
            ipc_prim->sink
        );
        ipc_send(IPC_SIGNAL_ID_TRANSFORM_SLICE_RSP,
                 &rsp_prim.ipc_transform_rsp,
                 sizeof(rsp_prim.ipc_transform_rsp));
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_ADPCM_DECODE:
    {
        const IPC_TRANSFORM_ADPCM_DECODE *ipc_prim = (const IPC_TRANSFORM_ADPCM_DECODE *)prim;
        rsp_prim.ipc_transform_rsp.ret = vm_trap_TransformAdpcmDecode
        (
            ipc_prim->source,
            ipc_prim->sink
        );
        ipc_send(IPC_SIGNAL_ID_TRANSFORM_ADPCM_DECODE_RSP,
                 &rsp_prim.ipc_transform_rsp,
                 sizeof(rsp_prim.ipc_transform_rsp));
    }
        break;
    case IPC_SIGNAL_ID_SINK_MAP_INIT:
    {
        const IPC_SINK_MAP_INIT *ipc_prim = (const IPC_SINK_MAP_INIT *)prim;
        vm_trap_SinkMapInit
        (
            ipc_prim->sink,
            ipc_prim->device,
            ipc_prim->header_len
        );
    }
        break;
    case IPC_SIGNAL_ID_SOURCE_MAP_INIT:
    {
        const IPC_SOURCE_MAP_INIT *ipc_prim = (const IPC_SOURCE_MAP_INIT *)prim;
        vm_trap_SourceMapInit
        (
            ipc_prim->source,
            ipc_prim->device,
            ipc_prim->header_len
        );
    }
        break;
    case IPC_SIGNAL_ID_SINK_UNMAP:
    {
        const IPC_SINK_UNMAP *ipc_prim = (const IPC_SINK_UNMAP *)prim;
        vm_trap_SinkUnmap
        (
            ipc_prim->sink
        );
    }
        break;
    case IPC_SIGNAL_ID_SOURCE_UNMAP:
    {
        const IPC_SOURCE_UNMAP *ipc_prim = (const IPC_SOURCE_UNMAP *)prim;
        vm_trap_SourceUnmap
        (
            ipc_prim->source
        );
    }
        break;
    case IPC_SIGNAL_ID_SINK_FLUSH_BLOCKING:
    {
        const IPC_SINK_FLUSH_BLOCKING *ipc_prim = (const IPC_SINK_FLUSH_BLOCKING *)prim;
        vm_trap_SinkFlushBlocking
        (
            ipc_prim->sink,
            ipc_prim->amount
        );
    }
        break;
    case IPC_SIGNAL_ID_TRANSFORM_PACKETISE:
    {
        const IPC_TRANSFORM_PACKETISE *ipc_prim = (const IPC_TRANSFORM_PACKETISE *)prim;
        rsp_prim.ipc_transform_rsp.ret = vm_trap_TransformPacketise
        (
            ipc_prim->source,
            ipc_prim->sink
        );
        ipc_send(IPC_SIGNAL_ID_TRANSFORM_PACKETISE_RSP,
                 &rsp_prim.ipc_transform_rsp,
                 sizeof(rsp_prim.ipc_transform_rsp));
    }
        break;
    case IPC_SIGNAL_ID_SINK_GET_BD_ADDR:
    {
        const IPC_SINK_GET_BD_ADDR *ipc_prim = (const IPC_SINK_GET_BD_ADDR *)prim;
        rsp_prim.ipc_sink_get_bd_addr_rsp.ret = vm_trap_SinkGetBdAddr
        (
            ipc_prim->sink,
            &rsp_prim.ipc_sink_get_bd_addr_rsp.tpaddr
        );
        ipc_send(IPC_SIGNAL_ID_SINK_GET_BD_ADDR_RSP,
                 &rsp_prim.ipc_sink_get_bd_addr_rsp,
                 sizeof(rsp_prim.ipc_sink_get_bd_addr_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_SINKS_FROM_BD_ADDR:
    {
        const IPC_STREAM_SINKS_FROM_BD_ADDR *ipc_prim = (const IPC_STREAM_SINKS_FROM_BD_ADDR *)prim;
        rsp_prim.ipc_stream_sinks_from_bd_addr_rsp.ret = vm_trap_StreamSinksFromBdAddr
        (
            ipc_prim->max,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->tpaddr, const TP_BD_ADDR_T *)
#else
            ipc_prim->tpaddr
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            &rsp_prim.ipc_stream_sinks_from_bd_addr_rsp.max,
            &rsp_prim.ipc_stream_sinks_from_bd_addr_rsp.sinks
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_SINKS_FROM_BD_ADDR_RSP,
                 &rsp_prim.ipc_stream_sinks_from_bd_addr_rsp,
                 sizeof(rsp_prim.ipc_stream_sinks_from_bd_addr_rsp));
    }
        break;
    case IPC_SIGNAL_ID_SINK_GET_RSSI:
    {
        const IPC_SINK_GET_RSSI *ipc_prim = (const IPC_SINK_GET_RSSI *)prim;
        vm_trap_SinkGetRssi
        (
            ipc_prim->sink
        );
    }
        break;
    case IPC_SIGNAL_ID_SINK_GET_WALLCLOCK:
    {
        const IPC_SINK_GET_WALLCLOCK *ipc_prim = (const IPC_SINK_GET_WALLCLOCK *)prim;
        rsp_prim.ipc_sink_get_wallclock_rsp.ret = vm_trap_SinkGetWallclock
        (
            ipc_prim->sink,
            &rsp_prim.ipc_sink_get_wallclock_rsp.wallclock
        );
        ipc_send(IPC_SIGNAL_ID_SINK_GET_WALLCLOCK_RSP,
                 &rsp_prim.ipc_sink_get_wallclock_rsp,
                 sizeof(rsp_prim.ipc_sink_get_wallclock_rsp));
    }
        break;
#endif /* TRAPSET_STREAM */


#if TRAPSET_AUDIO_ANC
    case IPC_SIGNAL_ID_AUDIO_ANC_STREAM_ENABLE:
    {
        const IPC_AUDIO_ANC_STREAM_ENABLE *ipc_prim = (const IPC_AUDIO_ANC_STREAM_ENABLE *)prim;
        vm_trap_AudioAncStreamEnable
        (
            ipc_prim->anc_enable_0,
            ipc_prim->anc_enable_1
        );
    }
        break;
    case IPC_SIGNAL_ID_AUDIO_ANC_FILTER_LPF_SET:
    {
        const IPC_AUDIO_ANC_FILTER_LPF_SET *ipc_prim = (const IPC_AUDIO_ANC_FILTER_LPF_SET *)prim;
        vm_trap_AudioAncFilterLpfSet
        (
            ipc_prim->anc_instance,
            ipc_prim->path_id,
            ipc_prim->shift1,
            ipc_prim->shift2
        );
    }
        break;
    case IPC_SIGNAL_ID_AUDIO_ANC_FILTER_IIR_SET:
    {
        const IPC_AUDIO_ANC_FILTER_IIR_SET *ipc_prim = (const IPC_AUDIO_ANC_FILTER_IIR_SET *)prim;
        vm_trap_AudioAncFilterIirSet
        (
            ipc_prim->anc_instance,
            ipc_prim->path_id,
            ipc_prim->num_coeffs,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->coeffs, const uint16 *)
#else
            ipc_prim->coeffs
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            
        );
    }
        break;
#endif /* TRAPSET_AUDIO_ANC */


#if TRAPSET_IIR
    case IPC_SIGNAL_ID_CODEC_SET_IIR_FILTER:
    {
        const IPC_CODEC_SET_IIR_FILTER *ipc_prim = (const IPC_CODEC_SET_IIR_FILTER *)prim;
        vm_trap_CodecSetIirFilter
        (
            ipc_prim->instance,
            ipc_prim->channel,
            ipc_prim->enable,
            ipc_prim->coefficients
        );
    }
        break;
#endif /* TRAPSET_IIR */


#if TRAPSET_UART
    case IPC_SIGNAL_ID_STREAM_UART_CONFIGURE:
    {
        const IPC_STREAM_UART_CONFIGURE *ipc_prim = (const IPC_STREAM_UART_CONFIGURE *)prim;
        vm_trap_StreamUartConfigure
        (
            ipc_prim->rate,
            ipc_prim->stop,
            ipc_prim->parity
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_UART_CONFIGURE_RSP,
                 &rsp_prim.ipc_void_rsp,
                 sizeof(rsp_prim.ipc_void_rsp));
    }
        break;
#endif /* TRAPSET_UART */


#if TRAPSET_SD_MMC
    case IPC_SIGNAL_ID_STREAM_SD_MMC_SOURCE:
    {
        const IPC_STREAM_SD_MMC_SOURCE *ipc_prim = (const IPC_STREAM_SD_MMC_SOURCE *)prim;
        rsp_prim.ipc_source_rsp.ret = vm_trap_StreamSdMmcSource
        (
            ipc_prim->slot,
            ipc_prim->start_block,
            ipc_prim->blocks_count
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_SD_MMC_SOURCE_RSP,
                 &rsp_prim.ipc_source_rsp,
                 sizeof(rsp_prim.ipc_source_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_SD_MMC_SINK:
    {
        const IPC_STREAM_SD_MMC_SINK *ipc_prim = (const IPC_STREAM_SD_MMC_SINK *)prim;
        rsp_prim.ipc_sink_rsp.ret = vm_trap_StreamSdMmcSink
        (
            ipc_prim->slot,
            ipc_prim->start_block,
            ipc_prim->blocks_count
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_SD_MMC_SINK_RSP,
                 &rsp_prim.ipc_sink_rsp,
                 sizeof(rsp_prim.ipc_sink_rsp));
    }
        break;
    case IPC_SIGNAL_ID_SD_MMC_DEVICE_INFO:
    {
        const IPC_SD_MMC_DEVICE_INFO *ipc_prim = (const IPC_SD_MMC_DEVICE_INFO *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_SdMmcDeviceInfo
        (
            ipc_prim->slot,
            ipc_prim->device_info
        );
        ipc_send(IPC_SIGNAL_ID_SD_MMC_DEVICE_INFO_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
#endif /* TRAPSET_SD_MMC */


#if TRAPSET_IIC
    case IPC_SIGNAL_ID_I2C_TRANSFER:
    {
        const IPC_I2C_TRANSFER *ipc_prim = (const IPC_I2C_TRANSFER *)prim;
        rsp_prim.ipc_uint16_rsp.ret = vm_trap_I2cTransfer
        (
            ipc_prim->address,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->tx, const uint8 *)
#else
            ipc_prim->tx
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->tx_len,
            ipc_prim->rx,
            ipc_prim->rx_len
        );
        ipc_send(IPC_SIGNAL_ID_I2C_TRANSFER_RSP,
                 &rsp_prim.ipc_uint16_rsp,
                 sizeof(rsp_prim.ipc_uint16_rsp));
    }
        break;
#endif /* TRAPSET_IIC */


#if TRAPSET_CAPACITIVE_SENSOR
    case IPC_SIGNAL_ID_CAPACITIVE_SENSOR_PAD_QUERY:
    {
        const IPC_CAPACITIVE_SENSOR_PAD_QUERY *ipc_prim = (const IPC_CAPACITIVE_SENSOR_PAD_QUERY *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_CapacitiveSensorPadQuery
        (
            ipc_prim->count,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->pads, const uint16*)
#else
            ipc_prim->pads
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->results
        );
        ipc_send(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_PAD_QUERY_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_CAPACITIVE_SENSOR_CONFIGURE_MULTI_PAD:
    {
        const IPC_CAPACITIVE_SENSOR_CONFIGURE_MULTI_PAD *ipc_prim = (const IPC_CAPACITIVE_SENSOR_CONFIGURE_MULTI_PAD *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_CapacitiveSensorConfigureMultiPad
        (
            ipc_prim->count,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->pads, const uint16 *)
#else
            ipc_prim->pads
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->common_config, const CAPACITIVE_SENSOR_PAD_CONFIG *)
#else
            ipc_prim->common_config
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            
        );
        ipc_send(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_CONFIGURE_MULTI_PAD_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_CAPACITIVE_SENSOR_ENABLE_PADS:
    {
        const IPC_CAPACITIVE_SENSOR_ENABLE_PADS *ipc_prim = (const IPC_CAPACITIVE_SENSOR_ENABLE_PADS *)prim;
        vm_trap_CapacitiveSensorEnablePads
        (
            ipc_prim->count,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->pads, const uint16 *)
#else
            ipc_prim->pads
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->pad_levels, const CAPACITIVE_SENSOR_PAD_LEVELS *)
#else
            ipc_prim->pad_levels
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            
        );
    }
        break;
    case IPC_SIGNAL_ID_CAPACITIVE_SENSOR_CONFIGURE_TOUCH_OFFSET:
    {
        const IPC_CAPACITIVE_SENSOR_CONFIGURE_TOUCH_OFFSET *ipc_prim = (const IPC_CAPACITIVE_SENSOR_CONFIGURE_TOUCH_OFFSET *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_CapacitiveSensorConfigureTouchOffset
        (
            ipc_prim->pad,
            ipc_prim->touch_offset
        );
        ipc_send(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_CONFIGURE_TOUCH_OFFSET_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
#endif /* TRAPSET_CAPACITIVE_SENSOR */


#if TRAPSET_CORE
    case IPC_SIGNAL_ID_UTIL_RANDOM:
    {
        vm_trap_UtilRandom
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_PS_STORE:
    {
        const IPC_PS_STORE *ipc_prim = (const IPC_PS_STORE *)prim;
        vm_trap_PsStore
        (
            ipc_prim->key,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->buff, const void *)
#else
            ipc_prim->buff
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->words
        );
    }
        break;
    case IPC_SIGNAL_ID_PS_RETRIEVE:
    {
        const IPC_PS_RETRIEVE *ipc_prim = (const IPC_PS_RETRIEVE *)prim;
        vm_trap_PsRetrieve
        (
            ipc_prim->key,
            ipc_prim->buff,
            ipc_prim->words
        );
    }
        break;
    case IPC_SIGNAL_ID_PS_FLOOD:
    {
        vm_trap_PsFlood
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_PS_FREE_COUNT:
    {
        const IPC_PS_FREE_COUNT *ipc_prim = (const IPC_PS_FREE_COUNT *)prim;
        rsp_prim.ipc_uint16_rsp.ret = vm_trap_PsFreeCount
        (
            ipc_prim->words
        );
        ipc_send(IPC_SIGNAL_ID_PS_FREE_COUNT_RSP,
                 &rsp_prim.ipc_uint16_rsp,
                 sizeof(rsp_prim.ipc_uint16_rsp));
    }
        break;
    case IPC_SIGNAL_ID_PS_FULL_RETRIEVE:
    {
        const IPC_PS_FULL_RETRIEVE *ipc_prim = (const IPC_PS_FULL_RETRIEVE *)prim;
        vm_trap_PsFullRetrieve
        (
            ipc_prim->key,
            ipc_prim->buff,
            ipc_prim->words
        );
    }
        break;
    case IPC_SIGNAL_ID_BOOT_GET_MODE:
    {
        rsp_prim.ipc_uint16_rsp.ret = vm_trap_BootGetMode
        (
        );
        ipc_send(IPC_SIGNAL_ID_BOOT_GET_MODE_RSP,
                 &rsp_prim.ipc_uint16_rsp,
                 sizeof(rsp_prim.ipc_uint16_rsp));
    }
        break;
    case IPC_SIGNAL_ID_BOOT_SET_MODE:
    {
        const IPC_BOOT_SET_MODE *ipc_prim = (const IPC_BOOT_SET_MODE *)prim;
        vm_trap_BootSetMode
        (
            ipc_prim->newBootmode
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_DEEP_SLEEP_ENABLE:
    {
        const IPC_VM_DEEP_SLEEP_ENABLE *ipc_prim = (const IPC_VM_DEEP_SLEEP_ENABLE *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_VmDeepSleepEnable
        (
            ipc_prim->en
        );
        ipc_send(IPC_SIGNAL_ID_VM_DEEP_SLEEP_ENABLE_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_VM_TRANSMIT_ENABLE:
    {
        const IPC_VM_TRANSMIT_ENABLE *ipc_prim = (const IPC_VM_TRANSMIT_ENABLE *)prim;
        vm_trap_VmTransmitEnable
        (
            ipc_prim->enabled
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_TRANSMIT_POWER_SET_DEFAULT:
    {
        const IPC_VM_TRANSMIT_POWER_SET_DEFAULT *ipc_prim = (const IPC_VM_TRANSMIT_POWER_SET_DEFAULT *)prim;
        vm_trap_VmTransmitPowerSetDefault
        (
            ipc_prim->power
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_TRANSMIT_POWER_SET_MAXIMUM:
    {
        const IPC_VM_TRANSMIT_POWER_SET_MAXIMUM *ipc_prim = (const IPC_VM_TRANSMIT_POWER_SET_MAXIMUM *)prim;
        vm_trap_VmTransmitPowerSetMaximum
        (
            ipc_prim->power
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_TRANSMIT_POWER_GET_DEFAULT:
    {
        vm_trap_VmTransmitPowerGetDefault
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_TRANSMIT_POWER_GET_MAXIMUM:
    {
        vm_trap_VmTransmitPowerGetMaximum
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_GET_TEMPERATURE:
    {
        vm_trap_VmGetTemperature
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_READ_VREF_CONSTANT:
    {
        rsp_prim.ipc_uint16_rsp.ret = vm_trap_VmReadVrefConstant
        (
        );
        ipc_send(IPC_SIGNAL_ID_VM_READ_VREF_CONSTANT_RSP,
                 &rsp_prim.ipc_uint16_rsp,
                 sizeof(rsp_prim.ipc_uint16_rsp));
    }
        break;
    case IPC_SIGNAL_ID_ADC_READ_REQUEST:
    {
        const IPC_ADC_READ_REQUEST *ipc_prim = (const IPC_ADC_READ_REQUEST *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_AdcReadRequest
        (
            ipc_prim->task,
            ipc_prim->adc_source,
            ipc_prim->extra_flag,
            ipc_prim->delay
        );
        ipc_send(IPC_SIGNAL_ID_ADC_READ_REQUEST_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_PS_UPDATE_AUDIO_KEY:
    {
        const IPC_PS_UPDATE_AUDIO_KEY *ipc_prim = (const IPC_PS_UPDATE_AUDIO_KEY *)prim;
        vm_trap_PsUpdateAudioKey
        (
            ipc_prim->key,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->buffer, const uint16 *)
#else
            ipc_prim->buffer
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->words,
            ipc_prim->offset,
            ipc_prim->key_length
        );
    }
        break;
    case IPC_SIGNAL_ID_PS_READ_AUDIO_KEY:
    {
        const IPC_PS_READ_AUDIO_KEY *ipc_prim = (const IPC_PS_READ_AUDIO_KEY *)prim;
        vm_trap_PsReadAudioKey
        (
            ipc_prim->key,
            ipc_prim->buffer,
            ipc_prim->words,
            ipc_prim->offset,
            ipc_prim->key_length_addr
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_GET_TEMPERATURE_BY_SENSOR:
    {
        const IPC_VM_GET_TEMPERATURE_BY_SENSOR *ipc_prim = (const IPC_VM_GET_TEMPERATURE_BY_SENSOR *)prim;
        vm_trap_VmGetTemperatureBySensor
        (
            ipc_prim->sensor
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_TRANSMIT_POWER_MESSAGES_ENABLE:
    {
        const IPC_VM_TRANSMIT_POWER_MESSAGES_ENABLE *ipc_prim = (const IPC_VM_TRANSMIT_POWER_MESSAGES_ENABLE *)prim;
        vm_trap_VmTransmitPowerMessagesEnable
        (
            ipc_prim->enable
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_GET_RESET_SOURCE:
    {
        rsp_prim.ipc_vm_reset_source_rsp.ret = vm_trap_VmGetResetSource
        (
        );
        ipc_send(IPC_SIGNAL_ID_VM_GET_RESET_SOURCE_RSP,
                 &rsp_prim.ipc_vm_reset_source_rsp,
                 sizeof(rsp_prim.ipc_vm_reset_source_rsp));
    }
        break;
    case IPC_SIGNAL_ID_VM_SOFTWARE_WD_KICK:
    {
        const IPC_VM_SOFTWARE_WD_KICK *ipc_prim = (const IPC_VM_SOFTWARE_WD_KICK *)prim;
        vm_trap_VmSoftwareWdKick
        (
            ipc_prim->timeout
        );
    }
        break;
    case IPC_SIGNAL_ID_FEATURE_VERIFY_LICENSE:
    {
        const IPC_FEATURE_VERIFY_LICENSE *ipc_prim = (const IPC_FEATURE_VERIFY_LICENSE *)prim;
        vm_trap_FeatureVerifyLicense
        (
            ipc_prim->feature
        );
    }
        break;
    case IPC_SIGNAL_ID_PS_SET_STORE:
    {
        const IPC_PS_SET_STORE *ipc_prim = (const IPC_PS_SET_STORE *)prim;
        vm_trap_PsSetStore
        (
            ipc_prim->store
        );
    }
        break;
    case IPC_SIGNAL_ID_PS_GET_STORE:
    {
        rsp_prim.ipc_psstores_rsp.ret = vm_trap_PsGetStore
        (
        );
        ipc_send(IPC_SIGNAL_ID_PS_GET_STORE_RSP,
                 &rsp_prim.ipc_psstores_rsp,
                 sizeof(rsp_prim.ipc_psstores_rsp));
    }
        break;
    case IPC_SIGNAL_ID_PIO_SET_WAKEUP_STATE_BANK:
    {
        const IPC_PIO_SET_WAKEUP_STATE_BANK *ipc_prim = (const IPC_PIO_SET_WAKEUP_STATE_BANK *)prim;
        vm_trap_PioSetWakeupStateBank
        (
            ipc_prim->bank,
            ipc_prim->mask,
            ipc_prim->value
        );
    }
        break;
    case IPC_SIGNAL_ID_PIO_SET_DEEP_SLEEP_EITHER_LEVEL_BANK:
    {
        const IPC_PIO_SET_DEEP_SLEEP_EITHER_LEVEL_BANK *ipc_prim = (const IPC_PIO_SET_DEEP_SLEEP_EITHER_LEVEL_BANK *)prim;
        vm_trap_PioSetDeepSleepEitherLevelBank
        (
            ipc_prim->bank,
            ipc_prim->mask,
            ipc_prim->value
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_DEEP_SLEEP_WAKE_SOURCES_ENABLE:
    {
        const IPC_VM_DEEP_SLEEP_WAKE_SOURCES_ENABLE *ipc_prim = (const IPC_VM_DEEP_SLEEP_WAKE_SOURCES_ENABLE *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_VmDeepSleepWakeSourcesEnable
        (
            ipc_prim->wake_source,
            ipc_prim->en
        );
        ipc_send(IPC_SIGNAL_ID_VM_DEEP_SLEEP_WAKE_SOURCES_ENABLE_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_DORMANT_CONFIGURE:
    {
        const IPC_DORMANT_CONFIGURE *ipc_prim = (const IPC_DORMANT_CONFIGURE *)prim;
        vm_trap_DormantConfigure
        (
            ipc_prim->key,
            ipc_prim->value
        );
    }
        break;
#endif /* TRAPSET_CORE */


#if TRAPSET_NFC
    case IPC_SIGNAL_ID_NFC_SEND_PRIM:
    {
        const IPC_NFC_SEND_PRIM *ipc_prim = (const IPC_NFC_SEND_PRIM *)prim;
        vm_trap_NfcSendPrim
        (
            ipc_prim->msg
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_NFC_SINK:
    {
        rsp_prim.ipc_sink_rsp.ret = vm_trap_StreamNfcSink
        (
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_NFC_SINK_RSP,
                 &rsp_prim.ipc_sink_rsp,
                 sizeof(rsp_prim.ipc_sink_rsp));
    }
        break;
#endif /* TRAPSET_NFC */


#if TRAPSET_BLUESTACK
    case IPC_SIGNAL_ID_STREAM_L2CAP_SINK:
    {
        const IPC_STREAM_L2CAP_SINK *ipc_prim = (const IPC_STREAM_L2CAP_SINK *)prim;
        rsp_prim.ipc_sink_rsp.ret = vm_trap_StreamL2capSink
        (
            ipc_prim->cid
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_L2CAP_SINK_RSP,
                 &rsp_prim.ipc_sink_rsp,
                 sizeof(rsp_prim.ipc_sink_rsp));
    }
        break;
    case IPC_SIGNAL_ID_SINK_GET_L2CAP_CID:
    {
        const IPC_SINK_GET_L2CAP_CID *ipc_prim = (const IPC_SINK_GET_L2CAP_CID *)prim;
        rsp_prim.ipc_uint16_rsp.ret = vm_trap_SinkGetL2capCid
        (
            ipc_prim->sink
        );
        ipc_send(IPC_SIGNAL_ID_SINK_GET_L2CAP_CID_RSP,
                 &rsp_prim.ipc_uint16_rsp,
                 sizeof(rsp_prim.ipc_uint16_rsp));
    }
        break;
    case IPC_SIGNAL_ID_SINK_POLL_AWAY_TIME:
    {
        const IPC_SINK_POLL_AWAY_TIME *ipc_prim = (const IPC_SINK_POLL_AWAY_TIME *)prim;
        vm_trap_SinkPollAwayTime
        (
            ipc_prim->sink
        );
    }
        break;
    case IPC_SIGNAL_ID_INQUIRY_SET_PRIORITY:
    {
        const IPC_INQUIRY_SET_PRIORITY *ipc_prim = (const IPC_INQUIRY_SET_PRIORITY *)prim;
        vm_trap_InquirySetPriority
        (
            ipc_prim->priority
        );
    }
        break;
    case IPC_SIGNAL_ID_INQUIRY_GET_PRIORITY:
    {
        vm_trap_InquiryGetPriority
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_GET_BD_ADDRT_FROM_CID:
    {
        const IPC_VM_GET_BD_ADDRT_FROM_CID *ipc_prim = (const IPC_VM_GET_BD_ADDRT_FROM_CID *)prim;
        rsp_prim.ipc_vm_get_bd_addrt_from_cid_rsp.ret = vm_trap_VmGetBdAddrtFromCid
        (
            ipc_prim->cid,
            &rsp_prim.ipc_vm_get_bd_addrt_from_cid_rsp.tpaddr
        );
        ipc_send(IPC_SIGNAL_ID_VM_GET_BD_ADDRT_FROM_CID_RSP,
                 &rsp_prim.ipc_vm_get_bd_addrt_from_cid_rsp,
                 sizeof(rsp_prim.ipc_vm_get_bd_addrt_from_cid_rsp));
    }
        break;
    case IPC_SIGNAL_ID_VM_GET_PUBLIC_ADDRESS:
    {
        const IPC_VM_GET_PUBLIC_ADDRESS *ipc_prim = (const IPC_VM_GET_PUBLIC_ADDRESS *)prim;
        rsp_prim.ipc_vm_get_public_address_rsp.ret = vm_trap_VmGetPublicAddress
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->random_addr, const TP_BD_ADDR_T *)
#else
            ipc_prim->random_addr
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            &rsp_prim.ipc_vm_get_public_address_rsp.public_addr
        );
        ipc_send(IPC_SIGNAL_ID_VM_GET_PUBLIC_ADDRESS_RSP,
                 &rsp_prim.ipc_vm_get_public_address_rsp,
                 sizeof(rsp_prim.ipc_vm_get_public_address_rsp));
    }
        break;
#endif /* TRAPSET_BLUESTACK */


#if TRAPSET_ENERGY
    case IPC_SIGNAL_ID_ENERGY_ESTIMATION_SET_BOUNDS:
    {
        const IPC_ENERGY_ESTIMATION_SET_BOUNDS *ipc_prim = (const IPC_ENERGY_ESTIMATION_SET_BOUNDS *)prim;
        vm_trap_EnergyEstimationSetBounds
        (
            ipc_prim->sco,
            ipc_prim->lower,
            ipc_prim->upper
        );
    }
        break;
    case IPC_SIGNAL_ID_ENERGY_ESTIMATION_OFF:
    {
        const IPC_ENERGY_ESTIMATION_OFF *ipc_prim = (const IPC_ENERGY_ESTIMATION_OFF *)prim;
        vm_trap_EnergyEstimationOff
        (
            ipc_prim->sco
        );
    }
        break;
#endif /* TRAPSET_ENERGY */


#if TRAPSET_USB_HUB
    case IPC_SIGNAL_ID_USB_HUB_ATTACH:
    {
        vm_trap_UsbHubAttach
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_USB_HUB_DETACH:
    {
        rsp_prim.ipc_bool_rsp.ret = vm_trap_UsbHubDetach
        (
        );
        ipc_send(IPC_SIGNAL_ID_USB_HUB_DETACH_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_USB_HUB_CONFIGURE:
    {
        const IPC_USB_HUB_CONFIGURE *ipc_prim = (const IPC_USB_HUB_CONFIGURE *)prim;
        vm_trap_UsbHubConfigure
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->device_params, const usb_device_parameters *)
#else
            ipc_prim->device_params
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            
        );
    }
        break;
#endif /* TRAPSET_USB_HUB */


#if TRAPSET_XIO
    case IPC_SIGNAL_ID_XIO_MEASURE_VOLTAGE:
    {
        const IPC_XIO_MEASURE_VOLTAGE *ipc_prim = (const IPC_XIO_MEASURE_VOLTAGE *)prim;
        rsp_prim.ipc_trap_voltsense_result_rsp.ret = vm_trap_XioMeasureVoltage
        (
            ipc_prim->task,
            ipc_prim->first_xio,
            ipc_prim->second_xio,
            ipc_prim->voltage_gain
        );
        ipc_send(IPC_SIGNAL_ID_XIO_MEASURE_VOLTAGE_RSP,
                 &rsp_prim.ipc_trap_voltsense_result_rsp,
                 sizeof(rsp_prim.ipc_trap_voltsense_result_rsp));
    }
        break;
    case IPC_SIGNAL_ID_DAC_ENABLE:
    {
        const IPC_DAC_ENABLE *ipc_prim = (const IPC_DAC_ENABLE *)prim;
        vm_trap_DacEnable
        (
            ipc_prim->enable
        );
    }
        break;
    case IPC_SIGNAL_ID_DAC_SET_GAIN:
    {
        const IPC_DAC_SET_GAIN *ipc_prim = (const IPC_DAC_SET_GAIN *)prim;
        rsp_prim.ipc_trap_voltsense_result_rsp.ret = vm_trap_DacSetGain
        (
            ipc_prim->gain
        );
        ipc_send(IPC_SIGNAL_ID_DAC_SET_GAIN_RSP,
                 &rsp_prim.ipc_trap_voltsense_result_rsp,
                 sizeof(rsp_prim.ipc_trap_voltsense_result_rsp));
    }
        break;
    case IPC_SIGNAL_ID_DAC_SET_LEVEL:
    {
        const IPC_DAC_SET_LEVEL *ipc_prim = (const IPC_DAC_SET_LEVEL *)prim;
        rsp_prim.ipc_trap_voltsense_result_rsp.ret = vm_trap_DacSetLevel
        (
            ipc_prim->level
        );
        ipc_send(IPC_SIGNAL_ID_DAC_SET_LEVEL_RSP,
                 &rsp_prim.ipc_trap_voltsense_result_rsp,
                 sizeof(rsp_prim.ipc_trap_voltsense_result_rsp));
    }
        break;
#endif /* TRAPSET_XIO */


#if TRAPSET_OTP
    case IPC_SIGNAL_ID_OTP_READ_DATA:
    {
        const IPC_OTP_READ_DATA *ipc_prim = (const IPC_OTP_READ_DATA *)prim;
        vm_trap_OtpReadData
        (
            ipc_prim->read_value,
            ipc_prim->start_word,
            ipc_prim->length_words
        );
    }
        break;
    case IPC_SIGNAL_ID_OTP_WRITE_DATA:
    {
        const IPC_OTP_WRITE_DATA *ipc_prim = (const IPC_OTP_WRITE_DATA *)prim;
        vm_trap_OtpWriteData
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->write_value, const uint16 *)
#else
            ipc_prim->write_value
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->start_word,
            ipc_prim->length_words
        );
    }
        break;
#endif /* TRAPSET_OTP */


#if TRAPSET_HOST
    case IPC_SIGNAL_ID_HOST_SEND_MESSAGE:
    {
        const IPC_HOST_SEND_MESSAGE *ipc_prim = (const IPC_HOST_SEND_MESSAGE *)prim;
        rsp_prim.ipc_uint16_rsp.ret = vm_trap_HostSendMessage
        (
            ipc_prim->msg
        );
        ipc_send(IPC_SIGNAL_ID_HOST_SEND_MESSAGE_RSP,
                 &rsp_prim.ipc_uint16_rsp,
                 sizeof(rsp_prim.ipc_uint16_rsp));
    }
        break;
    case IPC_SIGNAL_ID_MESSAGE_HOST_COMMS_TASK:
    {
        const IPC_MESSAGE_HOST_COMMS_TASK *ipc_prim = (const IPC_MESSAGE_HOST_COMMS_TASK *)prim;
        rsp_prim.ipc_task_rsp.ret = vm_trap_MessageHostCommsTask
        (
            ipc_prim->task
        );
        ipc_send(IPC_SIGNAL_ID_MESSAGE_HOST_COMMS_TASK_RSP,
                 &rsp_prim.ipc_task_rsp,
                 sizeof(rsp_prim.ipc_task_rsp));
    }
        break;
#endif /* TRAPSET_HOST */


#if TRAPSET_OPERATOR
    case IPC_SIGNAL_ID_OPERATOR_CREATE:
    {
        const IPC_OPERATOR_CREATE *ipc_prim = (const IPC_OPERATOR_CREATE *)prim;
        vm_trap_OperatorCreate
        (
            ipc_prim->cap_id,
            ipc_prim->num_keys,
            ipc_prim->info
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_DESTROY_MULTIPLE:
    {
        const IPC_OPERATOR_DESTROY_MULTIPLE *ipc_prim = (const IPC_OPERATOR_DESTROY_MULTIPLE *)prim;
        vm_trap_OperatorDestroyMultiple
        (
            ipc_prim->n_ops,
            ipc_prim->oplist,
            ipc_prim->success_ops
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_START_MULTIPLE:
    {
        const IPC_OPERATOR_START_MULTIPLE *ipc_prim = (const IPC_OPERATOR_START_MULTIPLE *)prim;
        vm_trap_OperatorStartMultiple
        (
            ipc_prim->n_ops,
            ipc_prim->oplist,
            ipc_prim->success_ops
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_STOP_MULTIPLE:
    {
        const IPC_OPERATOR_STOP_MULTIPLE *ipc_prim = (const IPC_OPERATOR_STOP_MULTIPLE *)prim;
        vm_trap_OperatorStopMultiple
        (
            ipc_prim->n_ops,
            ipc_prim->oplist,
            ipc_prim->success_ops
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_RESET_MULTIPLE:
    {
        const IPC_OPERATOR_RESET_MULTIPLE *ipc_prim = (const IPC_OPERATOR_RESET_MULTIPLE *)prim;
        vm_trap_OperatorResetMultiple
        (
            ipc_prim->n_ops,
            ipc_prim->oplist,
            ipc_prim->success_ops
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_MESSAGE:
    {
        const IPC_OPERATOR_MESSAGE *ipc_prim = (const IPC_OPERATOR_MESSAGE *)prim;
        vm_trap_OperatorMessage
        (
            ipc_prim->opid,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->send_msg, const uint16 *)
#else
            ipc_prim->send_msg
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->send_len_words,
            ipc_prim->recv_len_words
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_BUNDLE_LOAD:
    {
        const IPC_OPERATOR_BUNDLE_LOAD *ipc_prim = (const IPC_OPERATOR_BUNDLE_LOAD *)prim;
        vm_trap_OperatorBundleLoad
        (
            ipc_prim->index,
            ipc_prim->processor
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_BUNDLE_UNLOAD:
    {
        const IPC_OPERATOR_BUNDLE_UNLOAD *ipc_prim = (const IPC_OPERATOR_BUNDLE_UNLOAD *)prim;
        vm_trap_OperatorBundleUnload
        (
            ipc_prim->bundle
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_CONFIGURATION_SET:
    {
        const IPC_OPERATOR_FRAMEWORK_CONFIGURATION_SET *ipc_prim = (const IPC_OPERATOR_FRAMEWORK_CONFIGURATION_SET *)prim;
        vm_trap_OperatorFrameworkConfigurationSet
        (
            ipc_prim->key,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->send_msg, const uint16 *)
#else
            ipc_prim->send_msg
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->send_len_words
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_CONFIGURATION_GET:
    {
        const IPC_OPERATOR_FRAMEWORK_CONFIGURATION_GET *ipc_prim = (const IPC_OPERATOR_FRAMEWORK_CONFIGURATION_GET *)prim;
        vm_trap_OperatorFrameworkConfigurationGet
        (
            ipc_prim->key,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->send_msg, const uint16 *)
#else
            ipc_prim->send_msg
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->send_len_words,
            ipc_prim->recv_len_words
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_ENABLE:
    {
        const IPC_OPERATOR_FRAMEWORK_ENABLE *ipc_prim = (const IPC_OPERATOR_FRAMEWORK_ENABLE *)prim;
        vm_trap_OperatorFrameworkEnable
        (
            ipc_prim->state
        );
    }
        break;
#endif /* TRAPSET_OPERATOR */


#if TRAPSET_AUDIO_PWM
    case IPC_SIGNAL_ID_AUDIO_PWM_POWER_ENABLE:
    {
        const IPC_AUDIO_PWM_POWER_ENABLE *ipc_prim = (const IPC_AUDIO_PWM_POWER_ENABLE *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_AudioPwmPowerEnable
        (
            ipc_prim->enable
        );
        ipc_send(IPC_SIGNAL_ID_AUDIO_PWM_POWER_ENABLE_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_AUDIO_PWM_MUTE:
    {
        const IPC_AUDIO_PWM_MUTE *ipc_prim = (const IPC_AUDIO_PWM_MUTE *)prim;
        vm_trap_AudioPwmMute
        (
            ipc_prim->enable
        );
    }
        break;
#endif /* TRAPSET_AUDIO_PWM */


#if TRAPSET_AUDIO
    case IPC_SIGNAL_ID_STREAM_RINGTONE_SOURCE:
    {
        const IPC_STREAM_RINGTONE_SOURCE *ipc_prim = (const IPC_STREAM_RINGTONE_SOURCE *)prim;
        rsp_prim.ipc_source_rsp.ret = vm_trap_StreamRingtoneSource
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->ringtone, const ringtone_note*)
#else
            ipc_prim->ringtone
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            
        );
        ipc_send(IPC_SIGNAL_ID_STREAM_RINGTONE_SOURCE_RSP,
                 &rsp_prim.ipc_source_rsp,
                 sizeof(rsp_prim.ipc_source_rsp));
    }
        break;
    case IPC_SIGNAL_ID_STREAM_AUDIO_SOURCE:
    {
        const IPC_STREAM_AUDIO_SOURCE *ipc_prim = (const IPC_STREAM_AUDIO_SOURCE *)prim;
        vm_trap_StreamAudioSource
        (
            ipc_prim->hardware,
            ipc_prim->instance,
            ipc_prim->channel
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_AUDIO_SINK:
    {
        const IPC_STREAM_AUDIO_SINK *ipc_prim = (const IPC_STREAM_AUDIO_SINK *)prim;
        vm_trap_StreamAudioSink
        (
            ipc_prim->hardware,
            ipc_prim->instance,
            ipc_prim->channel
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_SCO_SINK:
    {
        const IPC_STREAM_SCO_SINK *ipc_prim = (const IPC_STREAM_SCO_SINK *)prim;
        vm_trap_StreamScoSink
        (
            ipc_prim->handle
        );
    }
        break;
    case IPC_SIGNAL_ID_STREAM_SCO_SOURCE:
    {
        const IPC_STREAM_SCO_SOURCE *ipc_prim = (const IPC_STREAM_SCO_SOURCE *)prim;
        vm_trap_StreamScoSource
        (
            ipc_prim->handle
        );
    }
        break;
    case IPC_SIGNAL_ID_SOURCE_GET_SCO_HANDLE:
    {
        const IPC_SOURCE_GET_SCO_HANDLE *ipc_prim = (const IPC_SOURCE_GET_SCO_HANDLE *)prim;
        rsp_prim.ipc_uint16_rsp.ret = vm_trap_SourceGetScoHandle
        (
            ipc_prim->source
        );
        ipc_send(IPC_SIGNAL_ID_SOURCE_GET_SCO_HANDLE_RSP,
                 &rsp_prim.ipc_uint16_rsp,
                 sizeof(rsp_prim.ipc_uint16_rsp));
    }
        break;
    case IPC_SIGNAL_ID_SINK_GET_SCO_HANDLE:
    {
        const IPC_SINK_GET_SCO_HANDLE *ipc_prim = (const IPC_SINK_GET_SCO_HANDLE *)prim;
        rsp_prim.ipc_uint16_rsp.ret = vm_trap_SinkGetScoHandle
        (
            ipc_prim->sink
        );
        ipc_send(IPC_SIGNAL_ID_SINK_GET_SCO_HANDLE_RSP,
                 &rsp_prim.ipc_uint16_rsp,
                 sizeof(rsp_prim.ipc_uint16_rsp));
    }
        break;
#endif /* TRAPSET_AUDIO */


#if TRAPSET_WAKE_ON_AUDIO
    case IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_TRIGGER_NOTIFICATION_START:
    {
        const IPC_OPERATOR_FRAMEWORK_TRIGGER_NOTIFICATION_START *ipc_prim = (const IPC_OPERATOR_FRAMEWORK_TRIGGER_NOTIFICATION_START *)prim;
        vm_trap_OperatorFrameworkTriggerNotificationStart
        (
            ipc_prim->type,
            ipc_prim->opid
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_TRIGGER_NOTIFICATION_STOP:
    {
        vm_trap_OperatorFrameworkTriggerNotificationStop
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_DATA_LOAD:
    {
        const IPC_OPERATOR_DATA_LOAD *ipc_prim = (const IPC_OPERATOR_DATA_LOAD *)prim;
        vm_trap_OperatorDataLoad
        (
            ipc_prim->index,
            ipc_prim->type,
            ipc_prim->auto_remove
        );
    }
        break;
    case IPC_SIGNAL_ID_OPERATOR_DATA_UNLOAD:
    {
        const IPC_OPERATOR_DATA_UNLOAD *ipc_prim = (const IPC_OPERATOR_DATA_UNLOAD *)prim;
        vm_trap_OperatorDataUnload
        (
            ipc_prim->file_id
        );
    }
        break;
    case IPC_SIGNAL_ID_AUDIO_DSP_CLOCK_CONFIGURE:
    {
        const IPC_AUDIO_DSP_CLOCK_CONFIGURE *ipc_prim = (const IPC_AUDIO_DSP_CLOCK_CONFIGURE *)prim;
        vm_trap_AudioDspClockConfigure
        (
            ipc_prim->clock_config
        );
    }
        break;
    case IPC_SIGNAL_ID_AUDIO_DSP_GET_CLOCK:
    {
        vm_trap_AudioDspGetClock
        (
        );
    }
        break;
    case IPC_SIGNAL_ID_AUDIO_POWER_SAVE_MODE_SET:
    {
        const IPC_AUDIO_POWER_SAVE_MODE_SET *ipc_prim = (const IPC_AUDIO_POWER_SAVE_MODE_SET *)prim;
        vm_trap_AudioPowerSaveModeSet
        (
            ipc_prim->mode
        );
    }
        break;
    case IPC_SIGNAL_ID_AUDIO_POWER_SAVE_MODE_GET:
    {
        vm_trap_AudioPowerSaveModeGet
        (
        );
    }
        break;
#endif /* TRAPSET_WAKE_ON_AUDIO */


#if TRAPSET_PROFILE
    case IPC_SIGNAL_ID_VM_REQUEST_RUN_TIME_PROFILE:
    {
        const IPC_VM_REQUEST_RUN_TIME_PROFILE *ipc_prim = (const IPC_VM_REQUEST_RUN_TIME_PROFILE *)prim;
        vm_trap_VmRequestRunTimeProfile
        (
            ipc_prim->profile
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_GET_RUN_TIME_PROFILE:
    {
        vm_trap_VmGetRunTimeProfile
        (
        );
    }
        break;
#endif /* TRAPSET_PROFILE */


#if TRAPSET_IIR16BIT
    case IPC_SIGNAL_ID_CODEC_SET_IIR_FILTER16_BIT:
    {
        const IPC_CODEC_SET_IIR_FILTER16_BIT *ipc_prim = (const IPC_CODEC_SET_IIR_FILTER16_BIT *)prim;
        vm_trap_CodecSetIirFilter16Bit
        (
            ipc_prim->channel_mask,
            ipc_prim->enable,
            ipc_prim->iir_coefficients
        );
    }
        break;
#endif /* TRAPSET_IIR16BIT */


#if TRAPSET_BITSERIAL
    case IPC_SIGNAL_ID_BITSERIAL_OPEN:
    {
        const IPC_BITSERIAL_OPEN *ipc_prim = (const IPC_BITSERIAL_OPEN *)prim;
        vm_trap_BitserialOpen
        (
            ipc_prim->block_index,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->config, const bitserial_config *)
#else
            ipc_prim->config
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            
        );
    }
        break;
    case IPC_SIGNAL_ID_BITSERIAL_CLOSE:
    {
        const IPC_BITSERIAL_CLOSE *ipc_prim = (const IPC_BITSERIAL_CLOSE *)prim;
        vm_trap_BitserialClose
        (
            ipc_prim->handle
        );
    }
        break;
    case IPC_SIGNAL_ID_BITSERIAL_TRANSFER:
    {
        const IPC_BITSERIAL_TRANSFER *ipc_prim = (const IPC_BITSERIAL_TRANSFER *)prim;
        vm_trap_BitserialTransfer
        (
            ipc_prim->handle,
            ipc_prim->transfer_handle_ptr,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->tx_data, const uint8 *)
#else
            ipc_prim->tx_data
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->tx_size,
            ipc_prim->rx_data,
            ipc_prim->rx_size
        );
    }
        break;
    case IPC_SIGNAL_ID_BITSERIAL_WRITE:
    {
        const IPC_BITSERIAL_WRITE *ipc_prim = (const IPC_BITSERIAL_WRITE *)prim;
        vm_trap_BitserialWrite
        (
            ipc_prim->handle,
            ipc_prim->transfer_handle_ptr,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->data, const uint8 *)
#else
            ipc_prim->data
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->size,
            ipc_prim->flags
        );
    }
        break;
    case IPC_SIGNAL_ID_BITSERIAL_READ:
    {
        const IPC_BITSERIAL_READ *ipc_prim = (const IPC_BITSERIAL_READ *)prim;
        vm_trap_BitserialRead
        (
            ipc_prim->handle,
            ipc_prim->transfer_handle_ptr,
            ipc_prim->data,
            ipc_prim->size,
            ipc_prim->flags
        );
    }
        break;
#endif /* TRAPSET_BITSERIAL */


#if TRAPSET_CRYPTO
    case IPC_SIGNAL_ID_CRYPTO_AES128_CTR:
    {
        const IPC_CRYPTO_AES128_CTR *ipc_prim = (const IPC_CRYPTO_AES128_CTR *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_CryptoAes128Ctr
        (
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->key, const uint8 *)
#else
            ipc_prim->key
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->nonce, const uint8 *)
#else
            ipc_prim->nonce
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->flags,
            ipc_prim->counter,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->source_data, const uint8 *)
#else
            ipc_prim->source_data
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->source_data_len_bytes,
            ipc_prim->dest_data,
            ipc_prim->dest_data_len_bytes
        );
        ipc_send(IPC_SIGNAL_ID_CRYPTO_AES128_CTR_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
    case IPC_SIGNAL_ID_CRYPTO_AES128_CBC:
    {
        const IPC_CRYPTO_AES128_CBC *ipc_prim = (const IPC_CRYPTO_AES128_CBC *)prim;
        rsp_prim.ipc_bool_rsp.ret = vm_trap_CryptoAes128Cbc
        (
            ipc_prim->encrypt,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->key, const uint8 *)
#else
            ipc_prim->key
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->nonce,
            ipc_prim->flags,
#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036
            MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->source_data, const uint8 *)
#else
            ipc_prim->source_data
#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */
            ,
            ipc_prim->source_data_len_bytes,
            ipc_prim->dest_data,
            ipc_prim->dest_data_len_bytes
        );
        ipc_send(IPC_SIGNAL_ID_CRYPTO_AES128_CBC_RSP,
                 &rsp_prim.ipc_bool_rsp,
                 sizeof(rsp_prim.ipc_bool_rsp));
    }
        break;
#endif /* TRAPSET_CRYPTO */


#if TRAPSET_CHARGERMESSAGE
    case IPC_SIGNAL_ID_CHARGER_DEBOUNCE:
    {
        const IPC_CHARGER_DEBOUNCE *ipc_prim = (const IPC_CHARGER_DEBOUNCE *)prim;
        rsp_prim.ipc_charger_events_rsp.ret = vm_trap_ChargerDebounce
        (
            ipc_prim->events_to_enable,
            ipc_prim->count,
            ipc_prim->period
        );
        ipc_send(IPC_SIGNAL_ID_CHARGER_DEBOUNCE_RSP,
                 &rsp_prim.ipc_charger_events_rsp,
                 sizeof(rsp_prim.ipc_charger_events_rsp));
    }
        break;
#endif /* TRAPSET_CHARGERMESSAGE */


#if TRAPSET_PSU
    case IPC_SIGNAL_ID_PSU_CONFIGURE:
    {
        const IPC_PSU_CONFIGURE *ipc_prim = (const IPC_PSU_CONFIGURE *)prim;
        vm_trap_PsuConfigure
        (
            ipc_prim->psu,
            ipc_prim->key,
            ipc_prim->value
        );
    }
        break;
    case IPC_SIGNAL_ID_VM_GET_POWER_SOURCE:
    {
        vm_trap_VmGetPowerSource
        (
        );
    }
        break;
#endif /* TRAPSET_PSU */


