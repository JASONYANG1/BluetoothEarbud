/* Copyright (c) 2016 Qualcomm Technologies International, Ltd. */
/*   Part of 6.2 */
/**
 * \file
 *
 * Main header for the \c ccp module.
 */

#ifndef CCP_H
#define CCP_H

#include "hydra/hydra_types.h"
#include "hydra/hydra_macros.h"

#include "gen/xap/system_prim.h"
#include "gen/xap/ccp_prim.h"

#ifndef COAL_TEST_BUILD
/*
 * Coal test build doesn't do the autogeneration and doesn't use the
 * results.
 */
#include "ccp/gen/ccp_funcs.h"
#endif /* COAL_TEST_BUILD */

#include "gen/xap/isp_prim.h"

/**
 * Minimum length of CCP signal.
 */
#define CCP_SIGNAL_MIN_WORD_SIZE        CCP_HEADER_WORD_SIZE

/**
 * Maximum length of CCP signal.
 */
#define CCP_SIGNAL_MAX_WORD_SIZE        64

/**
 * Retrieve the CCP signal ID from a \c uint16 \c pdu[].
 */
#define CCP_SIGNAL_ID_GET(pdu) \
    (CCP_SIGNAL_ID)((pdu)[CCP_HEADER_SIGNAL_ID_WORD_OFFSET])
/**
 * Set the CCP signal ID in a \c uint16 \c pdu[].
 */
#define CCP_SIGNAL_ID_SET(pdu, id) \
    ((pdu)[CCP_HEADER_SIGNAL_ID_WORD_OFFSET] = (id))

/**
 * Test if a CCP PDU contains a deep sleep wake signal.
 * Only the first word of the PDU is examined.
 */
#define CCP_SIGNAL_IS_DEEP_SLEEP_WAKE(pdu)                              \
    (CCP_SIGNAL_ID_GET(payload) == CCP_SIGNAL_ID_DEEP_SLEEP_WAKE_REQ || \
     CCP_SIGNAL_ID_GET(payload) == CCP_SIGNAL_ID_DEEP_SLEEP_WAKE_PIO_REQ)

#ifdef DESKTOP_TEST_BUILD

#include "submsg/submsg.h"

/**
 * For unit test builds we use the COAL submsg implementation directly.
 */
#define CCP_SEND(pdu,len,dest)         \
    submsg_isp_data_req(pdu, len, dest, ISP_PORT_MAPPING_ENUM_CCP)

#else /* not DESKTOP_TEST_BUILD */
#ifdef SUBSYSTEM_CURATOR
/*
 * Route of return messages
 */
#include "ccp_router/ccp_router.h"

/**
 * On curator we need to send through the ccp_router so that messages
 * can go to the host or a sub-system.
 */
#define CCP_SEND(pdu,len,dest)          ccp_router_send(pdu, len, dest)

#else

#include "isp_router/isp_router.h"

/** On other sub-systems, CCP messages always go via the curator */
#define CCP_SEND(pdu,len,dest)          \
    isp_router_send(pdu, len, dest, ISP_PORT_MAPPING_ENUM_CCP)

#endif /* SUBSYSTEM_CURATOR */
#endif /* DESKTOP_TEST_BUILD */

/**
 * Allocate (using \c pmalloc()) space for a PDU with variable-length data.
 * Copy in the data; handles the case of no data.
 *
 * Occurrences of this function should gradually be replaced by use
 * of PDUs from static allocation sized to fit the longest possible PDU.
 *
 * Because this uses \c pmalloc(), it panics on failure.
 *
 * As the intention is to replace this interface on the Curator, and on
 * other subsystems failure to send a command message is assumed to be a
 * fatal error, there is no non-panicky version.
 *
 * \param pdu will be set to the allocated PDU array.
 * \param pdu_len will be set to the full length of the PDU in uint16's.
 * \param data is a pointer to the data to be added; may be NULL if
 *        \c data_len is zero.
 * \param data_len is the length in uint16's of \c data.
 * \param offset is the offset of the data into the PDU, typically one
 *        of the autogenerated \c CCP_OFFSET_\e SIGNAME\c _\e ARGNAME
 *        macros.
 */
extern void ccp_allocate_variable_pdu(
    uint16 **pdu, uint16 *pdu_len,
    const uint16 *data, uint16 data_len,
    uint16 offset);

/**
 * Value of a patch level indicating this isn't patched.
 *
 * This is too large to fit in an enum, so is defined here
 * rather than in the XML.
 */
#define CCP_PATCH_LEVEL_NOT_YET_PATCHED (0xFFFFFFFFUL)

#endif /* CCP_H */
