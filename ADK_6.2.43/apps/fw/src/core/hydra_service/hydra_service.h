/* Copyright (c) 2016 Qualcomm Technologies International, Ltd. */
/*   Part of 6.2 */

#ifndef HYDRA_SERVICE_H
#define HYDRA_SERVICE_H

/*
 * Location of autogenerated CCP definitions.
 */
#include "gen/xap/ccp_prim.h"


/** Extract the provider field from \c SERVICE_RECORD_HEADER pointer */
#define SERVICE_RECORD_PROVIDER_GET(hdr)                \
    CCP_SERVICE_RECORD_HEADER_PROVIDER_GET(hdr)
/** Extract the ID field from \c SERVICE_RECORD_HEADER pointer */
#define SERVICE_RECORD_ID_GET(hdr)                                      \
    ((CCP_SERVICE_ID)                                                   \
     ((CCP_SERVICE_RECORD_HEADER_SERVICE_INDEX_GET(hdr) |               \
       (CCP_SERVICE_RECORD_HEADER_SERVICE_CLASS_GET(hdr) << 5))))
/** Extract the INDEX field from \c SERVICE_RECORD_HEADER pointer */
#define SERVICE_RECORD_INDEX_GET(hdr)           \
    CCP_SERVICE_RECORD_HEADER_SERVICE_INDEX_GET(hdr)
/**
 * Extract the CLASS field from \c SERVICE_RECORD_HEADER pointer.
 * Caveat: in the original version of this file the class was
 * a value directly "or"ed with the index to create the ID, i.e.
 * a 5-bit number shifted 5 bits left.  Now it's the base value,
 * unshifted.
 */
#define SERVICE_RECORD_CLASS_GET(hdr)           \
    CCP_SERVICE_RECORD_HEADER_SERVICE_CLASS_GET(hdr)
/** Extract the extended field from \c SERVICE_RECORD_HEADER pointer */
#define SERVICE_RECORD_EXTENDED_GET(hdr)                \
    CCP_SERVICE_RECORD_HEADER_EXTENDED_GET(hdr)

/** Extract the version field from \c SERVICE_RECORD_HEADER pointer */
#define SERVICE_RECORD_VERSION_GET(hdr)                \
    CCP_SERVICE_RECORD_HEADER_SERVICE_VERSION_GET(hdr)
/** Extract the host field from \c SERVICE_RECORD_HEADER pointer */
#define SERVICE_RECORD_HOST_GET(hdr)                \
    CCP_SERVICE_RECORD_HEADER_HOST_FLAG_GET(hdr)
/** Extract the mult field from \c SERVICE_RECORD_HEADER pointer */
#define SERVICE_RECORD_MULT_GET(hdr)                \
    CCP_SERVICE_RECORD_HEADER_MULTIPLICITY_GET(hdr)

/**
 * Service ID is ((service_class << 5) | service_index). See SERVICE_ID_CREATE.
 * This macro extracts the service index.
 */
#define SERVICE_INDEX_FROM_ID(id)   ((id) & 0x1f)

/**
 * Service ID is ((service_class << 5) | service_index). See SERVICE_ID_CREATE.
 * This macro extracts the service class.
 */
#define SERVICE_CLASS_FROM_ID(id)   (((id)>>5) & 0x1f)

/**
 * Shortened version of the auto-generated header for creating a
 * service record.
 */
/*lint -emacro (572, SERVICE_RECORD_CREATE)*/
#define SERVICE_RECORD_CREATE(provider, service_id,  \
                              version, host_flag, multiplicity) \
    CCP_SERVICE_RECORD_HEADER_CREATE( \
        provider, \
        SERVICE_INDEX_FROM_ID(service_id), SERVICE_CLASS_FROM_ID(service_id), \
        0U, version, host_flag, multiplicity, 0U, 0U)

/**
 * Shortened version of the auto-generated header for creating a
 * service record for an "Isolated Service". This is a service
 * that does not have direct interfaces between the provider and
 * consumer. All communications flow via the curator using the
 * Auxiliary Command Channel.
 */
/*lint -emacro (572, SERVICE_RECORD_CREATE_ISOLATED_SERVICE)*/
#define SERVICE_RECORD_CREATE_ISOLATED_SERVICE(provider, service_id,    \
                                      version, host_flag, multiplicity) \
    CCP_SERVICE_RECORD_HEADER_CREATE( \
        provider, \
        SERVICE_INDEX_FROM_ID(service_id), SERVICE_CLASS_FROM_ID(service_id), \
        0U, version, host_flag, multiplicity, 1U, 0U)

/**
 * Copy a service record header.
 *
 * Works whatever the representation of \c dst or \c src, e.g. may
 * be \c uint16 arrays.
 */
#define SERVICE_RECORD_HEADER_COPY(dst, src)    \
    memcpy(dst, src, CCP_SERVICE_RECORD_HEADER_WORD_SIZE * sizeof(uint16))

/**
 * Clear (zero) a service record header.
 */
#define SERVICE_RECORD_HEADER_CLEAR(hdr)                \
    memset(hdr, 0U, CCP_SERVICE_RECORD_HEADER_WORD_SIZE * sizeof(uint16))

/**
 * Set the fields of a service record header incorporating all fields
 * needed in an advertisement, for dynamic usage.
 *
 * \c hdr is a pointer to the service record header.
 * \c provider, \c id, \c version, \c host, \c mult are service
 * record header fields.
 */
#define SERVICE_RECORD_SET_ADVERT(                                      \
    hdr, provider, id, version, host, mult)                             \
    CCP_SERVICE_RECORD_HEADER_PACK(                                     \
    hdr, provider, SERVICE_INDEX_FROM_ID(id), SERVICE_CLASS_FROM_ID(id),\
    0, version, host, mult, 0, 0)

/**
 * Set the fields a service record header incorporating fields needed for
 * looking up a service, either in a query or (without wildcards)
 * for starting the service.
 */
#define SERVICE_RECORD_SET_LOOKUP(hdr, provider, id, version)           \
    CCP_SERVICE_RECORD_HEADER_PACK(                                     \
    hdr, provider, SERVICE_INDEX_FROM_ID(id), SERVICE_CLASS_FROM_ID(id),\
    0, version, 0, 0, 0, 0)

/*@}*/


/**
 * \name Definitions for service types.
 */
/*@{*/

/**
 * Create a full service ID from a class and an index.
 *
 * Note that \c CCP_SERVICE_CLASS is zero-based, no longer shifted to
 * place, e.g the old \c SERVICE_CLASS_ANY was (31 << 5), the new \c
 * CCP_SERVICE_CLASS_ANY is 31.  Hence this macro should be used
 * to combine classes and indexes.
 */
#define SERVICE_ID_CREATE(cl, ind) \
    ((CCP_SERVICE_ID)(((cl) << 5) | (ind)))

/**
 * Version of the above used internally in this file.
 * We can't cast to the type we're constructing.
 */
#define SERVICE_ID_X(cl, ind)                   \
    (((cl) << 5) | (ind))

/**
 * Service ID.
 * The full identifier for a service, including a class and an index.
 *
 * New classes and indexes should not be added here but in
 * //depot/hydra/main/common/interface/ccp.xml
 *
 * The classes and indexes are defined in the XML, so all that remains
 * here is to combine them.
 */
typedef enum CCP_SERVICE_ID
{
    /**
     * Define MISC services
     */
#define SERVICE_ID_MISC_CREATE(name) \
    SERVICE_ID_X(CCP_SERVICE_CLASS_MISC, CCP_SERVICE_CLASS_MISC_INDEX_ ## name)
    /** Standby service */
    CCP_SERVICE_ID_STANDBY = SERVICE_ID_MISC_CREATE(STANDBY),
    /** Licence Manager service */
    CCP_SERVICE_ID_MISC_LICENCE_MANAGER = SERVICE_ID_MISC_CREATE(MISC_LICENCE_MANAGER),
    /** Service test service */
    CCP_SERVICE_ID_SERVICE_TEST = SERVICE_ID_MISC_CREATE(SERVICE_TEST),

#ifdef DESKTOP_TEST_BUILD
    /** Additional test version of BT coex service.  Not used in real code. */
    CCP_SERVICE_ID_TEST_BT_COEX = SERVICE_ID_X(CCP_SERVICE_CLASS_MISC, 28),
    /** Additional test version of WLAN coex service.  Not used in real code. */
    CCP_SERVICE_ID_TEST_WLAN_COEX = SERVICE_ID_X(CCP_SERVICE_CLASS_MISC, 29),
#endif

    /**
     * Define BLUETOOTH services
     */
#define SERVICE_ID_BLUETOOTH_CREATE(name) \
    SERVICE_ID_X(CCP_SERVICE_CLASS_BLUETOOTH, \
                 CCP_SERVICE_CLASS_BLUETOOTH_INDEX_ ## name)
    /** Bluetooth HCI service. */
    CCP_SERVICE_ID_BLUETOOTH_HCI = SERVICE_ID_BLUETOOTH_CREATE(BLUETOOTH_HCI),
    /** Bluetooth coexistence service. */
    CCP_SERVICE_ID_BLUETOOTH_COEXISTENCE =
    SERVICE_ID_BLUETOOTH_CREATE(BLUETOOTH_COEXISTENCE),
    /** Bluetooth test service. */
    CCP_SERVICE_ID_BLUETOOTH_TEST = SERVICE_ID_BLUETOOTH_CREATE(BLUETOOTH_TEST),
    /** Bluetooth to-air shunt service */
    CCP_SERVICE_ID_BLUETOOTH_TO_AIR_SHUNT =
    SERVICE_ID_BLUETOOTH_CREATE(BLUETOOTH_TO_AIR_SHUNT),
    /** Bluetooth from-air shunt service */
    CCP_SERVICE_ID_BLUETOOTH_FROM_AIR_SHUNT =
    SERVICE_ID_BLUETOOTH_CREATE(BLUETOOTH_FROM_AIR_SHUNT),
    /** Bluestack upper layers service */
    CCP_SERVICE_ID_BLUETOOTH_FULL_STACK =
            SERVICE_ID_BLUETOOTH_CREATE(BLUETOOTH_FULL_STACK),
    /** Bluetooth information service */
    CCP_SERVICE_ID_BLUETOOTH_INFORMATION =
            SERVICE_ID_BLUETOOTH_CREATE(BLUETOOTH_INFORMATION),
    /** CSB Service */
    CCP_SERVICE_ID_BLUETOOTH_CSB =
            SERVICE_ID_BLUETOOTH_CREATE(BLUETOOTH_CSB),
    /** Bluetooth wake-on service */
    CCP_SERVICE_ID_BLUETOOTH_WAKE_ON =
            SERVICE_ID_BLUETOOTH_CREATE(BLUETOOTH_WAKE_ON),

    /**
     * Define WLAN services
     */
#define SERVICE_ID_WLAN_CREATE(name) \
    SERVICE_ID_X(CCP_SERVICE_CLASS_WLAN, \
                 CCP_SERVICE_CLASS_WLAN_INDEX_ ## name)
    /** Wireless LAN with UniFi HIP interface to host. */
    CCP_SERVICE_ID_WLAN_HIP = SERVICE_ID_WLAN_CREATE(WLAN_HIP),
    /** Wireless LAN test service. */
    CCP_SERVICE_ID_WLAN_TEST = SERVICE_ID_WLAN_CREATE(WLAN_TEST),
    /** Wireless LAN coexistence service. */
    CCP_SERVICE_ID_WLAN_COEXISTENCE =
    SERVICE_ID_WLAN_CREATE(WLAN_COEXISTENCE),

    /**
     * Define GNSS services
     */
#define SERVICE_ID_GNSS_CREATE(name) \
    SERVICE_ID_X(CCP_SERVICE_CLASS_GNSS, \
                 CCP_SERVICE_CLASS_GNSS_INDEX_ ## name)
    /** GNSS with MEIF interface. */
    CCP_SERVICE_ID_GNSS_MEIF = SERVICE_ID_GNSS_CREATE(GNSS_MEIF),

    /**
     * Define NFC services
     */
#define SERVICE_ID_NFC_CREATE(name) \
    SERVICE_ID_X(CCP_SERVICE_CLASS_NFC, \
                 CCP_SERVICE_CLASS_NFC_INDEX_ ## name)
    /** NFC service with standard host interface */
    CCP_SERVICE_ID_NFC_NCI = SERVICE_ID_NFC_CREATE(NFC_NCI),

    /**
     * Define AUDIO services
     */
#define SERVICE_ID_AUDIO_CREATE(name) \
    SERVICE_ID_X(CCP_SERVICE_CLASS_AUDIO, \
                 CCP_SERVICE_CLASS_AUDIO_INDEX_ ## name)
    /** Audio ACCMD Service. */
    CCP_SERVICE_ID_AUDIO_ACCMD_OVER_ISP =
    SERVICE_ID_AUDIO_CREATE(AUDIO_ACCMD_OVER_ISP),
    /** Audio SCO Processing service. */
    CCP_SERVICE_ID_AUDIO_SCO_PROCESSING =
    SERVICE_ID_AUDIO_CREATE(AUDIO_SCO_PROCESSING),
    /** Audio Sink Service */
    CCP_SERVICE_ID_AUDIO_SINK =
    SERVICE_ID_AUDIO_CREATE(AUDIO_SINK),
    /** Audio Source Service */
    CCP_SERVICE_ID_AUDIO_SOURCE =
    SERVICE_ID_AUDIO_CREATE(AUDIO_SOURCE),
    /** Audio wake-on-voice service */
    CCP_SERVICE_ID_AUDIO_WAKE_ON_VOICE =
    SERVICE_ID_AUDIO_CREATE(AUDIO_WAKE_ON_VOICE),

    /** Wildcard, match any service */
    CCP_SERVICE_ID_ANY =
    SERVICE_ID_X(CCP_SERVICE_CLASS_ANY, CCP_SERVICE_INDEX_ANY)
} CCP_SERVICE_ID;

#undef SERVICE_ID_X
/*@}*/


/**
 * \name Information elements (IEs)
 *
 * IEs are treated as arrays, consequently all addressing of elements of
 * IEs is done by offsets into arrays.  The offsets defined here are
 * where the IE header word (the only standard part) is at offset 0.
 * This is consistently adhered to: for example, the macros for
 * extracting parameter IE flags take a pointer to the start of the IE.
 */
/*@{*/

/**
 * Types of service record IEs.
 *
 * For service-specific types, the first and last entry in the range are
 * defined (not this is the actual last entry, not one beyond it).
 */
typedef enum SERVICE_IE
{
    /** MMU parameter IE */
    SERVICE_IE_PM_MMU = 0,
    /** Message parameter IE */
    SERVICE_IE_PM_MESSAGE = 1,
    /** First service-specific parameter IE */
    SERVICE_IE_PM_SERVICE_SPECIFIC_FIRST = 32,
    /** Last service-specific parameter IE */
    SERVICE_IE_PM_SERVICE_SPECIFIC_LAST = 63,
    /** Autostart IE */
    SERVICE_IE_AUTOSTART = 64,
    /** Auxiliary command channel IE */
    SERVICE_IE_AUX_CMD_CHANNEL = 65,
    /** Autostart Triggered IE */
    SERVICE_IE_AUTOSTART_TRIGGERED = 66,
    /** Have dependency IE */
    SERVICE_IE_HAVE_DEPENDENCY = 67,
    /** First option IE */
    SERVICE_IE_OPTION_FIRST = 128,
    /** Interface version option IE */
    SERVICE_IE_OPTION_INTERFACE_VERSION = 128,
    /** Host transport option IE */
    SERVICE_IE_OPTION_HOST_TRANSPORT = 129,
    /** Kick parameter IE */
    SERVICE_IE_OPTION_KICK_PARAMS = 130,
    /** First service-specific option IE */
    SERVICE_IE_OPTION_SERVICE_SPECIFIC_FIRST = 192,
    /** Last service-specific option IE */
    SERVICE_IE_OPTION_SERVICE_SPECIFIC_LAST = 255
} SERVICE_IE;

/**
 * Offset to the IE header.
 * This is a bit trivial since it effectively defines what
 * the offset means.
 */
#define SERVICE_IE_HEADER_OFFSET        (0U)
/**
 * Length of IE header in words.
 */
#define SERVICE_IE_HEADER_WORDS         (1U)

/**
 * Mask to get IE length from header.
 * The length is the number of octets (not words) following
 * the word containing the length and IE type.
 */
#define SERVICE_IE_HEADER_LENGTH_MASK   (0x00ffU)
/** Shift to get IE length from header */
#define SERVICE_IE_HEADER_LENGTH_SHIFT  (0U)

/** Mask to get IE type from header */
#define SERVICE_IE_HEADER_TYPE_MASK   (0xff00U)
/** Shift to get IE type from header */
#define SERVICE_IE_HEADER_TYPE_SHIFT  (8U)

/** Extract a generic field of an IE header given an array pointing to it */
#define SERVICE_IE_HEADER_FIELD_GET(field, ie)                 \
    (((ie)[0] & SERVICE_IE_HEADER_ ## field ## _MASK) >>       \
     SERVICE_IE_HEADER_ ## field ## _SHIFT)

/** Extract the length of an IE given an array pointing to it */
#define SERVICE_IE_HEADER_LENGTH_GET(ie)                \
    SERVICE_IE_HEADER_FIELD_GET(LENGTH, ie)

/**
 * Extract the length of an IE, converting to total words in the IE.
 * Halve to get the payload length in words, and add the header word.
 */
#define SERVICE_IE_HEADER_ARRAY_LENGTH_GET(ie)  \
    (SERVICE_IE_HEADER_LENGTH_GET(ie)/2U + 1U)

/**
 * Convert the array length of an IE to the length in the header.
 */
#define SERVICE_IE_ARRAY_LENGTH_TO_HEADER_LENGTH(al)   \
    (2U*(al-1U))

/** Extract the type of an IE given an array pointing to it */
#define SERVICE_IE_HEADER_TYPE_GET(ie)                \
    SERVICE_IE_HEADER_FIELD_GET(TYPE, ie)

/** Set an IE header word */
#define SERVICE_IE_HEADER_SET(words, length, tp)            \
    ((words)[SERVICE_IE_HEADER_OFFSET] = (uint16)(          \
     ((length) << SERVICE_IE_HEADER_LENGTH_SHIFT) |         \
     ((uint16)(tp) << SERVICE_IE_HEADER_TYPE_SHIFT)))
/**
 * Create an IE header word.
 * This is suitable for use in compile-time definitions.
 */
#define SERVICE_IE_HEADER_CREATE(length, tp)            \
    (((length) << SERVICE_IE_HEADER_LENGTH_SHIFT) |     \
     ((tp) << SERVICE_IE_HEADER_TYPE_SHIFT))

/*@}*/

/**
 * \name Generic parameter IE fields
 */
/*@{*/

/**
 * Maximum number of parameters allowed for a service.
 *
 * This was originally 16, but has been reduced to 8 in the
 * latest version of the specification to ease memory management.
 */
#define SERVICE_MAX_PARAMETERS  (8)

/**
 * Test if an IE type is parameter
 */
#define SERVICE_IE_TYPE_IS_PM(tp)               \
    ((tp) <= SERVICE_IE_PM_SERVICE_SPECIFIC_LAST)

/**
 * Test if an IE is a parameter.
 */
#define SERVICE_IE_IS_PM(ie)                    \
    (SERVICE_IE_TYPE_IS_PM(SERVICE_IE_HEADER_TYPE_GET(ie)))

/** Parameter IE: offset to header */
#define SERVICE_IE_PM_HEADER_OFFSET     \
    (SERVICE_IE_HEADER_OFFSET + SERVICE_IE_HEADER_WORDS)
/** Parameter IE: length of header */
#define SERVICE_IE_PM_HEADER_WORDS      (1U)

/** Get the entire parameter header (a single word) */
#define SERVICE_IE_PM_HEADER_WORD_GET(words)         \
    ((words)[SERVICE_IE_PM_HEADER_OFFSET])

/** Set the parameter header as a single word. */
#define SERVICE_IE_PM_HEADER_WORD_SET(dwords, val)      \
    ((dwords)[SERVICE_IE_PM_HEADER_OFFSET] = (val))

/** Get a generic field from a parameter IE header. */
#define SERVICE_IE_PM_FIELD_GET(field, words)   \
    (((words)[SERVICE_IE_PM_HEADER_OFFSET] &    \
      SERVICE_IE_PM_ ## field ## _MASK) >>      \
     SERVICE_IE_PM_ ## field ## _SHIFT)
#define SERVICE_IE_PM_FIELD_SET(field, words, value)    \
    ((words)[SERVICE_IE_PM_HEADER_OFFSET] =             \
     ((words)[SERVICE_IE_PM_HEADER_OFFSET] &            \
      ~SERVICE_IE_PM_ ## field ## _MASK) |              \
     ((value) << SERVICE_IE_PM_ ## field ## _SHIFT))

/** Parameter IE: index mask */
#define SERVICE_IE_PM_INDEX_MASK        (0x000fU)
/** Parameter IE: index shift */
#define SERVICE_IE_PM_INDEX_SHIFT       (0)
/** Parameter IE: Get parameter index from IE */
#define SERVICE_IE_PM_INDEX_GET(words)          \
    SERVICE_IE_PM_FIELD_GET(INDEX, words)

/** Parameter IE: Provider to consumer flag mask */
#define SERVICE_IE_PM_P2C_MASK  (0x0010U)
/** Parameter IE: Provider to consumer flag shift */
#define SERVICE_IE_PM_P2C_SHIFT (4)
/** Parameter IE: Get provider to consumer flag from IE */
#define SERVICE_IE_PM_P2C_GET(words) \
    SERVICE_IE_PM_FIELD_GET(P2C, words)

/** Parameter IE: Consumer to provider flag mask */
#define SERVICE_IE_PM_C2P_MASK  (0x0020U)
/** Parameter IE: Consumer to provider flag shift */
#define SERVICE_IE_PM_C2P_SHIFT (5)
/** Parameter IE: Get consumer to provider flag */
#define SERVICE_IE_PM_C2P_GET(words) \
    SERVICE_IE_PM_FIELD_GET(C2P, words)

/** Parameter IE: Provider supplier flag mask */
#define SERVICE_IE_PM_PS_MASK  (0x0040U)
/** Parameter IE: Provider supplier flag shift */
#define SERVICE_IE_PM_PS_SHIFT (6)
/** Parameter IE: Get provider supplier flag */
#define SERVICE_IE_PM_PS_GET(words) \
    SERVICE_IE_PM_FIELD_GET(PS, words)

/** Parameter IE: Consumer supplier flag mask */
#define SERVICE_IE_PM_CS_MASK  (0x0080U)
/** Parameter IE: Consumer supplier flag shift */
#define SERVICE_IE_PM_CS_SHIFT (7)
/** Parameter IE: Get consumer supplier flag */
#define SERVICE_IE_PM_CS_GET(words) \
    SERVICE_IE_PM_FIELD_GET(CS, words)

/** Parameter IE: Host access flag mask */
#define SERVICE_IE_PM_HA_MASK  (0x0100U)
/** Parameter IE: Host access flag shift */
#define SERVICE_IE_PM_HA_SHIFT (8)
/** Parameter IE: Get host access flag */
#define SERVICE_IE_PM_HA_GET(words) \
    SERVICE_IE_PM_FIELD_GET(HA, words)

/** Parameter IE: Final offer flag mask */
#define SERVICE_IE_PM_FO_MASK  (0x0200U)
/** Parameter IE: Final offer flag shift */
#define SERVICE_IE_PM_FO_SHIFT (9)
/** Parameter IE: Get final offer flag */
#define SERVICE_IE_PM_FO_GET(words) \
    SERVICE_IE_PM_FIELD_GET(FO, words)

/** Parameter IE: Final response flag mask */
#define SERVICE_IE_PM_FR_MASK  (0x0400U)
/** Parameter IE: Final response flag shift */
#define SERVICE_IE_PM_FR_SHIFT (10)
/** Parameter IE: Get final response flag */
#define SERVICE_IE_PM_FR_GET(words) \
    SERVICE_IE_PM_FIELD_GET(FR, words)

/** Parameter IE: Extended flag mask */
#define SERVICE_IE_PM_EXT_MASK  (0x8000)
/** Parameter IE: Extended flag shift */
#define SERVICE_IE_PM_EXT_SHIFT (15)
/** Parameter IE: Get extended flag */
#define SERVICE_IE_PM_EXT_GET(words) \
    SERVICE_IE_PM_FIELD_GET(EXT, words)

/** Mask for all flags */
#define SERVICE_IE_PM_FLAGS_MASK \
    (SERVICE_IE_PM_P2C_MASK|     \
     SERVICE_IE_PM_C2P_MASK|     \
     SERVICE_IE_PM_PS_MASK|      \
     SERVICE_IE_PM_CS_MASK|      \
     SERVICE_IE_PM_HA_MASK|      \
     SERVICE_IE_PM_FO_MASK|      \
     SERVICE_IE_PM_FR_MASK|      \
     SERVICE_IE_PM_EXT_MASK)

/**
 * Extract all flags, without shifting.
 * To be compared against the individual \c _MASK bits.
 */
#define SERVICE_IE_PM_FLAGS_GET(words)                                  \
    ((words)[SERVICE_IE_PM_HEADER_OFFSET] & SERVICE_IE_PM_FLAGS_MASK)

/**
 * Set a parameter IE header word.
 *
 * This follows the main IE header.
 * Flags are to be 'or' together to form the \c flags argument: note the
 * definitions of the flags (the \c _MASK values) are for use directly in
 * the header word, without additional shifting.
 *
 * This is a very small cosmetic addition to separate the value field
 * from the flag fields, since the index can be 'or'd directly with the
 * flags.
 */
#define SERVICE_IE_PM_HEADER_SET(words, index, flags)           \
    ((words)[SERVICE_IE_PM_HEADER_OFFSET] = (uint16)(           \
     ((index) << SERVICE_IE_PM_INDEX_SHIFT) | (flags)))
/**
 * Create a word containing the parameter index and flags.
 * This is suitable for use in compile-time definitions.
 */
#define SERVICE_IE_PM_HEADER_CREATE(index, flags)       \
    (((index) << SERVICE_IE_PM_INDEX_SHIFT) | (flags))

/** Offset to first payload word of a parameter IE*/
#define SERVICE_IE_PM_PAYLOAD_OFFSET                            \
    (SERVICE_IE_PM_HEADER_OFFSET + SERVICE_IE_PM_HEADER_WORDS)

/*@}*/


/**
 * \name MMU parameter IE fields
 */
/*@{*/

/** MMU parameter IE: offset to MMU buffer handle element */
#define SERVICE_IE_PM_MMU_HANDLE_OFFSET         \
    (SERVICE_IE_PM_PAYLOAD_OFFSET)
/** MMU parameter IE: offset to MMU buffer size element */
#define SERVICE_IE_PM_MMU_SIZE_OFFSET           \
    (SERVICE_IE_PM_PAYLOAD_OFFSET+1U)
/** MMU parameter IE: length in words */
#define SERVICE_IE_PM_MMU_WORDS                 \
    (SERVICE_IE_PM_PAYLOAD_OFFSET+2)
/** MMU parameter IE: length reported in header */
#define SERVICE_IE_PM_MMU_HEADER_LENGTH         \
    SERVICE_IE_ARRAY_LENGTH_TO_HEADER_LENGTH(SERVICE_IE_PM_MMU_WORDS)

/*@}*/


/**
 * \name Message channel IE fields
 */
/*@{*/

/** Message channel IE: offset to ISP information word */
#define SERVICE_IE_PM_MC_ISP_OFFSET          \
    (SERVICE_IE_PM_PAYLOAD_OFFSET)
/** Message channel IE: offset to MMU buffer size word */
#define SERVICE_IE_PM_MC_SIZE_OFFSET          \
    (SERVICE_IE_PM_PAYLOAD_OFFSET+1)
/** Message channel IE: length in words */
#define SERVICE_IE_PM_MC_WORDS                  \
    (SERVICE_IE_PM_PAYLOAD_OFFSET+2)
/** Message channel IE: length reported in header */
#define SERVICE_IE_PM_MC_HEADER_LENGTH                                  \
    SERVICE_IE_ARRAY_LENGTH_TO_HEADER_LENGTH(SERVICE_IE_PM_MMU_WORDS)

/* Macros for address and port not referring to position in IE */
/** Message channel IE: unpack generic field from ISP word */
#define SERVICE_IE_PM_MC_ISP_FIELD_UNPACK(field, word)                 \
    (uint16)((((word) &                                                \
            SERVICE_IE_PM_MC_ISP_ ## field ## _MASK) >>                \
            SERVICE_IE_PM_MC_ISP_ ## field ## _SHIFT))
/* Message channel IE: create generic field in ISP info */
#define SERVICE_IE_PM_MC_ISP_FIELD_CREATE(field, value)      \
    ((value) << SERVICE_IE_PM_MC_ISP_ ## field ## _SHIFT)
/** Message channel IE: destination port in ISP info, mask */
#define SERVICE_IE_PM_MC_ISP_DEST_PORT_MASK    (0x00ffU)
/** Message channel IE: destination port in ISP info, shift */
#define SERVICE_IE_PM_MC_ISP_DEST_PORT_SHIFT      (0)
/** Message channel IE; unpack destination port from ISP word */
#define SERVICE_IE_PM_MC_ISP_DEST_PORT_UNPACK(word)        \
    SERVICE_IE_PM_MC_ISP_FIELD_UNPACK(DEST_PORT, word)
/** Message channel IE: destination port in ISP info, create */
#define SERVICE_IE_PM_MC_ISP_DEST_PORT_CREATE(value)     \
    SERVICE_IE_PM_MC_ISP_FIELD_CREATE(DEST_PORT, value)
/** Message channel IE: destination address in ISP info, mask */
#define SERVICE_IE_PM_MC_ISP_DEST_ADDR_MASK   (0xff00U)
/** Message channel IE: destination address in ISP info, shift */
#define SERVICE_IE_PM_MC_ISP_DEST_ADDR_SHIFT      (8)
/** Message channel IE; unpack destination address from ISP word */
#define SERVICE_IE_PM_MC_ISP_DEST_ADDR_UNPACK(word)     \
    SERVICE_IE_PM_MC_ISP_FIELD_UNPACK(DEST_ADDR, word)
/** Message channel IE: destination address in ISP info, create */
#define SERVICE_IE_PM_MC_ISP_DEST_ADDR_CREATE(value)    \
    SERVICE_IE_PM_MC_ISP_FIELD_CREATE(DEST_ADDR, value)
/** Message channel IE: create the full ISP info word */
#define SERVICE_IE_PM_MC_ISP_CREATE(addr, port)         \
    (SERVICE_IE_PM_MC_ISP_DEST_PORT_CREATE(port) |      \
     SERVICE_IE_PM_MC_ISP_DEST_ADDR_CREATE(addr))

/* Macros referring to position in IE */
/** Message channel IE: extract generic field from ISP info */
#define SERVICE_IE_PM_MC_ISP_FIELD_GET(field, words)                    \
    SERVICE_IE_PM_MC_ISP_FIELD_UNPACK(                                 \
        field,                                                          \
        (words)[SERVICE_IE_PM_MC_ISP_OFFSET])
/** Message channel IE: destination port in ISP info, get */
#define SERVICE_IE_PM_MC_ISP_DEST_PORT_GET(words)        \
    SERVICE_IE_PM_MC_ISP_FIELD_GET(DEST_PORT, words)
/** Message channel IE: destination address in ISP info, get */
#define SERVICE_IE_PM_MC_ISP_DEST_ADDR_GET(words)        \
    SERVICE_IE_PM_MC_ISP_FIELD_GET(DEST_ADDR, words)
/** Set the ISP info word in a message channel parameter IE */
#define SERVICE_IE_PM_MC_ISP_SET(words, addr, port)                  \
    ((words)[SERVICE_IE_PM_MC_ISP_OFFSET] =                          \
     SERVICE_IE_PM_MC_ISP_CREATE(addr, port))

/*@}*/


/*
 * \name Autostart IE fields.
 *
 * There is no macro for giving the offset to individual record
 * headers after the word with the counts in, because I figured that
 * if I died because of banging my head repeatedly against the table
 * before finishing it probably wouldn't do anybody any good.
 */
/*@{*/

/** Offset to word with counts of record headers */
#define SERVICE_IE_AUTOSTART_COUNT_OFFSET \
    (SERVICE_IE_HEADER_OFFSET + SERVICE_IE_HEADER_WORDS)
/**
 * Offset to first record header in autostart IE.
 * Subsequent record headers are \c CCP_SERVICE_RECORD_HEADER_WORD_SIZE
 * words apart.
 */
#define SERVICE_IE_AUTOSTART_SRH_OFFSET         \
    (SERVICE_IE_AUTOSTART_COUNT_OFFSET+1)
/**
 * Autostart IE: length in words is variable.
 * Given the number of partners and triggers, this calculates it.
 */
#define SERVICE_IE_AUTOSTART_WORDS(npartners, ntriggers)        \
    (SERVICE_IE_AUTOSTART_SRH_OFFSET + 2*((npartners)+(ntriggers)))
/**
 * Autostart IE: length reported in header.
 */
#define SERVICE_IE_AUTOSTART_HEADER_LENGTH(npartners, ntriggers)        \
    SERVICE_IE_ARRAY_LENGTH_TO_HEADER_LENGTH(                           \
        SERVICE_IE_AUTOSTART_WORDS(npartners, ntriggers))

/**
 * Generic macro to get fields in count word
 */
#define SERVICE_IE_AUTOSTART_COUNT_FIELD_GET(field, words)       \
    (((words)[SERVICE_IE_AUTOSTART_COUNT_OFFSET] &               \
      SERVICE_IE_AUTOSTART_ ## field ## _MASK) >>                \
     SERVICE_IE_AUTOSTART_ ## field ## _SHIFT)
/** Mask for number of partner services in autostart record */
#define SERVICE_IE_AUTOSTART_NPARTNERS_MASK     (0x00ff)
/** Shift for number of partner services in autostart record */
#define SERVICE_IE_AUTOSTART_NPARTNERS_SHIFT    (0)
/** Get number of partner services from autostart record */
#define SERVICE_IE_AUTOSTART_NPARTNERS_GET(words)               \
    SERVICE_IE_AUTOSTART_COUNT_FIELD_GET(NPARTNERS, words)
/** Mask for number of trigger services in autostart record */
#define SERVICE_IE_AUTOSTART_NTRIGGERS_MASK     (0xff00)
/** Shift for number of trigger services in autostart record */
#define SERVICE_IE_AUTOSTART_NTRIGGERS_SHIFT    (8)
/** Get number of trigger services from autostart record */
#define SERVICE_IE_AUTOSTART_NTRIGGERS_GET(words)               \
    SERVICE_IE_AUTOSTART_COUNT_FIELD_GET(NTRIGGERS, words)
/** Set count field in autostart record */
#define SERVICE_IE_AUTOSTART_COUNT_SET(words, npartners, ntriggers)     \
    ((words)[SERVICE_IE_AUTOSTART_COUNT_OFFSET] =                       \
     ((npartners) << SERVICE_IE_AUTOSTART_NPARTNERS_SHIFT) |            \
     ((ntriggers) << SERVICE_IE_AUTOSTART_NTRIGGERS_SHIFT))
/**
 * Create a count field for an autostart record.
 * This is suitable for compile-time definitions.
 */
#define SERVICE_IE_AUTOSTART_COUNT_CREATE(npartners, ntriggers) \
    (((npartners) << SERVICE_IE_AUTOSTART_NPARTNERS_SHIFT) |    \
     ((ntriggers) << SERVICE_IE_AUTOSTART_NTRIGGERS_SHIFT))

/*@}*/

/**
 * \name Auxiliary command channel IE.
 * Nothing but the header.
 */
/*@{*/

/** Length in words */
#define SERVICE_IE_AUX_CMD_CHANNEL_WORDS (SERVICE_IE_HEADER_WORDS)

/** Length reported in header */
#define SERVICE_IE_AUX_CMD_CHANNEL_HEADER_LENGTH        \
    SERVICE_IE_ARRAY_LENGTH_TO_HEADER_LENGTH(SERVICE_IE_AUX_CMD_CHANNEL_WORDS)

/*@}*/

/**
 * \name Autostart Triggered IE fields.
 */
/*@{*/

/** Offset to word with count of record headers of triggered services */
#define SERVICE_IE_AUTOSTART_TRIGGERED_COUNT_OFFSET \
    (SERVICE_IE_HEADER_OFFSET + SERVICE_IE_HEADER_WORDS)
/**
 * Offset to first record header in Autostart Triggered IE.
 * Subsequent record headers are \c CCP_SERVICE_RECORD_HEADER_WORD_SIZE
 * words apart.
 */
#define SERVICE_IE_AUTOSTART_TRIGGERED_SRH_OFFSET       \
    (SERVICE_IE_AUTOSTART_TRIGGERED_COUNT_OFFSET+1)
/**
 * Autostart Triggered IE: length in words is variable.
 * Given the number of tiggered services, this calculates it.
 */
#define SERVICE_IE_AUTOSTART_TRIGGERED_WORDS(ntriggered)                \
    (SERVICE_IE_AUTOSTART_TRIGGERED_SRH_OFFSET + 2*(ntriggered))
/**
 * Autostart Triggered IE: length reported in header.
 */
#define SERVICE_IE_AUTOSTART_TRIGGERED_HEADER_LENGTH(ntriggered)        \
    SERVICE_IE_ARRAY_LENGTH_TO_HEADER_LENGTH(                           \
        SERVICE_IE_AUTOSTART_TRIGGERED_WORDS(ntriggered))

/*@}*/

/**
 * \name Option IE fields.
 *
 * Not much here, all payloads are currently service-specific even
 * where the type has a defined meaning.
 */
/*@{*/

/** Offset to start of payload in option IE */
#define SERVICE_IE_OPTION_PAYLOAD_OFFSET                        \
    (SERVICE_IE_HEADER_OFFSET + SERVICE_IE_HEADER_WORDS)

/**
 * Test if an IE type is an option.
 */
#define SERVICE_IE_TYPE_IS_OPTION(tp)           \
    ((tp) >= SERVICE_IE_OPTION_FIRST)

/**
 * Test if an IE is an option.
 */
#define SERVICE_IE_IS_OPTION(ie)                                \
    (SERVICE_IE_TYPE_IS_OPTION(SERVICE_IE_HEADER_TYPE_GET(ie)))

/** The infamous *2* : bits per uint16 / bits per octet. 
 * Use this instead of magic *2 in the code when converting from
 * numbers that count IE words into octets.
 * This must give the same value regardless of chip architecture,
 * e.g. on linux for unit tests, as well as on XAPs and DSPs. */
#define SERVICE_IE_OCTETS_PER_IE_WORD (16/8)

/*@}*/


/**
 * Details assocated with reason codes for low resources.
 */
typedef enum SERVICE_RESOURCE
{
    /** Resource is pool memory (\c pmalloc) */
    SERVICE_RESOURCE_POOL_MEMORY = 0,
    /** Resource is buffer memory */
    SERVICE_RESOURCE_BUFFER_MEMORY = 1,
    /** Resource is CPU */
    SERVICE_RESOURCE_CPU = 2,
    /** Resource is \c globserv storage for service instances */
    SERVICE_RESOURCE_INSTANCE = 3,
    /** Resource is other than one those listed above */
    SERVICE_RESOURCE_UNSPECIFIED = 255
} SERVICE_RESOURCE;

/**
 * Flags supplied with a query.
 */
typedef enum SERVICE_QUERY_FLAGS
{
    /**
     * If 0, only return service record headers.
     * If 1, return full service records, each one formatted
     * as a 16-bit length of the record (not counting the
     * length field), the service record header, and any
     * IEs.
     */
    SERVICE_QUERY_FLAG_FULL = 1,
    /**
     * If 0, only return services advertised to the host.
     * If 1, return any service including those advertised for
     * use on chip.
     */
    SERVICE_QUERY_FLAG_ALL = 2,
    /**
     * If 1, query the service that would be started if the
     * same header information were passed to a service start request.
     * This means service IDs must be explicit and at most
     * one service is returned per header in the query.
     * If 0, allow all wildcards and return all matches.
     */
    SERVICE_QUERY_FLAG_START = 4
} SERVICE_QUERY_FLAGS;

/** Service tag */
typedef uint16 STAG;
/** Invalid service stag */
typedef enum STAG_SPECIAL
{
    STAG_INVALID = 0
} STAG_SPECIAL;


/**
 * \name Utilities for handling IEs.
 *
 * IEs can be manipulated directly using the definitions above;
 * these utilities provide additional shortcuts.
 *
 * Functions are in \c hydra_service_ie_utils.c.
 */
/*@{*/

/**
 * Structure for encapsulating a pointer to a set of IEs.
 * Whether the \c ie pointer is owned by the structure depends
 * on the context, but typically it's allocated and copied elsewhere.
 * It's therefore more convenient to have data associated with
 * the structure marked as \c const.
 *
 * (Reminder: that's a different thing from a \c const \c
 * SERVICE_IE_PTR, which is saying you won't modify the elements
 * of the structure.)
 */
typedef struct SERVICE_IE_PTR
{
    /**
     * Pointer to current entry in IE
     */
    const uint16 *ptr;
    /**
     * Length of IE array in \c ptr.
     * This is decremented when we advance the \c ie pointer.
     *
     * Careful: this is \e not the length of an IE.  It is
     * the length of all the IEs remaining in the array at
     * \c ptr (or, if we are building up an IE array, it's
     * the length remaining for us to write IEs into).
     * For the length of \e one IE, use \c
     * SERVICE_IE_HEADER_LENGTH_GET(ie->ptr), and to make
     * that compatible with the units of \c len the result
     * needs to be halved and one added (it counts octets
     * after the first pair, not total words in the element).
     */
    uint16 len;
} SERVICE_IE_PTR;

/**
 * Structure for copying IEs into.
 * Equivalent to \c SERVICE_IE_PTR except the pointer is not
 * constant.  We apply a different and more restricted set
 * of operations to this structure as it points to uninitialised
 * memory.
 */
typedef struct SERVICE_IE_DEST_PTR
{
    /** Destination for next IE */
    uint16 *ptr;
    /**
     * Space left for copying IE into.
     * In other words, this is initialised to the length of the
     * pointer as  assigned and counts down as we fill the area.
     */
    uint16 len;
} SERVICE_IE_DEST_PTR;

/**
 * Clear the IE so it contains no information.
 */
#define SERVICE_IE_PTR_CLEAR(iep)   ((iep)->ptr = NULL, (iep)->len = 0U)

/**
 * Copy IE pointer information.
 */
#define SERVICE_IE_PTR_COPY(iepdst, iepsrc)                                \
    ((iepdst)->ptr = (iepsrc)->ptr, (iepdst)->len = (iepsrc)->len)

/**
 * Ensure the next IE in the list is valid.
 * This does not check that the whole list of IEs is valid.
 */
extern bool hydra_service_ie_valid(const SERVICE_IE_PTR *const ie);

/**
 * Advance the pointer to the next IE in the list.
 * Update the length also.  The length will be zero if the previous
 * IE was the last (the operation is still valid).
 * It is a fatal error if IE to be incremented is invalid;
 * use \c hydra_service_ie_valid() to ensure the current IE is vald.
 */
extern void hydra_service_ie_next(SERVICE_IE_PTR *ie);

/**
 * Find the parameter \c index in the IE list \c ie.
 *
 * \c ie is updated as a pointer (whether or not the IE is found).
 *
 * If parameter number \c index is found, return \c TRUE; ie->ptr
 * and ie->len are updated to point to the parameter.
 *
 * If parameter number \c index is not found, return \c FALSE; ie->ptr
 * and ie->len indicate the end of the list, unless the list
 * was invalid.
 */
extern bool hydra_service_ie_pm_find(SERVICE_IE_PTR *ie, uint16 index);

/**
 * Find the first IE of a given type in an IE array.
 *
 * \c ie is the array.
 * \c tp is the type to search for; any IE type can be used as the
 *    IE itself is not examined.
 *
 * \return \c TRUE if found, in which case \c ie is updated so that
 * \c ie->ptr is the found entry, else \c FALSE.
 *
 * It is possible subsequently to search for subsequent IEs of the same
 * type by using \c hydra_service_ie_next() to advance over the matched
 * IE.
 */
extern bool hydra_service_ie_type_find(SERVICE_IE_PTR *ie, uint16 tp);

/**
 * Copy an IE to the destination.
 * The \c len field in the destination is the remaining space in the
 * IE array; it is used as a safety check.
 *
 * Only the first IE is used in the source array; it is not sanity checked.
 */
extern void hydra_service_ie_copy(SERVICE_IE_DEST_PTR *dest,
                                  const SERVICE_IE_PTR *src);

/**
 * Copy an IE to the destination, updating the destination pointers.
 * The \c len field in the destination is the remaining space in the
 * IE array; it is used as a safety check.
 *
 * Only the first IE is used in the source array; it is not sanity checked.
 */
extern void hydra_service_ie_copy_and_inc(SERVICE_IE_DEST_PTR *dest,
                                          const SERVICE_IE_PTR *src);

/**
 * Increment a destination pointer (\c SERVICE_IE_DEST_PTR).
 * This is a different type from \c SERVICE_IE_PTR for \c const safety.
 * The overhead is limited, however.
 */
extern void hydra_service_ie_dest_inc(SERVICE_IE_DEST_PTR *dest);

/**
 * Return a pointer to the first IE of the given type in the IE array, without
 * touching the IE array.
 */
extern const uint16 * hydra_service_ie_option_type_get_first(const SERVICE_IE_PTR *ies,
                                               uint16 ie_id);
/*@}*/

#endif /* HYDRA_SERVICE_H */
