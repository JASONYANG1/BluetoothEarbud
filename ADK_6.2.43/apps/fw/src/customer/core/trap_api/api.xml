<!-- Copyright (c) 2016 Qualcomm Technologies International, Ltd. -->
<!--   Part of 6.2 -->
<api>
  <version>
    <major>8</major>
    <minor>0</minor>
  </version>
  <trapsets>
    <trapset builddefs="defined(INSTALL_FASTPIPE)" index="1" name="FASTPIPE" />
    <trapset builddefs="defined(INSTALL_CHARGER_SUPPORT)" index="2" name="CHARGER" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(INSTALL_FILE_MODULE)" index="3" name="FILE" />
    <trapset builddefs="defined(INSTALL_ADPCM) &amp;&amp; defined(INSTALL_DM_SYNC_MODULE)" index="4" name="VOICE" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(TRANSPORT_USER)" index="5" name="UART" />
    <trapset builddefs="STREAM_ &amp;&amp; HOST_ &amp;&amp; defined(INSTALL_HOST_STREAM)" index="6" name="HOSTSTREAM" />
    <trapset builddefs="defined(INSTALL_SCO_ENERGY_ESTIMATION)" index="7" name="ENERGY" />
    <trapset builddefs="defined(INSTALL_CAPACITIVE_SENSOR)" index="8" name="CAPACITIVE_SENSOR" />
    <trapset builddefs="(defined(TRANSPORT_NONE) || defined(TRANSPORT_USER) || defined(TRANSPORT_USB))" index="9" name="RTSCTS" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(INSTALL_AUDIO_MODULE)" index="10" name="AUDIO" />
    <trapset builddefs="defined(INSTALL_PIO_SET_FUNCTION)" index="11" name="PIOEX1" />
    <trapset builddefs="STREAM_ &amp;&amp; DSP_" index="12" name="KALIMBA" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(INSTALL_RFCOMM_MODULE)" index="13" name="RFCOMM" />
    <trapset builddefs="defined(INSTALL_FILE_MODULE) &amp;&amp; defined(INSTALL_FONT_MODULE)" index="14" name="FONT" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(INSTALL_L2CAP_MODULE)" index="15" name="BLUESTACK" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(INSTALL_FLASH) &amp;&amp; defined(INSTALL_SQIF)" index="16" name="REFORMATSQIF" />
    <trapset builddefs="defined(INSTALL_STIBBONS)" index="17" name="OPERATOR" />
    <trapset builddefs="defined(HAVE_LCD_HARDWARE)" index="18" name="LCD" />
    <trapset builddefs="defined(HAVE_CHARGER_INTERRUPTS)" index="19" name="CHARGERMESSAGE" />
    <trapset builddefs="defined(HAVE_PSU_HARDWARE)" index="20" name="PSU" />
    <trapset builddefs="defined(HAVE_MIC_BIAS_HARDWARE)" index="21" name="MICBIAS" />
    <trapset builddefs="STREAM_" index="22" name="STREAM" />
    <trapset builddefs="defined(INSTALL_IR)" index="23" name="INFRARED" />
    <trapset builddefs="defined(INSTALL_ATT_MODULE)" index="24" name="ATT" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(INSTALL_HIDBLEIO_MODULE)" index="25" name="HIDDONGLE" />
    <trapset builddefs="defined(INSTALL_NATIVE_APPLICATION)" index="26" name="NATIVE" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(INSTALL_SERIAL_FLASH_STREAM)" index="27" name="SPIFLASH" />
    <trapset builddefs="1" index="28" name="CORE" />
    <trapset builddefs="defined(INSTALL_LOADER_UPGRADE)" index="29" name="LDRUPGRADE" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(INSTALL_SQIF) &amp;&amp; defined(INSTALL_FILE_MODULE)" index="30" name="PARTITION" />
    <trapset builddefs="defined(HAVE_AMUX_CLOCK) &amp;&amp; !defined(CHIP_BASE_BC5)" index="31" name="AMUXCLOCK" />
    <trapset builddefs="HOST_" index="32" name="HOST" />
    <trapset builddefs="" index="33" name="SQIFEXECUTE" />
    <trapset builddefs="" index="34" name="MD5" />
    <trapset builddefs="defined(HAVE_LED_HARDWARE)" index="35" name="LED" />
    <trapset builddefs="defined(CHIP_BASE_JEMIMA)" index="36" name="BC7" />
    <trapset builddefs="STREAM_ &amp;&amp; USB_" index="37" name="USB" />
    <trapset builddefs="USB_HUB_" index="38" name="USB_HUB" />
    <trapset builddefs="defined(INSTALL_EXTERNAL_SRAM)" index="39" name="SRAM" />
    <trapset builddefs="defined(HAVE_GORDON_CHARGER) &amp;&amp; defined(INSTALL_CHARGER_SUPPORT)" index="40" name="CHARGER2" />
    <trapset builddefs="defined(INSTALL_MCDSP_SHUNT)" index="41" name="SHUNT" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(INSTALL_IIC_STREAM)" index="42" name="IICSTREAM" />
    <trapset builddefs="defined(HAVE_CODEC_ADC_IIR_FILTER)" index="43" name="IIR" />
    <trapset builddefs="defined(HAVE_TSMC_OTP)" index="44" name="OTP" />
    <trapset builddefs="defined(INSTALL_I2C)" index="45" name="IIC" />
    <trapset builddefs="!defined(DISABLE_EVT)" index="46" name="STATUS" />
    <trapset builddefs="defined(HAVE_AUX_DAC)" index="47" name="AUXDAC" />
    <trapset builddefs="1" index="48" name="TEST" />
    <trapset builddefs="" index="49" name="BLE3DD" />
    <trapset builddefs="" index="50" name="IIR16BIT" />
    <trapset builddefs="" index="51" name="NFC" />
    <trapset builddefs="STREAM_ &amp;&amp; defined(INSTALL_SD_MMC_STREAM)" index="52" name="SD_MMC" />
    <trapset builddefs="defined(INSTALL_IMAGE_UPGRADE)" index="53" name="IMAGEUPGRADE" />
    <trapset builddefs="STREAM_ &amp;&amp; (defined(INSTALL_CONNECTIONLESS_BROADCASTER) || defined(INSTALL_CONNECTIONLESS_LISTENER))" index="54" name="CSB" />
    <trapset builddefs="" index="55" name="AUDIO_MCLK" />
    <trapset builddefs="" index="56" name="CRYPTO" />
    <trapset builddefs="defined(CHIP_HAS_PWM_OUTPUTS)" index="57" name="AUDIO_PWM" />
    <trapset builddefs="" index="58" name="XIO" />
    <trapset builddefs="" index="59" name="BITSERIAL" />
    <trapset builddefs="" index="60" name="AUDIO_ANC" />
    <trapset builddefs="defined(INSTALL_WAKE_ON_AUDIO)" index="61" name="WAKE_ON_AUDIO" />
    <trapset builddefs="defined(CCP_CLOCK_CONTROL)" index="62" name="PROFILE" />
  </trapsets>
  <headers>
    <header name="Ps">
      <preamble>
/*! @file ps.h
@brief Access to persistent store.
** 
A user application running on the VM can access the persistent store on 
BlueCore which provides a small amount of non-volatile storage.
** 
Up to two hundred keys can be used, 0 to 199. There are no predefined
meanings for these keys; they can be used for any purpose required by the user
application. However, the total amount of data associated with all the keys
should be kept as small as possible.
** 
These keys are divided into three blocks of equal size and function
- User configuration data (0 to 49). 
- DSP configuration (50 to 99).
- VM Connection Library data (100 to 149) NOTE: Applications MUST NOT use these.
- User configuration data, 2nd block (150 to 199).
** 
The first twenty-five in both blocks, 0 to 24 and 50 to 74, are protected
against upload and modification via DFU (Device Firmware Upgrade) unless
accompanied by a valid signature. Hence, they should be used for sensitive data
such as cryptographic keys.
** 
The maximum length of persistent store key that is guaranteed to be supported by
the BlueCore firmware and its supporting tools is 64 words. Attempts to use
longer persistent store keys may return failure or may cause undefined firmware
behaviour.
** 
@par Notes
The persistent store is normally held in flash memory. This means that only a
finite number of changes can be made to values held in persistent store without
performing a defragment of the flash. The defragment is a time and memory
intensive operation that is only performed at boot time. Hence the number of
changes to the value of a key should be kept to a minimum. If the return code
from PsStore() indicates a failure then the chip needs to be reset for a
defragment to occur. To control when defragmentation occurs, use PsFlood() and
BootSetMode().  When persistent store is held in EEPROM, write operations to
EEPROM are time consuming. So during Bluetooth activity, avoid back-to-back
multiple PSKEY reads and writes since this may cause undefined firmware
behaviour.
** 
@par Notes
Doing error checks on a key's value costs code space and usually has no
effect.If the value of a key gives an error then it should be detected while the
module is being designed (or by the tools if you have simple keys) and so the
error checking is redundant in the field. The only exception is where it's
possible to set a key in such a way that the chip doesn't boot. In this case,
the user may be unable to recover the module once they've set the key. In this
case, you may want to consider issuing a fault and falling back to sane values
if the key is wrong.  It may be worth considering overriding certain settings
depending on other keys as a way of avoiding synchronised settings.  If you end
up overriding a whole key then the key is redundant and can be removed. If you
override part of a key, say a bit fielded key, then it costs little code to
simply apply a mask to the value read from persistent store and then set bits
later.
*/
</preamble>
      <extra_header>app/ps/ps_if.h</extra_header>
    </header>
    <header name="ble3dd">
      <preamble>
/*! @file ble3dd.h @brief Traps to control the 3DD adverts */
</preamble>
    </header>
    <header name="Usb_Hub">
      <preamble>
/*! @file usb_hub.h @brief Control of internal USB hub. 
** 
**
The new USB device architecture includes an internal USB hub, these
traps allow some control over it, like attaching/detaching device
to/from the hub.
*/
</preamble>
    <extra_header>app/usb/usb_if.h</extra_header>
    <extra_header>app/usb/usb_hub_if.h</extra_header>
    </header>
    <header name="Usb">
      <preamble>
/*! @file usb.h @brief Control of USB EndPoints, and other USB related traps. 
** 
** 
Bluelab applications have access to the on-chip USB interface.
USB devices communications occur through channels known as endpoints.
The USB specification defines a number of USB device classes through
Class Specifications. Each of the Class Specifications define the type
and direction of endpoints required to comply with that particular device
class. Examples include the Human Interface Device (HID) class, and the 
Communication Device Class (CDC).
** 
** 
In addition to the documentation provided here, the USB2.0 specification and
the "Bluetooth and USB Design Considerations" document available from
www.csrsupport.com are useful sources of information.
*/
</preamble>
      <extra_header>app/usb/usb_if.h</extra_header>
    </header>
    <header name="Micbias">
      <preamble>
/*! @file micbias.h @brief Traps to control the Microphone bias hardware */
</preamble>
      <extra_header>app/mic_bias/mic_bias_if.h</extra_header>
    </header>
    <header name="Boot">
      <preamble>
/*! @file boot.h @brief Control booting BlueCore with different active settings 
** 
** 
These functions control the BlueCore bootmode on unified firmware. Each bootmode has a unique view of the
persistent store, and so a single device could boot up as (for example) an HCI dongle using USB in one bootmode
and a HID dongle using BCSP in another bootmode.
** 
Incorrect use of these functions could produce a non-functional module, and so caution should be exercised. 
** 
BootGetPreservedWord and BootSetPreservedWord can be used to preserve a single word of state between boots.
*/
</preamble>
    </header>
    <header name="Transform">
      <preamble>
/*! @file transform.h @brief Transform data between sources and sinks */
</preamble>
      <extra_header>app/vm/vm_if.h</extra_header>
      <extra_header>sink_.h</extra_header>
      <extra_header>source_.h</extra_header>
      <extra_header>transform_.h</extra_header>
    </header>
    <header name="feature">
      <preamble>
/*! @file feature.h @brief Related to licensing of new features
*/
</preamble>
      <extra_header>app/feature/feature_if.h</extra_header>
    </header>
    <header name="Source">
      <preamble>
/*! @file source.h @brief Operations on sources of 8-bit data */
/*! Discard all bytes that are currently in the source */
#define SourceEmpty(s) do { Source _x=(s); SourceDrop(_x, SourceSize(_x)); } while(0)
</preamble>
      <extra_header>source_.h</extra_header>
      <extra_header>app/vm/vm_if.h</extra_header>
      <extra_header>app/stream/stream_if.h</extra_header>
    </header>
    <header name="Inquiry">
      <preamble>
/*! @file inquiry.h @brief Configure Bluetooth inquiry procedure.
**
**
These functions can be used to change the details of how BlueCore
schedules Bluetooth inquiry relative to other Bluetooth activity.
They are equivalent to the Inquiry_Priority BCCMD.
*/
</preamble>
    <extra_header>app/bluestack/types.h</extra_header>
    </header>
    <header name="Adc">
      <preamble>
/*! @file adc.h @brief Access to ADC hardware.
** 
**  
BlueCore has an analogue-to-digital converter (ADC) which can be
used to read the  voltage at a number of locations, such as:
- At AIO pins #adcsel_aio0 to #adcsel_aio3.
- From #adcsel_vref - the internal voltage in the chip.
- From #adcsel_vdd_bat - the battery.
.
(Note that this hardware is distinct from the ADCs that form part
of the analogue audio codec.)
**    
Note that not all sources are available on all BlueCores.
**    
The voltage (in mV) from a source is given by:
**
(reading) * VrefConstant / (vref_reading) 
**
\a reading comes from the #MESSAGE_ADC_RESULT for the source in
question. \a vref_reading is a corresponding reading for
#adcsel_vref that has been taken relatively recently.
VmReadVrefConstant() should be used to determine \a VrefConstant.
This calculation determines how many mV each bit of \a reading 
corresponds to, correcting for natural variation and systematic
errors in the ADC reading process.
**
For example, on CSR8670 VmReadVrefConstant() returns 700 (which is in
mV, and therefore represents 0.7 V). A reading of #adcsel_vref might 
return 531 (this number will vary slightly with process and 
temperature). In which case, 1 bit of ADC reading corresponds 
to a real value of 700/531 mV. Hence, if a reading of 100 is 
obtained from #adcsel_aio0, this corresponds to a true voltage of
**
100 * 700/531 = 132 mV on AIO0.
**
The underlying hardware has 8 bits of resolution on older BlueCores,
and 10 bits of resolution from BlueCore 5 onwards. The raw reading
may be conditioned by the firmware before being returned to the
application.
*/
</preamble>
      <extra_header>message_.h</extra_header>
      <extra_header>app/vm/vm_if.h</extra_header>
      <extra_header>app/adc/adc_if.h</extra_header>
    </header>
    <header name="Test">
      <preamble>
/*! @file test.h @brief Functions to enter BlueCore test modes */
#define FIRST_PCM_IF 0
</preamble>
    </header>
    <header name="Panic">
      <preamble>
/*! @file panic.h @brief Terminate the application unhappily. 
** 
** 
These functions can be used to panic the application, forcing it to terminate abnormally.
*/
/*!
Panics the application if the value passed is FALSE.
*/
#define PanicFalse PanicZero
/*!
Panics the application if the value passed is zero.
*/
#define PanicZero(x) (unsigned int) PanicNull((void *) (x))
/*!
Panics the application if the value passed is not zero.
*/
#define PanicNotZero(x) PanicNotNull((const void *) (x))
/*!
Allocates memory equal to the size of T and returns a pointer to the memory if successful. If the
memory allocation fails, the application is panicked.
*/
#define PanicUnlessNew(T) (T*)PanicUnlessMalloc(sizeof(T))
</preamble>
    </header>
    <header name="Status">
      <preamble>
/*! @file status.h @brief Access to chip status information.
** 
** 
Functions to access the chip status information.
*/
</preamble>
      <extra_header>message_.h</extra_header>
      <extra_header>app/status/status_if.h</extra_header>
    </header>
    <header name="Kalimba">
      <preamble>
/*! @file kalimba.h @brief Control of the Kalimba DSP */
</preamble>
      <extra_header>app/file/file_if.h</extra_header>
    </header>
    <header name="Led">
      <preamble>
/*! @file led.h @brief Traps to control the LED hardware present on some BlueCore variants */
</preamble>
      <extra_header>app/led/led_if.h</extra_header>
    </header>
    <header name="Sram">
      <preamble>
/*! @file sram.h @brief Traps to map SRAM into VM memory space */
</preamble>
    </header>
    <header name="Host">
      <preamble>
/*!
\file host.h
\brief Host communication over the TestTunnel 'host' transport.
**
A user application can communicate with the outside world by
using the 'host' TestTunnel. This library provides a simple
interface for the user application
to:
- send and receive \ref host_messages
- send and receive \ref host_streams (not supported in ADK6)
**
An application which does not use a host transport can use the
USB or UART interface directly, using the stream.h library. 
The host library is not used in that case.
**
User-written software on the host based on TestEngine is expected
to form the other end of the connection.
**
See \ref host for more info.
**
\page host Host communication
\section host_messages 16-bit data in messages
\subsection host_message_fmt Format of a packet
**
The packet format that is used by the VM for communications is
very simple, but allows the user to implement a large number of
features on top of the simple interface that we provide. The
packet begins with one 16-bit word indicating the length of the
packet (including the header), followed by a sub-type word. For
messages the sub-type can have any value in the range of 0-127
(0x00-0x7f), and is meant to indicate the type of the packet to
the code at either end. There are no restrictions on the use of
this word, as long as it is within the correct range. The
remaining words in the packet can contain any 16-bit data.
**
Typically the sub-type field is used to multiplex an number of
distinct channels between the application and the host.
**
All packets are held in dynamic memory blocks and the
constraints on number and size of these described in the
standard library apply to packets.
**
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;Length (16bit)&lt;/td&gt;
&lt;td&gt;Sub-type (16bit)&lt;/td&gt;
&lt;td&gt;Data...&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
**
To receive packets from the host, the application must register a 
task for #MESSAGE_FROM_HOST using MessageHostCommsTask().
**
\subsection host_message_code Example code
Send a small packet to the host
\code
uint16 *data = PanicUnlessMalloc(3 * sizeof(uint16));
data[0] = 3; // length
data[1] = 0x7e; // sub-type
data[2] = 0x1234; // data
HostSendMessage(data);
data = NULL; // we don't own this block anymore
\endcode
**
\section host_streams 8-bit data over Streams
There are 256 sources and 256 sinks associated with
stream-based host communications; an application might use
one for control and one for data.
**
An application can obtain the source and sink for a particular
one of the 256 channels using the StreamHostSource() and
StreamHostSink() functions. The source and sink are then
manipulated using the other functions from the stream.h 
library.
**
\subsection host_stream_fmt Format of a packet
The format of a packet is almost identical to that used for
messages; this preserves compatibility with existing firmware,
at the cost of making the stream-based protocol more complex
than strictly necessary.
**
The packet again begins with one 16-bit word indicating the
length of the packet in words (including the header), followed
by a sub-type word. The payload follows, with the bytes packed
into 16-bit words in low-byte high-byte order and padded out to
a 16-bit boundary. That is a payload of 0x01, 0x02, 0x03 will
be packed as 0x0201, 0x0003. For streams the sub-type can have
any value in the range of 0x100-0x2ff, and encodes both the 
stream being used and whether the payload includes a padding 
byte.
**
The bottom 8-bits of the sub-type word encode the channel for
the source or sink. If the top 8-bits are 2 then all of the 
bytes of the payload are used, if 1 then the top byte of the 
last word is not part of the payload.
**
In other words, a consumer might look like:
\code
void incoming(const uint16 *packet)
{
uint16 words = packet[0];
uint16 type  = packet[1];
uint16 chan  = type &amp; 0xff;
uint16 bytes = (words - 2) * 2 - ((type &gt;&gt; 8) == 1);
...
}
\endcode
**
\subsection host_stream_code Example code
Send a 2 byte packet to the host on channel 1
\code
Sink sink = PanicNull(StreamHostSink(1));
uint8 *data = SinkMap(sink) + SinkClaim(sink, 2);
data[0] = 0x12;
data[1] = 0x34;
PanicZero(SinkFlush(sink, 2));
\endcode
**
Process packets from the host on channel 2
\code
uint16 size;
Source source = StreamHostSource(2);
while ((size = SourceBoundary(source)) != 0)
{
const uint8 *data = SourceMap(source);
// do something with the data here
SourceDrop(source, size);
}
\endcode
**
\section host_issues Related Issues
\subsection host_limitations Limitations
All packets must fit in an available on-chip memory block
and as such are restricted to around 80 words in total.
This restriction applies even to stream-based messages.
**
If a packet arrives for a source and insufficient space is
available, the message will be silently discarded. Users
can expect to have at most 200 bytes of data held in any
source associated with host communications.
**
\subsection host_coex Coexistence
Both message and stream based host communications can be
used in the same application as required; the second word
of a data message is used to distinguish between the two
formats.
**
Which is more appropriate depends on your application:
streams are designed for 8-bit data, while messages are
more suited to packed binary data such as structures.
*/
</preamble>
    </header>
    <header name="Util">
      <preamble>
/*! @file util.h @brief Utility routines 
** 
** 
These routines perform a number of frequently required tasks. They will execute at a greater speed than
similar routines written in VM application code.
*/
</preamble>
    </header>
    <header name="Lcd">
      <preamble>

</preamble>
      <extra_header>app/lcd/lcd_if.h</extra_header>
    </header>
    <header name="Codec_">
      <preamble>
/*! @file codec_.h @brief Control the various aspects of the audio CODEC
*/
</preamble>
      <extra_header>app/audio/audio_if.h</extra_header>
      <extra_header>app/audio/audio_if.h</extra_header>
    </header>
    <header name="Sink">
      <preamble>
/*! @file sink.h   @brief Operations on sinks which take 8-bit data */
</preamble>
      <extra_header>sink_.h</extra_header>
      <extra_header>bdaddr_.h</extra_header>
      <extra_header>app/vm/vm_if.h</extra_header>
      <extra_header>app/stream/stream_if.h</extra_header>
    </header>
    <header name="Otp">
      <preamble>
/*! @file otp.h @brief Provides access to One Time Programmable (OTP) Memory.
** 
** 
Some chips have One Time Programmable (OTP) memory. OTP may 
contain some data which might be needed to read by VM Application.
**
** 
*/
</preamble>
    </header>
    <header name="Psu">
      <preamble>
/*! @file psu.h @brief Traps specifically for power supply control */
</preamble>
      <extra_header>app/psu/psu_if.h</extra_header>
    </header>
    <header name="Charger">
      <preamble>
/*! @file charger.h @brief Configuration of the onchip battery charger present on some BlueCore variants */
</preamble>
      <extra_header>app/charger/charger_if.h</extra_header>
    </header>
    <header name="Partition">
      <preamble>

</preamble>
      <extra_header>app/partition/partition_if.h</extra_header>
      <extra_header>sink_.h</extra_header>
      <extra_header>source_.h</extra_header>
    </header>
    <header name="ImageUpgrade">
      <preamble>
/*! @file imageupgrade.h @brief Image upgrade traps specifically for DFU  */
</preamble>
      <extra_header>app/image_upgrade/image_upgrade_if.h</extra_header>
    </header>
    <header name="I2c">
      <preamble>
/*! @file i2c.h @brief Access to the i2c bus 
** 
** 
BlueCore can support one master i2c interface.
\note
I2C PIOs in BlueCore are configured with PSKEY_I2C_SDA_PIO &amp; PSKEY_I2C_SCL_PIO if PS storage is not I2C EEPROM. The default value of I2C PIOs are defined in device datasheet. The BlueCore acts as the sole bus master. The speed of the bus (standard mode, i.e. up to 100kHz or fast mode, i.e. up to 400kHz) is configured with PSKEY_I2C_CONFIG.
\par 
Only 7bit slave addresses are explicitly supported. However, 10bit addresses can be used by splitting the 10bit address between the slave address (11110xx) and first data byte as defined by the I2C specification.
\par 
Use of the I2C bus requires pull-up resistors connected to the respective PIOs. Details of how to choose such resistors can be found in the I2C-Bus Specification, and recommended values for a typical design are listed in the BlueCore databooks.
*/
</preamble>
    </header>
    <header name="Voice">
      <preamble>
/*! @file voice.h @brief Traps to find out which codecs are supported */
</preamble>
      <extra_header>sink_.h</extra_header>
      <extra_header>app/voice/voice_if.h</extra_header>
    </header>
    <header name="Stream">
      <preamble>
/*! @file stream.h @brief Sources and sinks of 8-bit data 
** 
** 
The Stream API provides functions for efficiently processing streams of eight bit data.
Available streams include RFCOMM, L2CAP, the serial port, USB endpoints and files.
** 
Streams are classified into sources (which can be read) and sinks (which can be written).
*/
/*!
@brief Get the Source for the specified stream-based BCSP#13 channel.
@param channel The channel to fetch the Source for.
*/
#define StreamHostSource(channel) StreamSourceFromSink(StreamHostSink(channel))
/*!
@brief Find the Source associated with the raw UART.
** 
** 
Returns zero if it is unavailable (for example the appropriate
transport has not been configured.)
*/
#define StreamUartSource() StreamSourceFromSink(StreamUartSink())
/*!
@brief Find the Source corresponding to an RFCOMM connection.
*/
#define StreamRfcommSource(conn_id) StreamSourceFromSink(StreamRfcommSink(conn_id))
/*!
@brief Find the Source corresponding to an L2CAP connection
** 
** 
@param cid The connection ID to fetch the Source for.
*/
#define StreamL2capSource(cid) StreamSourceFromSink(StreamL2capSink(cid))
/*!
@brief The Source connected to the port passed on Kalimba.
@param port In the range 0..3 (BC3-MM) or 0..7 (BC5-MM)
*/
#define StreamKalimbaSource(port) StreamSourceFromSink(StreamKalimbaSink(port))
/*!
@brief Return the USB Class Request Source associated with 'interface'. 
@param interface The USB interface (returned by UsbAddInterface) to fetch the Source for.
*/
#define StreamUsbClassSource(interface) StreamSourceFromSink(StreamUsbClassSink(interface))
/*!
@brief Return the USB Request Source associated with the USB transport.
@param end_point The USB endpoint (bEndPointAddress field in EndPointInfo structure) to fetch the Source for.
*/
#define StreamUsbEndPointSource(end_point) StreamSourceFromSink(StreamUsbEndPointSink(end_point))
/*!
@brief Return the USB Vendor Source associated with the USB transport.
*/
#define StreamUsbVendorSource() StreamSourceFromSink(StreamUsbVendorSink())
/*!
@brief Return the FastPipe Source for the pipe requested.
@param id The ID of the pipe needed.
*/
#define StreamFastPipeSource(id) StreamSourceFromSink(StreamFastPipeSink(id))
</preamble>
      <extra_header>bdaddr_.h</extra_header>
      <extra_header>source_.h</extra_header>
      <extra_header>sink_.h</extra_header>
      <extra_header>transform_.h</extra_header>
      <extra_header>app/vm/vm_if.h</extra_header>
      <extra_header>app/file/file_if.h</extra_header>
      <extra_header>app/uart/uart_if.h</extra_header>
      <extra_header>app/stream/stream_if.h</extra_header>
      <extra_header>app/usb/usb_if.h</extra_header>
      <extra_header>app/partition/partition_if.h</extra_header>
      <extra_header>app/voltsense/voltsense_if.h</extra_header>
      <extra_header>operator_.h</extra_header>
      <extra_header>app/audio/audio_if.h</extra_header>
      <extra_header>app/ringtone/ringtone_if.h</extra_header>
    </header>
    <header name="Pio">
      <preamble>
/*! @file pio.h @brief Access BlueCore I/O lines 
** 
** 
BlueCore variants from BlueCore2 onwards have twelve Programmable Input/Output(PIO) 
pins and a further three or four pins (dependant on BlueCore variant) may
be available if they are not being used as AIO pins.
**
Some BlueCore variants from BlueCore5-MM onwards have 16 PIO pins and 
can also control some of the chips UART/PCM lines by mapping them in
as PIO pins 16 and greater. Mapping a UART/PCM line as a PIO line stops 
the line performing its original function, so these lines should only be 
used as PIOs when these interfaces are not required. 
**
Attempts to configure the upper 16 PIOs will be rejected if these
pins have not been mapped first. 
**
Persistent Store keys may be set to hand control of certain PIO pins over 
to the BlueCore firmware. Examples include PSKEY_USB_PIO_WAKEUP, PSKEY_USB_PIO_DETACH,
PSKEY_USB_PIO_PULLUP and PSKEY_USB_PIO_VBUS.
In such configurations the VM should not attempt to use these pins.
**
Various other hardware and software configurations make use of specific PIO pins.
Examples include
- Pio[1:0] Used to control external hardware on Class 1 modules.
- Pio[7:6] Used for I2C.
*/
</preamble>
      <extra_header>app/pio/pio_if.h</extra_header>
    </header>
    <header name="Energy">
      <preamble>
/*! @file energy.h @brief Estimate the energy in a SCO connection */
</preamble>
      <extra_header>sink_.h</extra_header>
    </header>
    <header name="Vm">
      <preamble>
/*! @file vm.h @brief VM access to low-level firmware and hardware */
</preamble>
      <extra_header>app/vm/vm_if.h</extra_header>
      <extra_header>bdaddr_.h</extra_header>
    </header>
    <header name="Infrared">
      <preamble>
/*! @file infrared.h @brief Traps to control the Infrared receiver */
</preamble>
      <extra_header>app/infrared/infrared_if.h</extra_header>
    </header>
    <header name="CapacitiveSensor">
      <preamble>

</preamble>
      <extra_header>app/capacitive_sensor/capacitive_sensor_if.h</extra_header>
    </header>
    <header name="File">
      <preamble>
/*! @file file.h @brief Access to the read-only file-system */
/*! @sa #StreamFileSource, #KalimbaLoad */
</preamble>
      <extra_header>csrtypes.h</extra_header>
      <extra_header>app/file/file_if.h</extra_header>
    </header>
    <header name="Operator">
      <preamble>
/*! @file operator.h @brief Traps that provide access to the VM-DSP Manager interface
**
**
Operator traps provide access to the DSP Manager interface.
**
DSP Manager is a feature of BlueCore that allows the VM, to
control how data sources and sinks are connected to each other.
It introduces a new kind of functional block called
operator, which is used to process data.
**
An operator is an active entity within DSPManager. 
An operator has one or more inputs and one or more outputs.
It need not have the same number of input and output.
It processes the incoming data in some way to generate the
outgoing data - this can be as simple as copying
with a volume change, through mixing two inputs or splitting
an input into two outputs, all the way to things like active
noise cancellation or MP3 encoding or decoding.
**
The behaviour of an operator is called its capability 
and an operator instantiates that capability. Each capability 
has a unique identifier (the capability identifier or capid).
The general meaning of a given capability will never change 
(thus capability 1 is defined as being "mono pass through" 
and will always be this). 
However, new features may be added to a capability from time to
time in an upwards-compatible manner (that is, host software
that is unaware of the new feature will not be affected by it).
When an operator is created it has a unique operator identifier 
or opid that is valid until it is destroyed. Several operators
can instantiate the same capability and all are independent  
from each other. When an operator is destroyed its identifier
becomes invalid. The identifier will eventually be re-used, 
but normally this re-use will be delayed as long as possible.
Operators can be running or stopped. Starting an operator changes
it from stopped to running; stopping an operator
changes it back to stopped again.
An operator cannot be destroyed while running.
**
The VM may be able to configure an operator by sending it 
messages. The operator can also send unsolicited messages to 
the VM to inform it of significant events. The messages that 
are available (in both directions) and their meaning depend 
on the specific capability.
**
**
*/
#define OperatorDestroy(opid) OperatorDestroyMultiple(1, &amp;(opid), NULL)
#define OperatorStart(opid) OperatorStartMultiple(1, &amp;(opid), NULL)
#define OperatorStop(opid) OperatorStopMultiple(1, &amp;(opid), NULL)
#define OperatorReset(opid) OperatorResetMultiple(1, &amp;(opid), NULL)
</preamble>
      <extra_header>operator_.h</extra_header>
      <extra_header>app/file/file_if.h</extra_header>
      <extra_header>app/stream/stream_if.h</extra_header>
      <extra_header>app/operator/operator_if.h</extra_header>
    </header>
    <header name="Message">
      <preamble>
/*!
No delay, perform immediately.
*/
#define D_IMMEDIATE ((Delay) -1)
/*!
Number of seconds to delay for.
*/
#define D_SEC(s)    ((Delay) ((s) * (Delay) 1000))
/*!
Number of minutes to delay for.
*/
#define D_MIN(m)    ((Delay) ((m) * (Delay) 1000 * (Delay) 60))
/*!
Number of hours to delay for.
*/
#define D_HOUR(h)   ((Delay) ((h) * (Delay) 1000 * (Delay) 60) * (Delay) 60)
/*! @file message.h @brief Control message passing
** 
** 
@par Tasks and Message Queues
** 
The messaging functions provide a mechanism for asynchronously posting 
messages between tasks. Messages are posted to MessageQueues which are owned by Tasks.
A Task which owns a non-empty MessageQueue will be run by the scheduler.
** 
@par Creating and Destroying Messages
** 
Messages are dynamically allocated which means that they come out of a very limited
dynamic-block budget. It is therefore important to ensure that messages are consumed as
soon as possible after being produced. Put another way, messages are intended to be a 
signalling mechanism rather than a data-buffering mechanism.
** 
All messages have an identifier property, and some may also contain a payload.
*/ 
/*!
@brief Allocate a message, suitable for sending.
This macro allocates space for a message and initialises a variable
with a pointer to the space.
The pointer should be passed to one of the MessageSend functions, or
passed to free.
@param NAME the name of the variable to be declared and initialised with the pointer
@param TYPE the type to use to determine how much space to allocate
*/
#define MESSAGE_MAKE(NAME,TYPE) \
TYPE * const NAME = PanicUnlessNew(TYPE)
</preamble>
      <extra_header>sink_.h</extra_header>
      <extra_header>message_.h</extra_header>
      <extra_header>app/message/system_message.h</extra_header>
      <extra_header>app/status/status_if.h</extra_header>
      <extra_header>operator_.h</extra_header>
    </header>
    <header name="Font">
      <preamble>
/*! @file font.h @brief Font subsystem support.
** 
** 
Functions to control the font subsystem.
*/
/*!
@brief The index of a font. Should be less than the value returned from FontInit().
*/
typedef uint16 FontId;
/*!
@brief A character in UCS-2.
*/
typedef uint16 ucs2char;
</preamble>
    </header>
    <header name="Native">
      <preamble>
/*! @file native.h @brief Traps specifically for native execution */
</preamble>
    </header>
    <header name="message_">
      <preamble>
/*! @file message_.h @brief Message types */
/*!
Message identifier type.
*/
typedef uint16 MessageId;
/*!
Message delay type.
*/
typedef uint32 Delay;
/*!
Message type.
*/
typedef const void *Message;
/*!
Task type.
*/
typedef struct TaskData *Task;
/*!
TaskData type.
*/
typedef struct TaskData { void (*handler)(Task, MessageId, Message);} TaskData;
</preamble>
    </header>
    <header name="operator_">
      <preamble>
/*! @file operator_.h @brief Operator Id types */
/*!
Operator identifier type.
*/
typedef uint16 Operator;

/*!
Operator Bundle ID type.
*/
typedef uint16 BundleID;
/*!
Invalid Bundle ID.
*/
#define BUNDLE_ID_INVALID ((BundleID)0x0000)
/*!
Operator Data File ID type.
*/
typedef uint16 DataFileID;
/*!
Invalid DataFile ID.
*/
#define DATA_FILE_ID_INVALID ((DataFileID)0x0000)

</preamble>
    </header>
    <header name="sink_">
      <preamble>
/*! @file sink_.h @brief Sink type*/
/*! The Sink type. */
struct __SINK;
typedef struct __SINK *Sink;
</preamble>
    </header>
    <header name="transform_">
      <preamble>
/*! @file transform_.h @brief Transform type*/
/*! The Transform type. */
struct __TRANSFORM;
typedef struct __TRANSFORM *Transform;
</preamble>
    </header>
    <header name="bdaddr_">
      <preamble>
/*! @file bdaddr_.h @brief bdaddr structure*/
/* Yet another variant of Bluetooth address to avoid pulling in bluetooth.h */
/*! Bluetooth address structure. */
typedef struct { uint32 lap; uint8 uap; uint16 nap; } bdaddr;
/*! Typed Bluetooth address structure.*/
typedef struct { uint8   type; bdaddr  addr; } typed_bdaddr;
#define TYPED_BDADDR_PUBLIC    ((uint8)0x00)
#define TYPED_BDADDR_RANDOM    ((uint8)0x01)
#define TYPED_BDADDR_INVALID   ((uint8)0xFF)
/*! ACL type logical transport. */
typedef enum {TRANSPORT_BREDR_ACL, TRANSPORT_BLE_ACL, TRANSPORT_NONE = 0xFF} TRANSPORT_T;
/*! Typed Bluetooth address structure with Transport */
typedef struct { typed_bdaddr taddr; TRANSPORT_T transport; } tp_bdaddr;
</preamble>
    </header>
    <header name="source_">
      <preamble>
/*! @file source_.h @brief Source type*/
/*! The Source type. */
struct __SOURCE;
typedef struct __SOURCE *Source;
</preamble>
    </header>
    <header name="Dormant">
      <preamble>

</preamble>
      <extra_header>app/dormant/dormant_if.h</extra_header>
    </header>
    <header name="csb_">
      <preamble>
/*! @file csb_.h @brief CSB AFH map type */
/*!
AFH data type.
An array of uint16s whose lower octets represent the AFH channels.
Each bit of lower octet represents a AFH channel.
Most significant bit(MSB) of last octet of AfhMap array represents reserved channel
and shall be set to 0.
*/
typedef uint16 AfhMap[10];
</preamble>
    </header>
    <header name="Csb">
      <preamble>
      </preamble>
      <extra_header>bdaddr_.h</extra_header>
      <extra_header>csb_.h</extra_header>
    </header>
    <header name="crypto">
        <preamble>
/*! Encryption operation control flags */
#define CRYPTO_FLAGS_AES_BIG_ENDIAN_COUNTER     1u
        </preamble>
    </header>
    
    <header name="Bitserial_api">
      <preamble>
/*! @file bitseiral_api.h @brief Control of Bitserial. 
** 
**
Bitserial traps.
*/
</preamble>
      <extra_header>app/bitserial/bitserial_if.h</extra_header>
    </header>
    
    <header name="Audio_clock">
      <preamble>
/*! @file audio_clock.h @brief Audio DSP Clock configuration 
** 
*/
      </preamble>
      <extra_header>app/audio/audio_if.h</extra_header>
    </header>

    <header name="Audio_power">
      <preamble>
/*! @file audio_power.h @brief Audio power save mode configuration 
** 
*/
      </preamble>
      <extra_header>app/audio/audio_if.h</extra_header>
    </header>

    <header name="SdMmc">
      <preamble>

</preamble>
      <extra_header>app/sd_mmc/sd_mmc_if.h</extra_header>
    </header>

    </headers>
  <traps version="21.0">
    <trap autogen="false" blocking="false" header="" lifestage="" name="malloc" processor="APP" tmi="0" trapset="CORE">
      <document>
        <description />
        <documentation />
        <comment />
      </document>
      <return type="void *">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sz" type="size_t">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="" lifestage="" name="free" processor="APP" tmi="1" trapset="CORE">
      <document>
        <description />
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mem" type="void *">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="" lifestage="" name="realloc" processor="APP" tmi="2" trapset="CORE">
      <document>
        <description />
        <documentation />
        <comment />
      </document>
      <return type="void *">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mem" type="void *">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sz" type="size_t">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="" lifestage="" name="memmove" processor="APP" tmi="3" trapset="CORE">
      <document>
        <description />
        <documentation />
        <comment />
      </document>
      <return type="void *">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="dst" type="void *">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
        <param name="src" type="const void *">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
        <param name="len" type="size_t">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="" lifestage="UNIMPLEMENTED" name="exit" processor="APP" tmi="4" trapset="CORE">
      <document>
        <description />
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="status" type="int16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="" lifestage="" name="putchar" processor="APP" tmi="5" trapset="CORE">
      <document>
        <description />
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="c" type="uint16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Panic" lifestage="" name="Panic" processor="APP" tmi="6" trapset="CORE">
      <document>
        <description>Panics the application unconditionally.</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Panic" lifestage="" name="PanicNull" processor="APP" tmi="7" trapset="CORE">
      <document>
        <description>Panics the application if the pointer passed is NULL, otherwise returns the pointer.</description>
        <documentation />
        <comment />
      </document>
      <return type="void *">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void *">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Panic" lifestage="" name="PanicNotNull" processor="APP" tmi="8" trapset="CORE">
      <document>
        <description>Panics the application if the pointer passed is not NULL, otherwise returns.</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="const void *">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Panic" lifestage="" name="PanicUnlessMalloc" processor="APP" tmi="9" trapset="CORE">
      <document>
        <description>Allocates sz words and returns a pointer to the memory if successful. If the memory allocation fails, the application is panicked.</description>
        <documentation />
        <comment />
      </document>
      <return type="void *">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sz" type="size_t">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Util" lifestage="" name="UtilCompareByte" processor="APP" tmi="10" trapset="CORE">
      <document>
        <description>Compare two blocks of memory of extent 'size', as uint8's. </description>
        <documentation />
        <comment />
      </document>
      <return type="int">
        <document>
          <description>&gt; 0 if 'a' is lexicographically greater than 'b', &lt; 0 if 'a' is lexicographically less than 'b', 0 if 'a' and 'b' have identical contents.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="a" type="const uint8 *">
          <document>
            <description>First memory block to compare. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="b" type="const uint8 *">
          <document>
            <description>Second memory block to compare. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="size_t">
          <document>
            <description>Size of memory blocks to compare. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Util" lifestage="" name="UtilCompareWord" processor="APP" tmi="10" trapset="CORE">
      <document>
        <description>Compare two blocks of memory of extent 'size', as uint16's. </description>
        <documentation />
        <comment />
      </document>
      <return type="int">
        <document>
          <description>&gt; 0 if 'a' is lexicographically greater than 'b', &lt; 0 if 'a' is lexicographically less than 'b', 0 if 'a' and 'b' have identical contents.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="a" type="const uint16 *">
          <document>
            <description>First memory block to compare. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="b" type="const uint16 *">
          <document>
            <description>Second memory block to compare. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="size_t">
          <document>
            <description>Size of memory blocks to compare. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Util" lifestage="" name="UtilFindByte" processor="APP" tmi="11" trapset="CORE">
      <document>
        <description>Compares two memory blocks.</description>
        <documentation>

  Conceptually we have a table in memory starting at 'data_start', with 'count' entries where each entry is 'size'.
  UtilFindByte searches for 'value', at 'offset' from the start of each entry, using bitmask 'mask'.

  </documentation>
        <comment />
      </document>
      <return type="uint8 *">
        <document>
          <description>VM address of the table entry containing 'value' if found, else 0.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mask" type="uint8">
          <document>
            <description>The bitmask to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint8">
          <document>
            <description>The value to look for. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="data_start" type="const uint8 *">
          <document>
            <description>The memory location of the start of the table. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="offset" type="uint16">
          <document>
            <description>The offset into each table entry that the search will be performed at. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="uint16">
          <document>
            <description>The size of each table entry. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="count" type="uint16">
          <document>
            <description>The number of entries in the table.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Util" lifestage="" name="UtilFindWord" processor="APP" tmi="11" trapset="CORE">
      <document>
        <description>Compares two memory blocks.</description>
        <documentation>

  Conceptually we have a table in memory starting at 'data_start', with 'count' entries where each entry is 'size'.
  UtilFindWord searches for 'value', at 'offset' from the start of each entry, using bitmask 'mask'.

  </documentation>
        <comment />
      </document>
      <return type="uint16 *">
        <document>
          <description>VM address of the table entry containing 'value' if found, else 0.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mask" type="uint16">
          <document>
            <description>The bitmask to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint16">
          <document>
            <description>The value to look for. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="data_start" type="const uint16 *">
          <document>
            <description>The memory location of the start of the table. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="offset" type="uint16">
          <document>
            <description>The offset into each table entry that the search will be performed at. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="uint16">
          <document>
            <description>The size of each table entry. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="count" type="uint16">
          <document>
            <description>The number of entries in the table.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Util" lifestage="" name="UtilGetNumber" processor="APP" tmi="12" trapset="CORE">
      <document>
        <description>Converts a string into a number. </description>
        <documentation>

  Note that the string converted here will not include the character pointed to by 'end'.
  That is, to convert the string "123" you would need to call 'UtilGetNumber(start, start+3, &amp;result)'.

  The number is expected to be an unsigned decimal in the range 0 to 2^16-1.
</documentation>
        <comment />
      </document>
      <return type="uint8 *">
        <document>
          <description>A pointer into the string (the first character after the number) unless no number was found, in which case 0 is returned.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="start" type="const uint8 *">
          <document>
            <description>The start of the string to convert. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="end" type="const uint8 *">
          <document>
            <description>The 'end' of the string to convert. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="result" type="uint16 *">
          <document>
            <description>Will contain the resulting number. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Util" lifestage="" name="UtilHashByte" processor="APP" tmi="13" trapset="CORE">
      <document>
        <description>Compute a uint8 hash value for the memory at 'data', of extent 'size' uint16's, starting with the given 'seed'.</description>
        <documentation />
        <comment />
      </document>
      <return type="uint8">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="data" type="const uint8 *">
          <document>
            <description>The start of the memory block to hash. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="uint16">
          <document>
            <description>The size of the memory block to hash. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="seed" type="uint8">
          <document>
            <description>The seed value to use for the hash.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Util" lifestage="" name="UtilHashWord" processor="APP" tmi="13" trapset="CORE">
      <document>
        <description>Compute a uint16 hash value for the memory at 'data', of extent 'size' uint16's, starting with the given 'seed'.</description>
        <documentation />
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="data" type="const uint16 *">
          <document>
            <description>The start of the memory block to hash. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="uint16">
          <document>
            <description>The size of the memory block to hash. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="seed" type="uint16">
          <document>
            <description>The seed value to use for the hash.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Util" lifestage="" name="UtilHash" processor="APP" tmi="13" trapset="CORE">
      <document>
        <description>Compute a uint16 hash value for the memory at 'data', of extent 'size' uint16's, starting with the given 'seed'.</description>
        <documentation>This function is deprecated. Please use UtilHashWord instead  </documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="data" type="const uint8 *">
          <document>
            <description>The start of the memory block to hash. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="uint16">
          <document>
            <description>The size of the memory block to hash. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="seed" type="uint16">
          <document>
            <description>The seed value to use for the hash.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Util" lifestage="" name="UtilRandom" processor="APP" tmi="14" trapset="CORE">
      <document>
        <description>Returns a 16-bit random number. </description>
        <documentation>

  Uses a numerical approach, but the state is shared with the BlueCore firmware 
  which also makes calls into this function so predictability will be low.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Util" lifestage="" name="UtilSwap" processor="APP" tmi="15" trapset="CORE">
      <document>
        <description>Exchanges the high and low bytes of 'size' words at 'data'.</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="data" type="uint16 *">
          <document>
            <description>The memory location to begin swapping from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="uint16">
          <document>
            <description>The number of swaps to perform.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageSendLater" processor="APP" tmi="16" trapset="CORE">
      <document>
        <description>Send a message to the corresponding task after the given delay in ms. The message will be passed to free after delivery.</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task to deliver the message to. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="id" type="MessageId">
          <document>
            <description>The message type identifier. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="message" type="void *">
          <document>
            <description>The message data (if any). </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="delay" type="uint32">
          <document>
            <description>The delay in ms before the message will be sent.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageCancelFirst" processor="APP" tmi="17" trapset="CORE">
      <document>
        <description>Cancel the first queued message with the given task and message id.</description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if such a message was found and cancelled.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task whose messages will be searched. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="id" type="MessageId">
          <document>
            <description>The message identifier to search for. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageSend" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Send a message to the corresponding task immediately. The message will be passed to free after delivery. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task to deliver the message to. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="id" type="MessageId">
          <document>
            <description>The message type identifier. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="message" type="void *">
          <document>
            <description>The message data (if any).</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Message" lifestage="" name="MessageCancelAll" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Cancel all queued messages with the given task and message id.</description>
        <documentation />
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>A count of how many such messages were cancelled.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task to cancel message for. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="id" type="MessageId">
          <document>
            <description>The message identifier to search for. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageLoop" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>The main scheduler loop; it waits until the next message is due and then sends it to the corresponding task. Never returns.</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="UNIMPLEMENTED" name="MessageWait" processor="APP" tmi="18" trapset="CORE">
      <document>
        <description>Block waiting for the next message. </description>
        <documentation>

  This function will either:
   - Fill out 'm' if a message is ready for delivery.
   - Send the VM to sleep until message delivery time if a message 
     exists but is not ready for delivery.
   - Send the VM to sleep for the range of a uint32 if no message exists.
</documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="m" type="void *">
          <document>
            <description>This will be filled out if a message is ready to be delivered.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageSendConditionallyOnTask" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Send a message to be be delivered when the corresponding Task is zero.</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="t" type="Task">
          <document>
            <description>The task to deliver the message to. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="id" type="MessageId">
          <document>
            <description>The message identifier. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="m" type="Message">
          <document>
            <description>The message data. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="c" type="const Task *">
          <document>
            <description>The task that must be zero for the message to be delivered.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageSendConditionally" processor="APP" tmi="19" trapset="CORE">
      <document>
        <description>Send a message to be be delivered when the corresponding uint16 is zero.</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="t" type="Task">
          <document>
            <description>The task to deliver the message to. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="id" type="MessageId">
          <document>
            <description>The message identifier. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="m" type="Message">
          <document>
            <description>The message data. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="c" type="const uint16 *">
          <document>
            <description>The condition that must be zero for the message to be delivered.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageFree" processor="APP" tmi="20" trapset="CORE">
      <document>
        <description>Frees the memory pointer to by data. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="id" type="MessageId">
          <document>
            <description> The message identifier. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="data" type="Message">
          <document>
            <description>A pointer to the memory to free.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageFlushTask" processor="APP" tmi="21" trapset="CORE">
      <document>
        <description>Cancel all queued messages (independent of id) for the given task. Normally used as part of the process of freeing a task.</description>
        <documentation>

  This function will also stop the task being registered with the firmware
  as the recipient of any system messages.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>The number of messages removed from the queue.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task to flush all message for. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageSystemTask" processor="APP" tmi="22" trapset="CORE">
      <document>
        <description>Register a task to handle system-wide messages.</description>
        <documentation>

  

  Currently the system-wide messages are:
  - #MESSAGE_USB_ENUMERATED 
  - #MESSAGE_USB_SUSPENDED
  - #MESSAGE_USB_DECONFIGURED
  - #MESSAGE_USB_ALT_INTERFACE
  - #MESSAGE_USB_ATTACHED
  - #MESSAGE_USB_DETACHED
  - #MESSAGE_PSFL_FAULT
  - #MESSAGE_TX_POWER_CHANGE_EVENT
  - #MESSAGE_SD_MMC_INSERTED
  - #MESSAGE_SD_MMC_REMOVED

  Other such messages may be added.
</documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The old task (or zero).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task which will receive the messages.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Ps" lifestage="" name="PsStore" processor="APP" tmi="23" trapset="CORE">
      <document>
        <description>Copy the specified memory buffer to persistent store. </description>
        <documentation>

  A Persistent store user key can be deleted by calling the PsStore function
  with \e key to be deleted and \e words argument being zero.

  \note
  The key is interpreted as an index into PSKEY_USR0 ... PSKEY_USR49,
  PSKEY_DSP0 ... PSKEY_DSP49, PSKEY_CONNLIB0 ... PSKEY_CONNLIB49,
  PSKEY_USR50 ... PSKEY_USR99,   PSKEY_CUSTOMER0 ... PSKEY_CUSTOMER99
  No other keys can be written from an application.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>The number of words actually written.
          Zero if either 'words' is zero or the store failed.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="uint16">
          <document>
            <description>The persistent store key to copy data to. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="buff" type="const void *">
          <document>
            <description>The memory buffer to copy data from,
            must be word aligned. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="words" type="uint16">
          <document>
            <description>The number of uint16 words to copy.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Ps" lifestage="" name="PsRetrieve" processor="APP" tmi="24" trapset="CORE">
      <document>
        <description>Copy to specified memory buffer from persistent store. </description>
        <documentation>

  \note
  The key is interpreted as an index into PSKEY_USR0 ... PSKEY_USR49,
  PSKEY_DSP0 ... PSKEY_DSP49, PSKEY_CONNLIB0 ... PSKEY_CONNLIB49,
  PSKEY_USR50 ... PSKEY_USR99,   PSKEY_CUSTOMER0 ... PSKEY_CUSTOMER99..
  No other keys can be written from an application.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>If \e buff is NULL and \e words is zero,
          returns the minimum length in words of the buffer necessary to hold
          the contents of \e key. Otherwise, returns the number of words
          actually read, or zero if the key does not exist or is longer
          than \e words.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="uint16">
          <document>
            <description>The persistent store key to copy data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="buff" type="void *">
          <document>
            <description>The memory buffer to copy data to,
            must be word aligned.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="words" type="uint16">
          <document>
            <description>The number of uint16 words to copy. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Ps" lifestage="" name="PsFlood" processor="APP" tmi="25" trapset="CORE">
      <document>
        <description>Flood fill the store to force a defragment</description>
        <documentation>

  Subsequent attempts to write to persistent store will fail until then.
</documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Ps" lifestage="" name="PsFreeCount" processor="APP" tmi="26" trapset="CORE">
      <document>
        <description>Return how many keys of this size in words we could write. </description>
        <documentation />
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="words" type="uint16">
          <document>
            <description>The key size in words to use.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Ps" lifestage="" name="PsFullRetrieve" processor="APP" tmi="27" trapset="CORE">
      <document>
        <description>Read any persistent store key which could be accessed from off-chip using BCCMD. </description>
        <documentation>

  Note that this uses full CSR PS key numbering, not the
  0..149 space used by the other Ps functions which are restricted to
  accessing the VM, DSP and connection library specific keys.

  If a key is present (has a value) in any store (e.g., ROM, factory),
  stores layered on top of that (e.g., EEPROM, RAM) cannot cause the key
  to be absent. Therefore, making some behaviour conditional on the absence
  of a key is something to be avoided if at all possible. If the key has a
  default value in ROM, your behaviour will be impossible to access.

  Note that you can override any value with a zero-length value,
  so testing for a zero-length value does not have this problem.
  Usually this means you can obey this rule by allowing a zero length key
  to behave the same as an absent key.

  The correct way to read a key which may be a zero length pskey may 
  will look like below
      uint16 pio = 0xffff;
      if (PsFullRetrieve(PSKEY_*., &amp;pio, sizeof(pio)) &amp;&amp; pio &lt;= 15)
  The initialisation of pio gives the value if the key isn't present,
  PsFullRetrieve returns FALSE if the key doesn't exist.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>If \e buff is NULL and \e words is zero,
          returns the minimum length in words of the buffer necessary
          to hold the contents of \e key. Otherwise, returns the number
          of words actually read, or zero if the key does not exist or
          is longer than \e words.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="uint16">
          <document>
            <description>The persistent store key to copy data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="buff" type="void *">
          <document>
            <description>The memory buffer to copy data to,
            must be word aligned. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="words" type="uint16">
          <document>
            <description>The number of uint16 words to copy.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Boot" lifestage="" name="BootGetMode" processor="CSR" tmi="28" trapset="CORE">
      <document>
        <description>Read the current boot mode.</description>
        <documentation />
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Boot" lifestage="" name="BootSetMode" processor="CSR" tmi="29" trapset="CORE">
      <document>
        <description>Set the mode and force a reboot (warm reset) of the chip using the boot image bank. </description>
        <documentation>

</documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="newBootmode" type="uint16">
          <document>
            <description>The new boot mode to use.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Boot" lifestage="UNIMPLEMENTED" name="BootGetPreservedWord" processor="CSR" tmi="30" trapset="CORE">
      <document>
        <description>Read the (single) word preserved between boots.</description>
        <documentation />
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Boot" lifestage="UNIMPLEMENTED" name="BootSetPreservedWord" processor="CSR" tmi="31" trapset="CORE">
      <document>
        <description>Write the (single) word preserved between boots. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="state" type="uint16">
          <document>
            <description>The word of state to preserve.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Vm" lifestage="UNIMPLEMENTED" name="VmPutChar" processor="APP" tmi="32" trapset="CORE">
      <document>
        <description>Output a character on the given channel. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="channel" type="uint16">
          <document>
            <description>The character to output. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="c" type="uint16">
          <document>
            <description>The channel to output to.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Vm" lifestage="" name="VmGetAvailableAllocations" processor="APP" tmi="33" trapset="CORE">
      <document>
        <description>Counts the maximum number of additional memory blocks which can be allocated </description>
        <documentation />
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>The number of free slots in the VM memory map. Note that this does not correspond to physical memory; it's possible for malloc() and similar functions to fail even when this function returns non-zero; the value returned by this function is only an upper bound on the number of possible allocations. See CS-110364-ANP "VM Memory Mapping and Memory Usage" for more detail.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Vm" lifestage="" name="VmGetClock" processor="APP" tmi="34" trapset="CORE">
      <document>
        <description>Read the current value of a 32-bit millisecond timer.</description>
        <documentation>

  Don't poll this; using MessageSendLater is much more efficient.
</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Vm" lifestage="" name="VmDeepSleepEnable" processor="CSR" tmi="35" trapset="CORE">
      <document>
        <description>Enables or disables deep sleep. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>The previous status.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="en" type="bool">
          <document>
             <description>FALSE will prevent the chip going into deep sleep. TRUE will permit the chip to go into deep sleep. It can still be blocked from doing so by other firmware components. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmTransmitEnable" processor="CSR" tmi="36" trapset="CORE">
      <document>
        <description>Request that the radio transmitter be enabled or disabled.</description>
        <documentation>

  

  Equivalent to using ENABLE_TX and DISABLE_TX over BCCMD from
  off-chip.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the request was satisfied, FALSE if it was not possible.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="enabled" type="bool">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmTransmitPowerSetDefault" processor="CSR" tmi="37" trapset="CORE">
      <document>
        <description>Allows the application to override the default specified by PSKEY_LC_DEFAULT_TX_POWER. </description>
        <documentation>

   The default transmit power is used for paging, inquiry, and their responses,
   and as the initial power for new acl links. The value passed is rounded down to
   the next available value when set, so the value returned by a call to 
   VmTransmitPowerGetDefault may be less than that previously passed to 
   VmTransmitPowerSetDefault.

   </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="power" type="int16">
          <document>
            <description>int16 The new default power to use in dBm.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmTransmitPowerSetMaximum" processor="CSR" tmi="38" trapset="CORE">
      <document>
        <description>Allows the application to override the maximum specified by PSKEY_LC_MAX_TX_POWER. </description>
        <documentation>

   The maximum transmit power is only referenced when increasing the transmit power,
   so if the transmit power on a link is already above this level the new value
   will not take effect until an attempt is made to increase the power.

   The value passed is rounded down to the next available value when set, so the value 
   returned by a call to VmTransmitPowerGetMaximum may be less than that previously passed 
   to VmTransmitPowerSetMaximum.

   </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="power" type="int16">
          <document>
            <description>The new maximum power to use in dBm.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmTransmitPowerGetDefault" processor="CSR" tmi="39" trapset="CORE">
      <document>
        <description>Returns the current default power setting.</description>
        <documentation />
        <comment />
      </document>
      <return type="int16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmTransmitPowerGetMaximum" processor="CSR" tmi="40" trapset="CORE">
      <document>
        <description>Returns the current maximum power setting.</description>
        <documentation />
        <comment />
      </document>
      <return type="int16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmGetTemperature" processor="APP" tmi="41" trapset="CORE">
      <document>
        <description>Reads the internal temperature of BlueCore</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="int16">
        <document>
          <description>Approximate temperature in degrees Celsius, or INVALID_TEMPERATURE if it could not be read.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Vm" lifestage="UNIMPLEMENTED" name="VmSetPcmClock" processor="CSR" tmi="42" trapset="CORE">
      <document>
        <description>Enables the VM to set the PCM_CLK frequency when using the 4 mHz internal clock. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the change was accepted, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="frequency" type="vm_pcm_clock_setting">
          <document>
            <description>The frequency PCM_CLK will output at as a vm_pcm_clock_setting type. Valid values are PCM_CLK_OFF, PCM_CLK_128, PCM_CLK_256 and PCM_CLK_512 kHz. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Vm" lifestage="UNIMPLEMENTED" name="VmGetPcmClock" processor="CSR" tmi="43" trapset="CORE">
      <document>
        <description>Enables the VM to check the current PCM_CLK frequency, when it is being generated from the 4MHz internal clock.</description>
        <documentation>

    </documentation>
        <comment />
      </document>
      <return type="vm_pcm_clock_setting">
        <document>
          <description>A vm_pcm_clock_setting type indicating the current PCM clock frequency.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Vm" lifestage="UNIMPLEMENTED" name="VmAmuxClockEnable" processor="CSR" tmi="0" trapset="AMUXCLOCK">
      <document>
        <description>Enables the amux clock output on AIO0.</description>
        <documentation>

    Note that this is only available on BC4 parts, excluding BC4-external.

    Note that PSKEY_AMUX_CLOCK must be have been set correctly, and
    PSKEY_AMUX_AIO0 must be set to ANA_AMUX_A_SEL_DIG_OUT_CLK_AMUX.
</documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="enabled" type="bool">
          <document>
            <description>Whether the clock is enabled.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Vm" lifestage="" name="VmReadVrefConstant" processor="APP" tmi="44" trapset="CORE">
      <document>
        <description>Get the absolute value for Vref on this version of BlueCore</description>
        <documentation>

    This is a constant value for a given version of BlueCore. See adc.h for
    the intended use of this function.

    In ADK6 firmware, AdcReadRequest() will return reading for Vref (#adcsel_vref_hq_buff)
    without scaling it to a nominal voltage. This function
    provides the information that the battery library needs to adjust its
    readings appropriately.
    
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>The value of Vref (in mV) for the version of BlueCore the application is running on.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Adc" lifestage="DEAD" name="AdcRequest" processor="APP" tmi="45" trapset="CORE">
      <document>
        <description>Send a request to the ADC to make a reading from adc_source. When the reading is made, a #MESSAGE_ADC_RESULT message will be sent to the task passed. See adc.h for how to interpret the result.</description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if request is accepted, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task which will receive the ADC result message. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="adc_source" type="vm_adc_source_type">
          <document>
            <description>The source (#vm_adc_source_type) to take readings from. </description>
            <documentation />
            <comment />
          </document>
        </param>        
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Adc" lifestage="" name="AdcReadRequest" processor="APP" tmi="45" trapset="CORE">
      <document>
        <description>Send a request to the ADC to make a reading from adc_source. When the reading is made, a #MESSAGE_ADC_RESULT message will be sent to the task passed. See adc.h for how to interpret the result.</description>
        <documentation>
    Note that this trap replaces trap AdcRequest(). This is because it has to support queuing multiple request
calls with different task, ADC source, extra flag and delay parameters.
    So far the extra_flag parameter only supports enabling/disabling the 10uA internal current source from HQ_REF
during the reading.
    Adc readings for various analogue sources may require a delay to let external circuitry settle and not impact
the reading (for example external capacitors need time to charge when the internal current source is enabled).
    This delay needs to be provided by customer where they see appropriate.
    PIO setup is not handled by this trap but can be done at any point. XIO pads need to be configured as analogue pins.
This is done by using PioSetMapPins32Bank to put the PIO under HW control and then PioSetFunction to set the function to
XIO_ANALOGUE. LED pads are handled internally by the Curator so we just need to make sure those pins are not used by
something else. This is done by using PioSetMapPins32Bank to put the PIO under HW control and then PioSetFunction to set
the function to OTHER.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if request is accepted, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task which will receive the ADC result message. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="adc_source" type="vm_adc_source_type">
          <document>
            <description>The source (#vm_adc_source_type) to take readings from. </description>
            <documentation />
            <comment />
          </document>
        </param>        
        <param name="extra_flag" type="vm_adc_extra_flag">
          <document>
            <description>The flags (#vm_adc_extra_flag) to be used for readings</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="delay" type="uint16">
          <document>
            <description>Delay in millisconds to use for internal current source</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Vm" lifestage="" name="VmGetTimerTime" processor="APP" tmi="46" trapset="CORE">
      <document>
        <description>Read the current value of the 32-bit micro-second timer. The 32-bit value returned will wrap from 0xFFFFFFFF to 0x00000000 every 2**32 / 1e6 / 60 = 71.6 minutes.</description>
        <documentation>

  Don't poll this; using MessageSendLater is much more efficient.
</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>The current value of the 32-bit microsecond timer.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Ps" lifestage="" name="PsUpdateAudioKey" processor="APP" tmi="47" trapset="CORE">
      <document>
        <description>Copy the specified memory buffer to audio persistent store. </description>
        <documentation>

  A Persistent store audio key can be updated by the application by invoking this trap.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>The number of words actually written.
          Zero if either 'words' is zero or the update failed.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="uint32">
          <document>
            <description>The persistent store audio key to copy data to. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="buffer" type="const uint16 *">
          <document>
            <description>The memory buffer to copy data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="words" type="uint16">
          <document>
            <description>Number of word of key data to write.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="offset" type="uint16">
          <document>
            <description>Number of words from the start of the key to write data.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key_length" type="uint16">
          <document>
            <description>Length of the key data in uint16 words.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Ps" lifestage="" name="PsReadAudioKey" processor="APP" tmi="48" trapset="CORE">
      <document>
        <description>Copy to specified memory buffer from audio persistent store. </description>
        <documentation>
 
  A Persistent store audio key can be read by the application by invoking this trap.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>Returns 0 if input \e buffer is NULL.
          Otherwise, returns the number of words actually read, or zero if the key does not exist.
          </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="uint32">
          <document>
            <description>The persistent store audio key to copy data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="buffer" type="uint16 *">
          <document>
            <description>The memory buffer to copy data to. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="words" type="uint16">
          <document>
            <description>The number of words to copy. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="offset" type="uint16">
          <document>
            <description>Number of words from the start of the key to read data.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key_length_addr" type="uint16 *">
          <document>
            <description>Pointer to return the length of the key in uint16 words.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Pio" lifestage="DEAD" name="PioSetAuxDac" processor="CSR" tmi="0" trapset="AUXDAC">
      <document>
        <description>Enables or disables the auxiliary DAC on BlueCore, setting the output level to the requested value. </description>
        <documentation>

   

   Note that the auxiliary DAC level drops to 0V when BlueCore enters
   deep sleep for power-saving.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the request succeeded; FALSE if it could not be honoured because the DAC is in use by other parts of the firmware.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="enabled" type="bool">
          <document>
            <description>TRUE or FALSE. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="level" type="uint8">
          <document>
            <description>The output level to use.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessagePioTask" processor="APP" tmi="46" trapset="CORE">
      <document>
        <description>Register a task to handle PIO changes.</description>
        <documentation />
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The old task (or zero).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>This task will receive #MESSAGE_PIO_CHANGED messages when the pins configured by PioDebounce32() change. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioDebounce32" processor="CSR" tmi="47" trapset="CORE">
      <document>
        <description>Configure PIO monitoring.</description>
        <documentation>

  This function configures a simple debounce engine for PIO input
  pins. It can detect transitions on PIOs and return stabilised
  readings for them, filtering out glitches.

  When the engine detects a change in state of one or more of the
  monitored pins, it repeatedly reads the pin state. If the state of
  all the monitored pins remains unchanged for \e count successive
  samples, it is considered stable and a #MESSAGE_PIO_CHANGED message
  is sent to the task registered with MessagePioTask().

  \note
  It is not possible to configure different debounce settings for
  different pins or groups of pins, or to debounce pins independently
  of each other.

  Examples:

  To enable events on PIO2 and PIO3, with 4 reads 2ms apart (6ms
  total):

  \code
  PioDebounce32(1u&lt;&lt;2 | 1u&lt;&lt;3, 4, 2);
  \endcode

  To enable events on any transition on PIO5 with no debouncing:

  \code
  PioDebounce32(1u&lt;&lt;5, 1, 0);
  \endcode
</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then monitoring could not be set up for that PIO; no action will have been taken on any PIOs (any previously set up monitoring will remain in force). The most likely reasons for a non-zero return are attempting to debounce nonexistent PIOs, or attempting to debounce unmapped PIOs. See the PioSetMapPins32() documentation for information on which PIOs can be mapped.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mask" type="uint32">
          <document>
            <description>Bitmask indicating which pins to monitor. Setting this to zero disables PIO monitoring. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="count" type="uint16">
          <document>
            <description>How many times the monitored pins' state must be observed to be consistent before it is considered stable. Zero and one have special significance. If \e count is 1, then no debouncing is performed - any perceived change of the pins will raise the event. If \e count is 0, any transition raises the event, even if no change in pin state can be detected; in this case, the "state" members of #MessagePioChanged may show no change in state. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="period" type="uint16">
          <document>
            <description>The delay in milliseconds between successive reads of the pins. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioDebounce32Bank" processor="CSR" tmi="48" trapset="CORE">
      <document>
        <description>Configure PIO monitoring.</description>
        <documentation>

  This function configures a simple debounce engine for PIO input
  pins. It can detect transitions on PIOs and return stabilised
  readings for them, filtering out glitches.

  When the engine detects a change in state of one or more of the
  monitored pins, it repeatedly reads the pin state. If the state of
  all the monitored pins remains unchanged for \e count successive
  samples, it is considered stable and a #MESSAGE_PIO_CHANGED message
  is sent to the task registered with MessagePioTask().

  \note
  It is not possible to configure different debounce settings for
  different pins or groups of pins, or to debounce pins independently
  of each other.

  Examples:

  To enable events on PIO2 and PIO3, with 4 reads 2ms apart (6ms
  total):

  \code
  PioDebounce32(1u&lt;&lt;2 | 1u&lt;&lt;3, 4, 2);
  \endcode

  To enable events on any transition on PIO5 with no debouncing:

  \code
  PioDebounce32(1u&lt;&lt;5, 1, 0);
  \endcode
</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then monitoring could not be set up for that PIO; no action will have been taken on any PIOs (any previously set up monitoring will remain in force). The most likely reasons for a non-zero return are attempting to debounce nonexistent PIOs, or attempting to debounce unmapped PIOs. See the PioSetMapPins32() documentation for information on which PIOs can be mapped.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="mask" type="uint32">
          <document>
            <description>Bitmask indicating which pins to monitor. Setting this to zero disables PIO monitoring. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="count" type="uint16">
          <document>
            <description>How many times the monitored pins' state must be observed to be consistent before it is considered stable. Zero and one have special significance. If \e count is 1, then no debouncing is performed - any perceived change of the pins will raise the event. If \e count is 0, any transition raises the event, even if no change in pin state can be detected; in this case, the "state" members of #MessagePioChanged may show no change in state. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="period" type="uint16">
          <document>
            <description>The delay in milliseconds between successive reads of the pins. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGet32" processor="CSR" tmi="49" trapset="CORE">
      <document>
        <description>Returns the contents of the PIO data input register. For PIOs set as outputs, this function will return the value last written using PioSet32(). </description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGet32Bank" processor="CSR" tmi="50" trapset="CORE">
      <document>
        <description>Returns the contents of one of the PIO data input registers. For PIOs set as outputs, this function will return the value last written using PioSet32Bank(). </description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioSet32" processor="CSR" tmi="51" trapset="CORE">
      <document>
        <description>Modifies the contents of the PIO data output register. PIO pins must be set to outputs via PioSetDir32() before they can be driven high or low through this trap. This trap also sets pull direction for PIOs used as inputs.</description>
        <documentation>

  

  Note that all PIOs must be mapped in before they can be used.
  See the PioSetMapPins32() documentation for information on valid PIO directions
  and PIO mapping.  

  BlueCore has internal resistors which can be configured to either pull-up or 
  pull-down the pins used for input. This is controlled by the value 
  written to the output register using PioSet32().
  The resistors pull-down if the value is zero, and pull-up otherwise, so the 
  following fragment sets pins 1 and 2 to inputs with pin 1 configured to 
  pull-up and pin 2 configured to pull-down.

  \code

  PioSet32(2|4, 2);
  PioSetDir32(2|4, 0);

  \endcode
</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then that PIO could not be driven to the level specified; note that no action will have been taken on any PIOs.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mask" type="uint32">
          <document>
            <description>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="bits" type="uint32">
          <document>
            <description>Each bit in the "bits" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being driven high. Bits set to 0 in this value will result in that PIO line being driven low.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioSet32Bank" processor="CSR" tmi="52" trapset="CORE">
      <document>
        <description>Modifies the contents of the PIO data output register. PIO pins must be set to outputs via PioSetDir32Bank() before they can be driven high or low through this trap. This trap also sets pull direction for PIOs used as inputs.</description>
        <documentation>

  

  Note that all PIOs must be mapped in before they can be used.
  See the PioSetMapPins32Bank() documentation for information on valid PIO directions
  and PIO mapping.  

  BlueCore has internal resistors which can be configured to either pull-up or 
  pull-down the pins used for input. This is controlled by the value 
  written to the output register using PioSet32Bank().
  The resistors pull-down if the value is zero, and pull-up otherwise, so the 
  following fragment sets pins 1 and 2 to inputs with pin 1 configured to 
  pull-up and pin 2 configured to pull-down.

  \code

  PioSet32Bank(0, 2|4, 2);
  PioSetDir32Bank(0, 2|4, 0);

  \endcode
</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then that PIO could not be driven to the level specified; note that no action will have been taken on any PIOs.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="mask" type="uint32">
          <document>
            <description>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="bits" type="uint32">
          <document>
            <description>Each bit in the "bits" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being driven high. Bits set to 0 in this value will result in that PIO line being driven low.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGetDir32" processor="CSR" tmi="53" trapset="CORE">
      <document>
        <description>Read whether PIOs are set as inputs or outputs. </description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>Each bit in the return value corresponds to a PIO line. Bits set to 1 mean that PIO line is configured as an output. Bits set to 0 mean it is configured as an input.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGetDir32Bank" processor="CSR" tmi="54" trapset="CORE">
      <document>
        <description>Read whether PIOs are set as inputs or outputs. </description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>Each bit in the return value corresponds to a PIO line. Bits set to 1 mean that PIO line is configured as an output. Bits set to 0 mean it is configured as an input.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioSetDir32" processor="CSR" tmi="55" trapset="CORE">
      <document>
        <description>Set PIOs as inputs or outputs.</description>
        <documentation>

  

  Note that all PIOs must be mapped in before they can be used.
  See the PioSetMapPins32() documentation for information on valid PIO directions
  and PIO mapping.
</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then that PIO could not be set to the direction specified; note that no action will have been taken on any PIOs.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mask" type="uint32">
          <document>
            <description>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="dir" type="uint32">
          <document>
            <description>Each bit in the "dir" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being configured as an output. Bits set to 0 in this value will result in that PIO line being configured as an input.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioSetDir32Bank" processor="CSR" tmi="56" trapset="CORE">
      <document>
        <description>Set PIOs as inputs or outputs.</description>
        <documentation>

  

  Note that all PIOs must be mapped in before they can be used.
  See the PioSetMapPins32Bank() documentation for information on valid PIO directions
  and PIO mapping.
</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then that PIO could not be set to the direction specified; note that no action will have been taken on any PIOs.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="mask" type="uint32">
          <document>
            <description>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="dir" type="uint32">
          <document>
            <description>Each bit in the "dir" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being configured as an output. Bits set to 0 in this value will result in that PIO line being configured as an input.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGetStrongBias32" processor="CSR" tmi="57" trapset="CORE">
      <document>
        <description>Read whether PIOs are set to use strong or weak pull.</description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGetStrongBias32Bank" processor="CSR" tmi="58" trapset="CORE">
      <document>
        <description>Read whether PIOs are set to use strong or weak pull.</description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioSetStrongBias32" processor="CSR" tmi="59" trapset="CORE">
      <document>
        <description>Set PIOs to use strong or weak pull when used as inputs. </description>
        <documentation>

  

  \code

   PioSetDir32((1&lt;&lt;4)|(1&lt;&lt;5), 0);
   PioSet32((1&lt;&lt;4)|(1&lt;&lt;5), (1&lt;&lt;4));
   PioSetStrongBias32((1&lt;&lt;4)|(1&lt;&lt;5), (1&lt;&lt;5));

  \endcode

</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then that PIO could not be set to use strong bias; note that no action will have been taken on any PIOs. BlueCore includes weak internal pull-ups or pull-downs on pins which are being used as inputs (see PioSet32()). This function allows the pull-up or pull-down to be made stronger on a per-pin basis. So to set pin 4 and 5 as inputs, 4 pulled up weakly, 5 pulled down strongly</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mask" type="uint32">
          <document>
            <description>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="bits" type="uint32">
          <document>
            <description>Each bit in the "bits" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being configured as having strong bias. Bits set to 0 in this value will result in that PIO line being configured as not having strong bias. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioSetStrongBias32Bank" processor="CSR" tmi="60" trapset="CORE">
      <document>
        <description>Set PIOs to use strong or weak pull when used as inputs. </description>
        <documentation>

  

  \code

   PioSetDir32((1&lt;&lt;4)|(1&lt;&lt;5), 0);
   PioSet32((1&lt;&lt;4)|(1&lt;&lt;5), (1&lt;&lt;4));
   PioSetStrongBias32((1&lt;&lt;4)|(1&lt;&lt;5), (1&lt;&lt;5));

  \endcode

</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then that PIO could not be set to use strong bias; note that no action will have been taken on any PIOs. BlueCore includes weak internal pull-ups or pull-downs on pins which are being used as inputs (see PioSet32()). This function allows the pull-up or pull-down to be made stronger on a per-pin basis. So to set pin 4 and 5 as inputs, 4 pulled up weakly, 5 pulled down strongly</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="mask" type="uint32">
          <document>
            <description>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="bits" type="uint32">
          <document>
            <description>Each bit in the "bits" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being configured as having strong bias. Bits set to 0 in this value will result in that PIO line being configured as not having strong bias. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGetMapPins32" processor="CSR" tmi="61" trapset="CORE">
      <document>
        <description>Returns a 32 bit value showing which PIO lines have been mapped to chip pins (see documentation for PioSetMapPins32() for more detail).</description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGetMapPins32Bank" processor="CSR" tmi="62" trapset="CORE">
      <document>
        <description>Returns a 32 bit value showing which PIO lines have been mapped to chip pins (see documentation for PioSetMapPins32() for more detail).</description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioSetMapPins32" processor="CSR" tmi="63" trapset="CORE">
      <document>
        <description>Maps PIOs as software or hardware controlled.</description>
        <documentation>

  Before using a PIO as a software controlled digital IO a call to this
  function is required. Not mapping the PIO may cause other functions in the
  PIO trap API to return errors and not produce the required behaviour.

  To put a PIO under HW control the app needs to call this function first and
  then PioSetFunction to select the HW functionality needed.

  Please note that there is no default state, all PIOs should be considered
  unmapped and unusable until they are configured by a call to this function.

</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then that PIO could not be mapped or unmapped; note that no action will have been taken on any PIOs.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mask" type="uint32">
          <document>
            <description>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="bits" type="uint32">
          <document>
            <description>Each bit corresponds to a PIO line. A bit set to 1 will cause a PIO to be behave as a software controlled pin. A bit set to 0 will result in the pio being marked as controlled by a hardware peripheral.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioSetMapPins32Bank" processor="CSR" tmi="64" trapset="CORE">
      <document>
        <description>Maps PIOs as software or hardware controlled.</description>
        <documentation>

  Before using a PIO as a software controlled digital IO a call to this
  function is required. Not mapping the PIO may cause other functions in the
  PIO trap API to return errors and not produce the required behaviour.

  To put a PIO under HW control the app needs to call this function first and
  then PioSetFunction to select the HW functionality needed.

  Please note that there is no default state, all PIOs should be considered
  unmapped and unusable until they are configured by a call to this function.

</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then that PIO could not be mapped or unmapped; note that no action will have been taken on any PIOs.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="mask" type="uint32">
          <document>
            <description>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="bits" type="uint32">
          <document>
            <description>Each bit corresponds to a PIO line. A bit set to 1 will cause a PIO to be behave as a software controlled pin. A bit set to 0 will result in the pio being marked as controlled by a hardware peripheral.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Pio" lifestage="DEAD" name="PioSetRts" processor="CSR" tmi="0" trapset="RTSCTS">
      <document>
        <description>Controls the settings of the RTS line</description>
        <documentation>

   

   When the host transport is set to none, so that the UART is not
   being used, the application has full control of the RTS line.

   When the user transport is in use, this function can be used to
   assert flow control when the firmware would not automatically do
   so. However, the firmware may also force RTS low to assert incoming
   flow control even if PioSetRts(TRUE) has been called.

   With other transports (including USB), it is not possible to
   control the RTS line, and FALSE will be returned.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, and FALSE if the operation could not be performed. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="level" type="bool">
          <document>
            <description>Set (TRUE) or Clear (FALSE).</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Pio" lifestage="DEAD" name="PioGetCts" processor="CSR" tmi="1" trapset="RTSCTS">
      <document>
        <description>Lets the VM check the status of the Clear To Send UART pin</description>
        <documentation>

    </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if host transport is set to none and CTS input signal within the UART is set to active, else returns FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Native" lifestage="UNIMPLEMENTED" name="NativePauseForDebug" processor="CSR" tmi="0" trapset="NATIVE">
      <document>
        <description>Pause the VM ready to start native debugging (if appropriate)</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageStreamTaskFromSink" processor="CSR" tmi="0" trapset="STREAM">
      <document>
        <description>Associate a Task with a Sink.</description>
        <documentation>

  

  @note
  # Task cannot be registered for operator sink which is not
     connected to a source.
  # Task cannot be registered for operator sink which is connected
     to an operator source.
  # Task can be registered on all streams irrespective of whether
     they are connected or not.
</documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The previous task for this sink, if any, or zero(0) otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The sink to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="task" type="Task">
          <document>
            <description>The task to associate.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageStreamGetTaskFromSink" processor="CSR" tmi="1" trapset="STREAM">
      <document>
        <description>Get the Task currently associated with a sink. </description>
        <documentation />
        <comment />
      </document>
      <return type="Task">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The sink to use.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" fast="true" header="Sink" lifestage="" name="SinkSlack" processor="CSR" tmi="2" trapset="STREAM">
      <document>
        <description>Report how many bytes can successfully be claimed in the corresponding sink.</description>
        <documentation>

  @note 
  Operator sink stream mapping parameters must be configured by using 
  SinkMapInit before calling this function. If the sink is an operator
  sink stream with uninitialized mapping parameters, then it always returns
  zero(0), irrespective of whether the operator sink stream is valid or not.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>Zero if the sink is not valid.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to check. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" fast="true" header="Sink" lifestage="" name="SinkClaim" processor="CSR" tmi="3" trapset="STREAM">
      <document>
        <description>Attempt to claim the indicated number of extra bytes in a sink.</description>
        <documentation>

  Claims will certainly fail if the sink is invalid, 
  or if SinkSlack indicates that the space is unavailable.

  SinkClaim(sink, 0) will return the number of octets that are currently
  claimed in the sink.

  @note 
  Operator sink stream mapping parameters must be configured by using 
  SinkMapInit before calling this function. If the sink is an operator
  sink stream with uninitialized mapping parameters, then it always returns
  0xFFFF, irrespective of whether the operator sink stream is valid or not.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>The offset, from the address returned by SinkMap, of the newly claimed region if the claim was successful, 0xFFFF otherwise.
          This value is also the number of octets claimed at the point SinkClaim is called.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The sink to claim. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="extra" type="uint16">
          <document>
            <description>The number of bytes to attempt to claim. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" fast="true" header="Sink" lifestage="" name="SinkMap" processor="CSR" tmi="4" trapset="STREAM">
      <document>
        <description>Map the sink into the address map, returning a pointer to the first claimed byte in the sink. </description>
        <documentation>

  Only the total number of claimed bytes (as
  returned by SinkClaim(sink,0)) are accessible. At most one sink can be
  mapped in at any time; pointers previously obtained from SinkMap become
  invalid when another call to SinkMap is made.

  @note
  An implementation detail first introduced in ADK6 means that the return value
  of this function for a given sink is no longer a constant. Therefore, any code
  that relies on the value returned by SinkMap to remain the same between
  SinkFlush calls may fail.

  @note
  Operator sink stream mapping parameters must be configured by using
  SinkMapInit before calling this function. If the sink is an operator
  sink stream with uninitialized mapping parameters, then it always returns
  zero(0), irrespective of whether the operator sink stream is valid or not.

</documentation>
        <comment />
      </document>
      <return type="uint8 *">
        <document>
          <description>zero if the sink is invalid.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The sink to map into the address map. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" fast="true" header="Sink" lifestage="" name="SinkFlush" processor="CSR" tmi="5" trapset="STREAM">
      <document>
        <description>Flush the indicated number of bytes out of the sink. </description>
        <documentation>

  The specified bytes of data are passed to the corresponding byte stream,
  for example out to the UART, or into BlueStack as if sent by a
  RFC_DATA_IND for UART/RFCOMM sinks respectively.

  Pointers previously obtained from SinkMap or SinkMapHeader become invalid
  after a call to SinkFlush.

  @note
  Operator sink stream mapping parameters must be configured by using 
  SinkMapInit before calling this function. If the sink is an operator
  sink stream with uninitialized mapping parameters, then it always returns
  FALSE, irrespective of whether the operator sink stream is valid or not.

  @note
  If the sink is a StreamFileSink, StreamFilesystemSink or an ImageUpgradeStreamGetSink
  then further data must not be written to the sink before MESSAGE_MORE_SPACE has been
  received. Alternatively the SinkFlushBlocking trap can be called instead of SinkFlush
  on the above sink types. SinkFlushBlocking provides a guarantee that the data has been
  written by the time the trap returns.

  @note
  The claimed number of bytes in the sink must be mapped and initialised 
  before flush operation is called into.

</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, or FALSE if the operation failed because the sink was invalid or amount exceeded the size of the sink as reported by SinkClaim(sink, 0).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to flush. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="amount" type="uint16">
          <document>
            <description>The number of bytes to flush.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" fast="true" header="Sink" lifestage="" name="SinkFlushHeader" processor="CSR" tmi="6" trapset="STREAM">
      <document>
        <description>Flush the indicated number of bytes out of the sink, with a header.</description>
        <documentation>

  Associates the header with the message.
  The specified bytes of data are then passed to the corresponding byte stream, for
  example out to the UART, or into BlueStack as if sent by a
  RFC_DATA_IND for UART/RFCOMM sinks respectively.

 @note
 Operator sink stream mapping parameters must be configured by using 
 SinkMapInit before calling this function. If the sink is an operator
 sink stream with uninitialized mapping parameters, then it always returns
 FALSE, irrespective of whether the operator sink stream is valid or not.
 
  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, or FALSE if the operation failed because the sink was invalid or amount exceeded the size of the sink as reported by SinkClaim(sink, 0).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to flush data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="amount" type="uint16">
          <document>
            <description>The number of bytes of data to flush. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="header" type="const void *">
          <document>
            <description>The header to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="length" type="uint16">
          <document>
            <description>The size of the header.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" fast="true" header="Source" lifestage="" name="SourceSize" processor="CSR" tmi="7" trapset="STREAM">
      <document>
        <description>Reports the number of bytes available in the source.</description>
        <documentation>
 @note 
 Operator source stream mapping parameters must be configured by using 
 SourceMapInit before calling this function. If the source is an operator
 source stream with uninitialized mapping parameters, then it always returns
 zero(0), irrespective of whether the operator source stream is valid or not.
        </documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>Zero if the source is invalid.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to fetch the size of. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" fast="true" header="Source" lifestage="" name="SourceSizeHeader" processor="CSR" tmi="8" trapset="STREAM">
      <document>
        <description>Reports the number of words available in the first header associated with source.</description>
        <documentation>
          
  @note 
  Operator source stream mapping parameters must be configured by using 
  SourceMapInit before calling this function. If the source is an operator
  source stream with uninitialized mapping parameters, then it always returns
  zero(0), irrespective of whether the operator source stream is valid or not.
 </documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>zero if the source is invalid or has no header.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The Source whose header size is required.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" fast="true" header="Source" lifestage="" name="SourceMap" processor="CSR" tmi="9" trapset="STREAM">
      <document>
        <description>Map the source into the address map, returning a pointer to the first byte in the source. </description>
        <documentation>

  The number of accessible bytes is as given by SourceSize(). 
  At most one source can be mapped in at any time;
  pointers previously obtained from SourceMap() become invalid when
  another call to SourceMap() is made. Calls to SourceDrop() also
  invalidate previous pointers returned by SourceMap(). See the SourceDrop()
  documentation for more details.

  @note 
  Operator source stream mapping parameters must be configured by using 
  SourceMapInit before calling this function. If the source is an operator
  source stream with uninitialized mapping parameters, then it always returns
  zero(0), irrespective of whether the operator source stream is valid or not.
  </documentation>
       </document>
      <return type="const uint8 *">
        <document>
          <description>zero if the source is invalid. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to map into the address map.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" fast="true" header="Source" lifestage="" name="SourceMapHeader" processor="CSR" tmi="10" trapset="STREAM">
      <document>
        <description>Map the first header associated with a source into the address map.</description>
        <documentation>

  The number of accessible words is as given by SourceSizeHeader(). At most one header
  source can be mapped in at any time; pointers previously obtained
  from SourceMapHeader() become invalid when another call to
  SourceMapHeader() is made. Calls to SourceDrop() also
  invalidate previous pointers returned by SourceMapHeader().
  See the SourceDrop() documentation for more details.

  @note 
  Operator source stream mapping parameters must be configured by using 
  SourceMapInit before calling this function. If the source is an operator
  source stream with uninitialized mapping parameters, then it always returns
  zero(0), irrespective of whether the operator source stream is valid or not.
  
</documentation>
        <comment />
      </document>
      <return type="const void *">
        <document>
          <description>A pointer to the first word in the header, or zero if the source is invalid or has no headers.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The Source whose header we wish to map. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" fast="true" header="Source" lifestage="" name="SourceDrop" processor="CSR" tmi="11" trapset="STREAM">
      <document>
        <description>Discards the indicated number of bytes from the front of the source.</description>
        <documentation>
 @note
 An implementation detail first introduced in ADK6 means that pointers
 previously obtained from SourceMap or SourceMapHeader will not automatically
 point to the first non-dropped data item after SourceDrop is called.
 Effectively, SourceDrop invalidates pointers previously obtained from SourceMap
 or SourceMapHeader.

 @note 
 Operator source stream mapping parameters must be configured by using 
 SourceMapInit before calling this function. If the source is an operator
 source stream with uninitialized mapping parameters, data will not be 
 dropped, irrespective of whether the operator source stream is valid or not.
       </documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The Source to drop the data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="amount" type="uint16">
          <document>
            <description>The number of bytes to drop. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" fast="true" header="Source" lifestage="" name="SourceBoundary" processor="CSR" tmi="12" trapset="STREAM">
      <document>
        <description>Return how many bytes in this source are before the next packet boundary (for non packet-based sources returns the same as SourceSize.)</description>
        <documentation>
  @note 
  Operator source stream mapping parameters must be configured by using 
  SourceMapInit before calling this function. If the source is an operator
  source stream with uninitialized mapping parameters, then it always returns
  zero(0), irrespective of whether the operator source stream is valid or not.
  
  </documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>Zero if the source is invalid.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to evaluate.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" fast="true" header="Source" lifestage="" name="SourceSizeBlocking" processor="CSR" tmi="53" trapset="STREAM">
      <document>
        <description>Reports the number of data bytes available in the source.</description>
        <documentation>


  This is a blocking version of the SourceSize function. 
  It can be used when reading from streams that have bounded transport delays 
  and where the data is known to exist (such as file streams). 
  It can be used as an alternative to having a task waiting for a MESSAGE_MORE_DATA message.

  @note
  Not all stream types support SourceSizeBlocking. If the given stream doesn't
  support SourceSizeBlocking this function will return SourceSize result.

  @note
  For writable filesystem if data read into source has failed then it will 
  return 0 indicating FAILURE and no data.
  
  </documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>Zero if the source is invalid or if read data into source had failed. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to evaluate.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamMove" processor="CSR" tmi="13" trapset="STREAM">
      <document>
        <description>Move the specified number of bytes from the start of 'source' to the end of 'sink'. </description>
        <documentation>

  The count must be no more than both SinkSlack() and SourceBoundary().

  @note
  An implementation detail first introduced in ADK6 means that pointers returned
  by SourceMap, SourceMapHeader, SinkMap or SinkMapHeader will be invalidated
  after a call to StreamMove.

  @note
  If either source or sink is an operator source/sink stream then it always
  returns zero(0), irrespective of whether the operator source/sink stream
  is valid or not.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>Zero on failure and the count on success.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to move data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="source" type="Source">
          <document>
            <description>The Source to move data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="count" type="uint16">
          <document>
            <description>The number of bytes to move. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamConnect" processor="CSR" tmi="14" trapset="STREAM">
      <document>
        <description>Make an automatic connection between a source and sink </description>
        <documentation>

  

  @note
  Transform created via this call is started implicitly. It is not 
  desired to start or stop such transforms by invoking @a TransformStart()
  or @a TransformStop() respectively from the application.
</documentation>
        <comment />
      </document>
      <return type="Transform">
        <document>
          <description>An already started transform on success, or zero on failure.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The Source data will be taken from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink data will be written to.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamConnectDispose" processor="CSR" tmi="15" trapset="STREAM">
      <document>
        <description>Dispose of all data arriving on the specified source by throwing it away.</description>
        <documentation>

  

  On success the source is effectively connected using StreamConnect();
  you can stop discarding data from the source by calling
  StreamDisconnect(source, 0).
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>FALSE on failure, TRUE on success.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source whose data is to be disposed of.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamConnectAndDispose" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Make an automatic connection between a source and sink, or dispose it.</description>
        <documentation>

  Like StreamConnect(), but if the connection could not be made then the
  source will be passed to StreamConnectDispose(). Similarly, if the
  connection is subsequently broken using StreamDisconnect() or by the
  sink being closed the source will be passed to StreamConnectDispose().

  The end result is that the source will be tidied up correctly, no
  matter what happens after this call.

  Note that the task associated with the source will be
  changed. Messages related to the source will no longer be sent to
  the task previously associated with it.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the connection was made between \e source and \e sink; FALSE if the initial connection failed (in which case, if \e source was valid, it will have been immediately passed to StreamConnectDispose()).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The Source data will be taken from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink data will be written to. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamDisconnect" processor="CSR" tmi="16" trapset="STREAM">
      <document>
        <description>Break any existing automatic connection involving the source *or* sink.</description>
        <documentation>

  Source or sink may be zero.
</documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The Source to check for connections. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to check for connections.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" fast="true" header="Source" lifestage="" name="SourceIsValid" processor="CSR" tmi="51" trapset="STREAM">
      <document>
        <description>Return TRUE if a source is valid, FALSE otherwise.</description>
        <documentation>

  @note
  Even if the source is an operator source, this trap should be able to check
  whether the supplied source stream is valid or not.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to check.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" fast="true" header="Sink" lifestage="" name="SinkIsValid" processor="CSR" tmi="52" trapset="STREAM">
      <document>
        <description>Return TRUE if a sink is valid, FALSE otherwise.</description>
        <documentation>

  @note
  Even if the sink is an operator sink, this trap should able to check whether
  the supplied sink is valid or not. 
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The sink to check.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamConfigure" processor="CSR" tmi="17" trapset="STREAM">
      <document>
        <description>Configure the stream subsystem. </description>
        <documentation>

    

    Reasons for a FALSE return value include attempting to use an invalid \e key,
    attempting to use a \e key not supported in the current firmware build and 
    attempting to use a \e value that is not suitable for the \e key being used.

    The application will be panicked if it attempts to enable or
    disable streams when any corresponding L2CAP/RFCOMM connection is
    open.

    Note that this trap is also used to enable/disable an application's interest
    in receiving certain messages (eg.see keys #VM_STREAM_USB_ALT_IF_MSG_ENABLED
    and #VM_STREAM_USB_ATTACH_MSG_ENABLED).

    This trap is also used to enable L2CAP large buffers for particular PSM
    using key #VM_STREAM_L2CAP_ADD_LARGE_BUFFER_ON_PSM and remove all large 
    buffer information using key #VM_STREAM_L2CAP_REMOVE_ALL_LARGE_BUFFER.
    #VM_STREAM_L2CAP_ADD_LARGE_BUFFER_ON_PSM key should be used to configure 
    before sending or accepting L2CAP connection request.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the configure worked, FALSE if the configure failed.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="vm_stream_config_key">
          <document>
            <description>Keys are defined in #vm_stream_config_key. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint16">
          <document>
            <description>The value to set \e key to.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Source" lifestage="" name="SourceConfigure" processor="CSR" tmi="18" trapset="STREAM">
      <document>
        <description>Configure a particular source.</description>
        <documentation>

    

    See #stream_config_key for the possible keys and their meanings. Note that
    some keys apply only to specific kinds of source.

    @note
    This trap cannot configure operator source stream. So, it always returns 
    FALSE over operator source stream input.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>FALSE if the request could not be performed, TRUE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to configure. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key" type="stream_config_key">
          <document>
            <description>The key to configure. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32">
          <document>
            <description>The value to write to 'key'</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Sink" lifestage="" name="SinkConfigure" processor="CSR" tmi="19" trapset="STREAM">
      <document>
        <description>Configure a particular sink. </description>
        <documentation>

    

    See #stream_config_key for the possible keys and their meanings. Note that
    some keys apply only to specific kinds of sink.
    
    @note
    This trap can not configure an operator sink stream. So, it always returns 
    FALSE when passed an operator sink stream input.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>FALSE if the request could not be performed, TRUE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to configure. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key" type="stream_config_key">
          <document>
            <description>The key to configure. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32">
          <document>
            <description>The value to write to 'key'</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamSourceFromSink" processor="CSR" tmi="20" trapset="STREAM">
      <document>
        <description>Find the Source from its Sink. </description>
        <documentation />
        <comment />
      </document>
      <return type="Source">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink whose source is required. @note If the sink is an operator sink stream then this trap always returns zero(0), because BlueCore firmware can not convert operator sink stream into operator source stream.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamSinkFromSource" processor="CSR" tmi="21" trapset="STREAM">
      <document>
        <description>Find the Sink from its Source. </description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source whose sink is required. @note If the source is an operator source stream then this trap always returns zero(0), because BlueCore firmware can not convert operator source stream into an operator sink stream.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Source" lifestage="" name="SourceClose" processor="CSR" tmi="22" trapset="STREAM">
      <document>
        <description>Request to close the source </description>
        <documentation>

    Some sources, such as RFCOMM connections or the USB
    hardware, have a lifetime defined by other means, and cannot be
    closed using this call.

 @note 
 Operator source stream mapping parameters must be configured by using 
 SourceMapInit before calling this function. If the source is an operator
 source stream with uninitialized mapping parameters, then it always returns  
 FALSE, irrespective of whether the operator source stream is valid or not.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the source could be closed, and FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to close </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Sink" lifestage="" name="SinkClose" processor="CSR" tmi="23" trapset="STREAM">
      <document>
        <description>Request to close the sink </description>
        <documentation>

    Some sinks, such as RFCOMM connections or the USB
    hardware, have a lifetime defined by other means, and cannot be
    closed using this call.
  @note 
  Operator sink stream mapping parameters must be configured by using 
  SinkMapInit before calling this function. If the sink is an operator
  sink stream with uninitialized mapping parameters, then it always returns
  FALSE, irrespective of whether the operator sink stream is valid or not.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the source could be closed, and FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The sink to close </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Sink" lifestage="UNIMPLEMENTED" name="SinkAlias" processor="CSR" tmi="24" trapset="STREAM">
      <document>
        <description>Request to alias two Sinks </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the sinks are aliased successfully, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink1" type="Sink">
          <document>
            <description>The first Sink to be aliased </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink2" type="Sink">
          <document>
            <description>The second Sink to be aliased </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Sink" lifestage="" name="SinkSynchronise" processor="CSR" tmi="25" trapset="STREAM">
      <document>
        <description>Request to synchronise two Sinks </description>
        <documentation>

    Call this function to synchronise timing drifts between two
    sink streams before calling a StreamConnect
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the Sinks are synchronised successfully, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink1" type="Sink">
          <document>
            <description>The first Sink to be synchronised </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink2" type="Sink">
          <document>
            <description>The second Sink to be synchronised </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Source" lifestage="" name="SourceSynchronise" processor="CSR" tmi="26" trapset="STREAM">
      <document>
        <description>Request to synchronise two Sources </description>
        <documentation>

    Call this function to synchronise timing drifts between two
    source streams before calling a StreamConnect
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the Sources are synchronised successfully, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source1" type="Source">
          <document>
            <description>The first Source to be synchronised </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="source2" type="Source">
          <document>
            <description>The second Source to be synchronised </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Transform" lifestage="" name="TransformStart" processor="CSR" tmi="27" trapset="STREAM">
      <document>
        <description>Start a transform; newly created transforms must be started.</description>
        <documentation>

  

  @note
  Application shouldn't call this function for transforms created via 
  @a StreamConnect() call as those transforms are started implicitly.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>FALSE on failure, TRUE on success.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="transform" type="Transform">
          <document>
            <description>The transform to start.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Transform" lifestage="" name="TransformStop" processor="CSR" tmi="28" trapset="STREAM">
      <document>
        <description>Stop a transform,</description>
        <documentation>

  

  @note
  Application shouldn't call this function for transforms created 
  via @a StreamConnect() call. To stop data flow for such transforms, 
  application would typically call @a TransformDisconnect().
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>FALSE on failure, TRUE on success.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="transform" type="Transform">
          <document>
            <description>The transform to stop.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Transform" lifestage="" name="TransformDisconnect" processor="CSR" tmi="29" trapset="STREAM">
      <document>
        <description>Disconnect and destroy a transform. </description>
        <documentation>

  

  The transform can no longer be used after successful disconnecting of the 
  transform.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, FALSE on failure.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="transform" type="Transform">
          <document>
            <description>The transform to destroy.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="" name="TransformPollTraffic" processor="CSR" tmi="30" trapset="STREAM">
      <document>
        <description>Report if any traffic has been handled by this transform.</description>
        <documentation>

  Reads and clears a bit that reports any activity on a
  transform. This can be used to detect activity on connect streams.

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the transform exists and has processed data, FALSE otherwise. @note If the transform is connected between stream and an operator then this trap reports traffic by the transform. But, if the transform is connected between two operators inside the DSP then the trap would return FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="transform" type="Transform">
          <document>
            <description>The transform to query.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="" name="TransformFromSource" processor="CSR" tmi="31" trapset="STREAM">
      <document>
        <description>Find the transform connected to a source.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Transform">
        <document>
          <description>The transform connected to the specified source, or zero if no transform or connection is active.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to look for.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="" name="TransformFromSink" processor="CSR" tmi="32" trapset="STREAM">
      <document>
        <description>Find the transform connected to a sink.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Transform">
        <document>
          <description>The transform connected to the specified sink, or zero if no transform or connection is active.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The sink to look for.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="" name="TransformConfigure" processor="CSR" tmi="33" trapset="STREAM">
      <document>
        <description>Configure parameters associated with a transform. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>Returns FALSE if the key was unrecognised, or if the value was out of bounds.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="transform" type="Transform">
          <document>
            <description>The transform to configure. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key" type="vm_transform_config_key">
          <document>
            <description>Valid values depend on the transform. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint16">
          <document>
            <description>Valid values depend on the transform. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamRegionSource" processor="CSR" tmi="34" trapset="STREAM">
      <document>
        <description>Create a source from a region of memory. </description>
        <documentation>

  This function allows a region of memory to be treated as a source.
  This is useful when there is a requirement to handle data (held in a
  known region of memory) using functions that expect a source, e.g.
  StreamConnect(), in order to efficiently transfer the data without
  having to copy it.

  It is important that the memory being treated as a source persists
  long enough for the stream operation to complete, i.e., long enough
  for the source to be read. The source created using this function
  only exists while the data is being read. However, the memory block
  being treated as a source is not freed by the stream subsystem once
  the data has been read. It remains the caller's responsibility to
  manage the memory and free it when it is appropriate to do so.

  If length is zero then 0 is returned.
</documentation>
        <comment />
      </document>
      <return type="Source">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="data" type="const uint8 *">
          <document>
            <description>The memory that the source will be created from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="length" type="uint16">
          <document>
            <description>The size of the memory region.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="" name="TransformChunk" processor="CSR" tmi="35" trapset="STREAM">
      <document>
        <description>Create a transform between the specified source and sink. </description>
        <documentation>

  

  Copies data in chunks.
</documentation>
        <comment />
      </document>
      <return type="Transform">
        <document>
          <description>0 on failure, otherwise the transform.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The Source to use in the transform. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to use in the transform.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="" name="TransformSlice" processor="CSR" tmi="36" trapset="STREAM">
      <document>
        <description>Create a transform between the specified source and sink. </description>
        <documentation>

  

  Removes bytes from start and end of packets.
</documentation>
        <comment />
      </document>
      <return type="Transform">
        <document>
          <description>0 on failure, otherwise the transform.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The Source to use in the transform. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to use in the transform.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="UNIMPLEMENTED" name="TransformAdpcmDecode" processor="CSR" tmi="37" trapset="STREAM">
      <document>
        <description>Create an ADPCM decode transform between source and sink </description>
        <documentation />
        <comment />
      </document>
      <return type="Transform">
        <document>
          <description>0 on failure, otherwise the transform.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source containing ADPCM encoded data </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description> The destination sink </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Sink" lifestage="" name="SinkMapInit" processor="CSR" tmi="46" trapset="STREAM">
      <document>
        <description>Configures operator sink mapping parameters before calling SinkMap. </description>
        <documentation>
  Sink mapping parameters must be configured for an operator sink stream
  before calling SinkMap. The configuration parameters are #stream_device
  and header length.
  
  @note
  If the sink is not an operator sink then it always returns zero(0).
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if sink mapping parameters have been configured, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>Identifies the operator sink stream. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="device" type="stream_device">
          <document>
            <description>Type of operator sink device. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="header_len" type="uint16">
          <document>
            <description>Length of header in bytes to be used with operator sink stream. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Source" lifestage="" name="SourceMapInit" processor="CSR" tmi="47" trapset="STREAM">
      <document>
        <description>Configures operator source mapping parameters before calling SourceMap or SourceMapHeader. </description>
        <documentation>
  Source mapping parameters must be configured for an operator source 
  stream before calling SourceMap or SourceMapHeader. The configuration
  parameters are #stream_device and header length.
  
  @note
  If the source is not an operator source then it always returns zero(0).
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if source mapping parameters have been configured, otherwise FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>Identifies the operator source. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="device" type="stream_device">
          <document>
            <description>Type of operator source device. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="header_len" type="uint16">
          <document>
            <description>Length of header in bytes to be used with operator source stream. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Sink" lifestage="" name="SinkUnmap" processor="CSR" tmi="48" trapset="STREAM">
      <document>
        <description>Unmap and reset mapping parameters for an operator sink stream. </description>
        <documentation>
  Unmap and reset mapping parameters for an operator sink stream.
  @note
  If the sink is not an operator sink then it always returns zero(0).
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if sink has been unmapped successfully, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>Identifies the operator sink to unmap. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Source" lifestage="" name="SourceUnmap" processor="CSR" tmi="49" trapset="STREAM">
      <document>
        <description>Unmap and reset mapping parameters for an operator source stream. </description>
        <documentation>
Unmap and reset mapping parameters for an operator source stream.
  @note
  If the source is not an operator source then it always returns zero(0).
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if source has been unmapped successfully, otherwise FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>Identifies the operator source to unmap. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Sink" lifestage="" name="SinkFlushBlocking" processor="CSR" tmi="50" trapset="STREAM">
      <document>
        <description>Execute a blocking flush operation to flush the indicated number of bytes out of the sink and only return once they've left. </description>
        <documentation>

  The specified bytes of data are passed to the corresponding byte stream
  and the function waits for confirmation that the bytes have been processed
  before returning. For example an image upgrade sink would pass bytes
  to the QSPI device to write and wait until the write is complete before
  returning.

  Not all stream types support SinkFlushBlocking. If the given stream doesn't
  support SinkFlushBlocking this function will return FALSE.

  Pointers previously obtained from SinkMap or SinkMapHeader become invalid
  after a call to SinkFlushBlocking.

  This is a blocking version of the SinkFlush function and executes at the
  normal priority level rather than high priority.

  @note
  Operator sink stream mapping parameters must be configured by using
  SinkMapInit before calling this function. If the sink is an operator
  sink stream with uninitialized mapping parameters, then it always returns
  FALSE, irrespective of whether the operator sink stream is valid or not.

  @note
  The claimed number of bytes in the sink must be mapped and initialised 
  before flush operation is called into.

</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, or FALSE if the operation failed because the sink was invalid, or doesn't support blocking flushes, or amount exceeded the size of the sink as reported by SinkClaim(sink, 0).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to flush. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="amount" type="uint16">
          <document>
            <description>The number of bytes to flush.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="" name="TransformPacketise" processor="CSR" tmi="54" trapset="STREAM">
      <document>
        <description>Create a packetising transform between the specified source and sink.</description>
        <documentation>
 The packetising transfom loads audio frames into L2CAP packets (or vice versa). The packet format is
proprietary (TWS+), based on RTP. Various configuration is supported on the master (audio->L2CAP) side
to limit the size and timing of packets, as well as the codec and packet format.
        </documentation>
        <comment />
      </document>
      <return type="Transform">
        <document>
          <description>0 on failure, otherwise the transform.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to use in the transform. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description>The sink to use in the transform.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="UNIMPLEMENTED" name="MessageStatusTask" processor="APP" tmi="0" trapset="STATUS">
      <document>
        <description>Register a task to receive a message when status values change.</description>
        <documentation>

  

  The registered task
  will receive just one message and must register itself again if it
  wishes to receive another.

  A message will be sent when any of the listed status fields may have
  changed.
</documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The previously registered task, if any.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task to receive the #MESSAGE_STATUS_CHANGED message. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="count" type="uint16">
          <document>
            <description>How many fields to monitor </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="fields" type="const status_field *">
          <document>
            <description>The fields to monitor</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Status" lifestage="UNIMPLEMENTED" name="StatusQuery" processor="CSR" tmi="1" trapset="STATUS">
      <document>
        <description>Queries the value of the specified status fields.</description>
        <documentation>

  The current value of each of the fields will be written to the
  corresponding element of the results array.
</documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="count" type="uint16">
          <document>
            <description>The number of status fields to read. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="fields" type="const status_field *">
          <document>
            <description>count values each specifying one status value </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="results" type="uint16 *">
          <document>
            <description>count values which will be written to</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Host" lifestage="" name="HostSendMessage" processor="APP" tmi="0" trapset="HOST">
      <document>
        <description>Send a message to the host over the TestTunnel 'host' channel.</description>
        <documentation />
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>The length of the block sent on success, zero otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="msg" type="uint16 *">
          <document>
            <description>The message (block) to send. If the block has been malloc'd then it will be free'd automatically as part of this call. Non-malloc'd blocks (for example, constant arrays) will be copied into a block malloc'd by the call, and that block will be used instead. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Message" lifestage="" name="MessageHostCommsTask" processor="APP" tmi="1" trapset="HOST">
      <document>
        <description>Register a task to handle HostComms primitives.</description>
        <documentation />
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The old task (or zero).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>This task will receive #MESSAGE_FROM_HOST </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="UNIMPLEMENTED" name="StreamHostSink" processor="CSR" tmi="0" trapset="HOSTSTREAM">
      <document>
        <description>Get the Sink for the specified stream-based BCSP#13 channel. </description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="channel" type="uint16">
          <document>
            <description>The channel to fetch the Sink for.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Stream" lifestage="" name="StreamUartSink" processor="APP" tmi="0" trapset="UART">
      <document>
        <description>Find the Sink associated with the raw UART.</description>
        <documentation>

  Returns zero if it is unavailable (for example the appropriate
  transport has not been configured.)
</documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamUartConfigure" processor="APP" tmi="1" trapset="UART">
      <document>
        <description>Dynamically configure the UART settings. </description>
        <documentation>
        PIOs are not handled by this but can be assigned to the UART at any
        point. This is done by using PioSetMapPins32Bank to put the PIO under
        HW control and then PioSetFunction to set the function to one of the
        UART signals.
        Please note that one PIO can be assigned for multiple signals at the
        same time. All UART signals are initially muxed to PIO 96 (which
        doesn't exist) to make sure there are no conflicts. Once a PIO is muxed
        to a UART signal, that signal cannot be muxed back to PIO 96.
        This trap is ignored unless raw access to the UART is enabled. UART is
        enabled by adding TRANSPORT_USER to the firmware defines (enabled by
        default). 
</documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="rate" type="vm_uart_rate">
          <document>
            <description>The UART rate to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="stop" type="vm_uart_stop">
          <document>
            <description>The UART stop to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="parity" type="vm_uart_parity">
          <document>
            <description>The UART parity to use.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="UNIMPLEMENTED" name="StreamRingtoneSource" processor="CSR" tmi="0" trapset="AUDIO">
      <document>
        <description>Returns a source for a synthesised sequence of notes.</description>
        <documentation>

  If the ringtone_note* passed is invalid, the function returns 0.
</documentation>
        <comment />
      </document>
      <return type="Source">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="ringtone" type="const ringtone_note*">
          <document>
            <description>This must be a pointer to an array of ringtone notes.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamAudioSource" processor="CSR" tmi="1" trapset="AUDIO">
      <document>
        <description>Request to create an audio source </description>
        <documentation>
   Note that the DSP software/operator framework must be loaded before creating an audio source.
   Check OperatorFrameworkEnable documentation for more details. 
        </documentation>
        <comment />
      </document>
      <return type="Source">
        <document>
          <description>The Source ID associated with the audio hardware.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="hardware" type="audio_hardware">
          <document>
            <description>The audio hardware which would be reserved as a source </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="instance" type="audio_instance">
          <document>
            <description>The audio hardware instance (meaning depends on \e hardware) </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="channel" type="audio_channel">
          <document>
            <description>The audio channel (meaning depends on \e hardware) </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamAudioSink" processor="CSR" tmi="2" trapset="AUDIO">
      <document>
        <description>Request to create an audio sink </description>
        <documentation>
   Note that the DSP software/operator framework must be loaded before creating an audio sink.
   Check OperatorFrameworkEnable documentation for more details.
        </documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description>The Sink ID associated with the audio hardware.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="hardware" type="audio_hardware">
          <document>
            <description>The audio hardware which would be reserved as a sink </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="instance" type="audio_instance">
          <document>
            <description>The audio hardware instance (meaning depends on \e hardware) </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="channel" type="audio_channel">
          <document>
            <description>The audio channel (meaning depends on \e hardware) </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Codec_" lifestage="" name="CodecSetIirFilter" processor="CSR" tmi="0" trapset="IIR">
      <document>
        <description>Some BlueCore variants have a programmable IIR filter on ADC A and/or B. This trap configures those filters. </description>
        <documentation>
    Note that the DSP operator framework must be loaded before setting the configuration parameters.
    Check OperatorFrameworkEnable documentation for more details.

    To keep microphones in synchronisation, IIR filter(if used) should be configured before
    ADC is turned on(i.e. before StreamConnect()).
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the filter was configured as requested, else FALSE. An invalid coefficient address will result in a FALSE return, as will an invalid instance or channel.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="instance" type="audio_instance">
          <document>
            <description>The audio hardware instance to configure. (See description of #AUDIO_HARDWARE_CODEC for meaning.) </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="channel" type="audio_channel">
          <document>
            <description>The audio channel. (See description of #AUDIO_HARDWARE_CODEC for meaning.) </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="enable" type="bool">
          <document>
            <description>Enables (pass TRUE) or disables (pass FALSE) the filter. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="coefficients" type="uint16 *">
          <document>
            <description>An array of values to program into the filter. Ten values are required for the filter on existing chips.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamScoSink" processor="CSR" tmi="3" trapset="AUDIO">
      <document>
        <description>Returns a Sink from the SCO stream passed. </description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="handle" type="uint16">
          <document>
            <description>The SCO stream from which to fetch the Sink.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamScoSource" processor="CSR" tmi="6" trapset="AUDIO">
      <document>
        <description>Returns a Source from the SCO stream passed. </description>
        <documentation />
        <comment />
      </document>
      <return type="Source">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="handle" type="uint16">
          <document>
            <description>The SCO stream from which to fetch the Source.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>    
    <trap autogen="true" blocking="true" header="Source" lifestage="" name="SourceGetScoHandle" processor="CSR" tmi="7" trapset="AUDIO">
      <document>
        <description>Find the SCO handle corresponding to a source. </description>
        <documentation>@returns The handle, or 0 is the sink wasn't a SCO source
   
   @note
   If the source is an operator source stream then it always returns Zero because it is 
   not a sco source.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to get the handle for </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Sink" lifestage="" name="SinkGetScoHandle" processor="CSR"  tmi="4" trapset="AUDIO">
      <document>
        <description>Find the SCO handle corresponding to a sink. </description>
        <documentation>@returns The handle, or 0 is the sink wasn't a SCO sink
   
   @note
   If the sink is an operator sink stream then it always returns Zero because it is 
   not a sco sink.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to get the handle for </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>    
    <trap autogen="true" blocking="true" header="Voice" lifestage="DEAD" name="VoiceCodecSupported" processor="CSR" tmi="0" trapset="VOICE">
      <document>
        <description>Find out if a certain codec is supported.</description>
        <documentation>

    </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the codec is supported, FALSE otherwise. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="codec" type="voice_codec">
          <document>
            <description>The codec to check for.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Voice" lifestage="DEAD" name="VoiceCodecSet" processor="CSR" tmi="1" trapset="VOICE">
      <document>
        <description>Sets the codec that will be used.</description>
        <documentation>

    </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the codec was successfully set, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sco_sink" type="Sink">
          <document>
            <description>The sink identifying the SCO connection to set the codec. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="codec" type="voice_codec">
          <document>
            <description>The codec to be used.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Vm" lifestage="" name="VmSendRfcommPrim" processor="CSR" tmi="0" trapset="RFCOMM">
      <document>
        <description>Sends an RFCOMM Bluestack primitive. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="prim" type="void *">
          <document>
            <description>A pointer to the primitive to send. The memory must have been dynamically allocated.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamRfcommSink" processor="CSR" tmi="1" trapset="RFCOMM">
      <document>
        <description>Find the Sink corresponding to an RFCOMM connection.</description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="conn_id" type="uint16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Sink" lifestage="" name="SinkGetRfcommConnId" processor="CSR" tmi="2" trapset="RFCOMM">
      <document>
        <description>Find the RFCOMM connection corresponding to a sink. </description>
        <documentation />
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to get the connection identifier for. @note If the sink is an operator sink stream then it always returns Zero because BlueCore firmware can not get RFCOMM connection ID from operator sink stream.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Vm" lifestage="" name="VmSendL2capPrim" processor="CSR" tmi="0" trapset="BLUESTACK">
      <document>
        <description>Sends an L2CAP Bluestack primitive. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="prim" type="void *">
          <document>
            <description>A pointer to the primitive to send. The memory must have been dynamically allocated.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Vm" lifestage="" name="VmSendDmPrim" processor="CSR" tmi="1" trapset="BLUESTACK">
      <document>
        <description>Sends a DM Bluestack primitive. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="prim" type="void *">
          <document>
            <description>A pointer to the primitive to send. The memory must have been dynamically allocated.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Vm" lifestage="" name="VmSendSdpPrim" processor="CSR" tmi="2" trapset="BLUESTACK">
      <document>
        <description>Sends an SDP Bluestack primitive.</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="prim" type="void *">
          <document>
            <description>A pointer to the primitive to send. The memory must have been dynamically allocated.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Vm" lifestage="" name="VmGetHandleFromPointer" processor="CSR" tmi="3" trapset="BLUESTACK">
      <document>
        <description>Converts a VM address space pointer to a handle </description>
        <documentation>

    When assembling a primitive which includes indirect blocks, the application
    must:
    - Allocate a block
    - Convert it to a handle
    - Store the handle in the primitive rather than storing the pointer itself
</documentation>
        <comment />
      </document>
      <return type="void *">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="pointer" type="void *">
          <document>
            <description>The pointer to convert.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Vm" lifestage="" name="VmGetPointerFromHandle" processor="CSR" tmi="4" trapset="BLUESTACK">
      <document>
        <description>Converts a handle to a VM address space pointer. </description>
        <documentation>

    If a Bluestack primitive refers to indirect blocks of memory, those are
    presented in the primitive as handles rather than real pointers. To access
    the data an application must pass the handle to VmGetPointerFromHandle()
    which will make the indirect block visible to the application. The application
    must call this exactly once for each such indirect block, and the resulting
    pointers must all be passed to free. Failure to perform this procedure will 
    result in a resource leak.
    Note - while VmGetHandleFromPointer() will successfully produce a handle from
    a pointer to a constant, VmGetPointerFromHandle() will not produce a pointer
    from such a handle. It will instead panic with VM_PANIC_READ_FROM_ILLEGAL_ADDRESS.
</documentation>
        <comment />
      </document>
      <return type="void *">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="handle" type="void *">
          <document>
            <description>The handle to convert.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageBlueStackTask" processor="CSR" tmi="5" trapset="BLUESTACK">
      <document>
        <description>Register a task to handle BlueStack primitives.</description>
        <documentation />
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The old task (or zero).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>This task will receive MESSAGE_BLUESTACK_*_PRIM, except #MESSAGE_BLUESTACK_ATT_PRIM that are handled by the MessageAttTask(). </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamL2capSink" processor="CSR" tmi="6" trapset="BLUESTACK">
      <document>
        <description>Find the Sink corresponding to an L2CAP connection</description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="cid" type="uint16">
          <document>
            <description>The connection ID to fetch the Sink for.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Sink" lifestage="" name="SinkGetL2capCid" processor="CSR" tmi="7" trapset="BLUESTACK">
      <document>
        <description>Find the L2CAP channel id corresponding to a sink. </description>
        <documentation>

  @note
  If the sink is an operator sink stream then it always returns Zero because 
  BlueCore firmware can not get L2CAP channel id from operator
  sink stream.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to get the connection identifier for.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Sink" lifestage="" name="SinkGetBdAddr" processor="CSR" tmi="38" trapset="STREAM">
      <document>
        <description>Get the Bluetooth address from a sink.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if such an address was found, FALSE otherwise. @note If the sink is an operator sink stream then it always returns FALSE because BlueCore firmware can not get Bluetooth address from operator sink stream.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink to fetch the Bluetooth address from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param direction="OUT" name="tpaddr" type="tp_bdaddr *">
          <document>
            <description>If the address is found it will be returned to the location pointed at by this value.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamSinksFromBdAddr" processor="CSR" tmi="39" trapset="STREAM">
      <document>
        <description>Find all the sinks connected to a given Bluetooth address. </description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if there was enough space, FALSE if some had to be discarded.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param direction="IN OUT" name="max" type="uint16 *">
          <document>
            <description>Stores up to *max sinks in the array given, and updates *max. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param array="true" direction="OUT" name="sinks" type="Sink *">
          <document>
            <description>The array of sinks to store into. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param direction="IN" name="tpaddr" type="const tp_bdaddr *">
          <document>
            <description>The Bluetooth address to use.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Sink" lifestage="" name="SinkGetRssi" processor="CSR" tmi="40" trapset="STREAM">
      <document>
        <description>Get the RSSI for the ACL for a sink.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the RSSI was obtained, FALSE otherwise. @note If the sink is an operator sink stream then it always returns FALSE because it is not a ACL sink.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink which uses the ACL, </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param direction="OUT" name="rssi" type="int16 *">
          <document>
            <description>If the sink corresponds to an ACL the RSSI in dBm will be written to this location.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Sink" lifestage="" name="SinkPollAwayTime" processor="CSR" tmi="8" trapset="BLUESTACK">
      <document>
        <description>Read the away time on the underlying ACL. </description>
        <documentation>

  

  The away time is the time since any packet was received on that ACL
  and is reported in milliseconds. If the time exceeds 0xFFFF, 0xFFFF will
  be returned (this is unlikely with sensible link supervision
  timeouts.)

  @note
  If the sink is an operator sink stream then it always returns Zero because 
  BlueCore firmware can not get ACL connections from operator
  sink stream.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the sink identifies an ACL and the away time on that link could be read, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>identifies the underlying ACL </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param direction="OUT" name="msec" type="uint16 *">
          <document>
            <description>receives the away time if the call succeeds (unmodified otherwise)</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Inquiry" lifestage="" name="InquirySetPriority" processor="CSR" tmi="9" trapset="BLUESTACK">
      <document>
        <description>Sets the priority level of Bluetooth inquiry.</description>
        <documentation>

    </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the level was successfully set, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="priority" type="InquiryPriority">
          <document>
            <description>The desired priority level.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Inquiry" lifestage="" name="InquiryGetPriority" processor="CSR" tmi="10" trapset="BLUESTACK">
      <document>
        <description>Gets the current priority level of Bluetooth inquiry.</description>
        <documentation>

    </documentation>
        <comment />
      </document>
      <return type="InquiryPriority">
        <document>
          <description>The current priority level.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="File" lifestage="" name="FileFind" processor="CSR" tmi="0" trapset="FILE">
      <document>
        <description>Find the index for a named file or directory, relative to the starting directory.</description>
        <documentation>

  

  Leading and trailing directory separators in @a name are ignored.

  @a start is commonly #FILE_ROOT.
  @note
  For file in read-write filesystem start parameter needs to be #FILE_ROOT
  and path should have "/rwfs/" prepended to the file name.
</documentation>
        <comment />
      </document>
      <return type="FILE_INDEX">
        <document>
          <description>The index of the item searched for, or #FILE_NONE if no such item exists.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="start" type="FILE_INDEX">
          <document>
            <description>index of directory in which to start the search </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="name" type="const char *">
          <document>
            <description>the name (possibly including a path) of the item to find </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="length" type="uint16">
          <document>
            <description>the number of characters in @a name</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="File" lifestage="" name="FileType" processor="CSR" tmi="1" trapset="FILE">
      <document>
        <description>Find the type of a file specified by its index</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="FILE_TYPE">
        <document>
          <description>The type of the specified file.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="index" type="FILE_INDEX">
          <document>
            <description>the index of the file whose type is required</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="File" lifestage="" name="FileParent" processor="CSR" tmi="2" trapset="FILE">
      <document>
        <description>Find the index of the directory containing this file or directory. </description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="FILE_INDEX">
        <document>
          <description>The index of the directory containing item, or #FILE_NONE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="item" type="FILE_INDEX">
          <document>
            <description>The index of the item we know about.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamFileSource" processor="CSR" tmi="3" trapset="FILE">
      <document>
        <description>Return a source with the contents of the specified file.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Source">
        <document>
          <description>0 if index is #FILE_NONE, or does not correspond to a narrow file.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="index" type="FILE_INDEX">
          <document>
            <description>the file whose contents are requested</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="File" lifestage="" name="FileCreate" processor="CSR" tmi="4" trapset="FILE">
      <document>
        <description>Create file in read-write filesystem.</description> 
        <documentation>

  @note  
  read-write filesystem does not support directory structure. File path 
  should not contain any extra directory apart from "/rwfs/" which  
  needs to be prepended to the file name.

  </documentation>
        <comment />
      </document>
      <return type="FILE_INDEX">
        <document>
          <description>The index of the file created, or #FILE_NONE if could not.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>        
        <param name="name" type="const char *">
          <document>
            <description>the name (including a path) of the item to create </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="length" type="uint16">
          <document>
            <description>the number of characters in @a name</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamFileSink" processor="CSR" tmi="5" trapset="FILE">
      <document>
        <description>Open the file in writable filesystem and return a sink structure to that file.</description> 
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description>The index of the file created, or #FILE_NONE if could not.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>        
        <param name="index" type="FILE_INDEX">
          <document>
            <description>the name (possibly including a path) of the item to find </description>
            <documentation />
            <comment />
          </document>
        </param>        
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="File" lifestage="" name="FileDelete" processor="CSR" tmi="6" trapset="FILE">
      <document>
        <description>Delete file in read-write filesystem.</description> 
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>Success or not.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>        
        <param name="index" type="FILE_INDEX">
          <document>
            <description>the file which needs to be deleted.</description>
            <documentation />
            <comment />
          </document>
        </param>        
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="File" lifestage="" name="FileRename" processor="CSR" tmi="7" trapset="FILE">
      <document>
        <description>Rename file in read-write filesystem.</description> 
        <documentation>
  @note 
  If a file is renamed to itself then it will return FALSE.
  @note  
  For files in read-write filesystem, path needs to have "/rwfs/" prepended to the file names.
  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>Success or not.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>        
        <param name="old_path" type="const char *">
          <document>
            <description>the name (including a path) of the file to rename </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="old_path_len" type="uint16">
          <document>
            <description>the number of characters in old path name</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="new_path" type="const char *">
          <document>
            <description>the new name (including a path) of the file </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="new_path_len" type="uint16">
          <document>
            <description>the number of characters in new path name</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamFilesystemSource" processor="CSR" tmi="8" trapset="FILE">
      <document>
        <description>Return a source with the contents of the specified filesystem.</description>
        <documentation>
  The StreamFilesystemEnable MIB key must be set to 'true' for this trap to be used. This MIB key should be disabled before release as this trap
  allows anyone with access to the Apps P1 traps to read the contents of filesystems which may contain sensitive information.

  This sink does not support being connected to stream sources, i.e. calling StreamConnect on a Filesystem source will return 0.

  Example:
  \code
  uint16 size;
  Source source = StreamFilesystemSource(FILESYSTEM_ID_DEVICE_RO_FS);
  while ((size = SourceBoundary(source)) != 0)
  {
    const uint8 *data = SourceMap(source);
    // do something with the data here
    SourceDrop(source, size);
  }
  SourceClose(source);
  \endcode
        </documentation>
        <comment />
      </document>
      <return type="Source">
        <document>
          <description>0 if the provided filesystem_id is not supported or if the StreamFilesystemEnable MIB key is false. The contents of the filesystem otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="filesystem_id" type="FILESYSTEM_ID">
          <document>
            <description>The filesystem whose contents are requested. Currently FILESYSTEM_ID_DEVICE_RO_FS is the only supported value.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Stream" lifestage="" name="StreamFilesystemSink" processor="CSR" tmi="9" trapset="FILE">
      <document>
        <description>Return a sink for writing an entire filesystem.</description>
        <documentation>
  The entire filesystem must fit into the available space in the stream so that it can be written in a single flush.
  This is required so that the entire filesystem can be validated before any erase or write operations happen.
  Once the entire filesystem has been written into this stream SinkFlushBlocking should be called to validate and write the data.
  SinkFlushBlocking will return false if any stage of the validate / erase / write / initialise process fails.

  Alternatively, SinkFlush can be used to write the filesystem, but the operation should only be considered successfully complete when
  MESSAGE_MORE_SPACE is received by the sink's associated task. When using SinkFlush, if any stage of the process fails then, whilst SinkFlush
  may have returned TRUE, MESSAGE_MORE_SPACE will not be sent to the sink's task.

  This sink does not support being connected to stream sources, i.e. calling StreamConnect on a Filesystem sink will return 0.

  This sink is automatically closed when a flush completes successfully.

  The StreamFilesystemEnable MIB key must be set to 'true' for this trap to be used. This MIB key should be disabled before release as this trap
  allows anyone with access to the Apps P1 traps to modify the contents of filesystems which may contain sensitive information.

  Example:
  \code
  // Create a Filesystem Sink
  Sink sink = PanicNull(StreamFilesystemSink(FILESYSTEM_ID_DEVICE_RO_FS));
  uint8 *mapped = SinkMap(sink);
  uint16 total = 0;

  // Copy each packet to the sink before flushing
  while((data = userDefinedGetPacketFunction(&amp;length)))
  {
    uint16 offset = SinkClaim(sink, length);
    memcpy(mapped + offset, data, length);
    total += length;
  }

  // Blocking flush to validate, erase, write and initialise the filesystem.
  SinkFlushBlocking(sink, total);
  \endcode
        </documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description>0 if the provided filesystem_id is not supported or if the StreamFilesystemEnable MIB key is false. A sink for writing to the filesystem otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="filesystem_id" type="FILESYSTEM_ID">
          <document>
            <description>The filesystem whose contents are to be written. Currently FILESYSTEM_ID_DEVICE_RO_FS is the only supported value.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="File" lifestage="" name="FileSystemUnmount" processor="CSR" tmi="10" trapset="FILE">
      <document>
        <description>Unmount filesystem</description>
        <documentation>

  Used to free up memory on the system processor when the current file operations 
  have been completed. After this call the file system will be mounted again 
  automatically when any trap referencing it is used (such as FileFind or FileCreate).
  
  @note
  This trap does not support all filesystems. If the given filesystem is not supported then 
  this trap will return FALSE.
  
  @note
  For read-write filesystem mount path needs to be "/rwfs/".

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if unmounted successfully, otherwise FALSE</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mount_path" type="const char *">
          <document>
            <description>the mount path of the filesystem to unmount </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamSdMmcSource" processor="APP" tmi="0" trapset="SD_MMC">
      <document>
        <description>Return a source with data on an SD/MMC card.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Source">
        <document>
          <description>0 if params are not correct or there is no SD/MMC card in the slot.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="slot" type="uint8">
          <document>
            <description>SD slot number, counting from 0</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="start_block" type="uint32">
          <document>
            <description>number of the first 512-byte block to be read from a card.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="blocks_count" type="uint32">
          <document>
            <description>total number of 512-byte blocks to be read from a card</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamSdMmcSink" processor="APP" tmi="1" trapset="SD_MMC">
      <document>
        <description>Return a sink that writes data on an SD/MMC card.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description>0 if params are not correct or there is no SD/MMC card in the slot.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="slot" type="uint8">
          <document>
            <description>SD slot number, counting from 0</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="start_block" type="uint32">
          <document>
            <description>number of the first 512-byte block to write data to.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="blocks_count" type="uint32">
          <document>
            <description>total number of 512-byte blocks that can be written.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="SdMmc" lifestage="" name="SdMmcSlotInit" processor="APP" tmi="2" trapset="SD_MMC">
      <document>
        <description>Initialise/deinitialise SD host slot driver.</description>
        <documentation>
        Initialisation will be done of the slots for which MIB key is set
        (SDHostSlot0 and SDHostSlot1).
        If none of the key is set, no operation will be performed but trap will
        return TRUE. It will return FALSE if initialisation operation fails.
        For deinitialisation; all initialised slots will be deinitialised.
        If no slot was initialised, no operation will be performed but trap will
        return TRUE. It will return FALSE if deinitialisation operation fails.
        On \Stretto and \Aura, once SD host is initialised, \c VmRequestRunTimeProfile()
        changes will pend until the SD host slot driver is deinitialised by this API.
  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>True if operation is successful, otherwise FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="init" type="bool">
          <document>
            <description>Initialise (TRUE) or Deinitialise (FALSE) slot driver.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="SdMmc" lifestage="" name="SdMmcReadData" processor="APP" tmi="3" trapset="SD_MMC">
      <document>
        <description>Read data from an SD card.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>True if operation is successful, otherwise FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="slot" type="uint8">
          <document>
            <description>SD slot number, counting from 0</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="buff" type="uint8 *">
          <document>
            <description>Pointer to a block of memory with a minimum size of 512*blocks_count bytes.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="start_block" type="uint32">
          <document>
            <description>Number of the first 512-byte block to be read from the card.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="blocks_count" type="uint32">
          <document>
            <description>Total number of 512-byte blocks to be read from the card.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="SdMmc" lifestage="" name="SdMmcDeviceInfo" processor="APP" tmi="4" trapset="SD_MMC">
      <document>
        <description>Fetch information of an SD card.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>True if operation is successful, otherwise FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="slot" type="uint8">
          <document>
            <description>SD slot number of the card, counting from 0. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="device_info" type="sd_mmc_dev_info *">
          <document>
            <description>Pointer to structure (sd_mmc_dev_info) where device
            information will be written if operation succeeds.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Stream" lifestage="UNIMPLEMENTED" name="StreamKalimbaSink" processor="CSR" tmi="0" trapset="KALIMBA">
      <document>
        <description>The Sink connected to the port passed on Kalimba. </description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="port" type="uint16">
          <document>
            <description>In the range 0..3 (BC3-MM) or 0..7 (BC5-MM)</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Kalimba" lifestage="UNIMPLEMENTED" name="KalimbaLoad" processor="CSR" tmi="1" trapset="KALIMBA">
      <document>
        <description>Loads the specified DSP code into Kalimba and sets it running at full speed with Kalimba in control of the clock.</description>
        <documentation>

  

  \note
  The time taken to start the DSP application depends on the details of the DSP
  application, which can not be predicted by the BlueCore firmware. If the VM
  software watchdog is in use, the VM application should consider the time
  taken to start the DSP application when deciding on the timeout value. The
  BlueCore firmware will not automatically extend the timeout.

  @note
  It does not load DSP code when the operators are in use. In this case, 
  it returns FALSE. Application needs to destroy running operators to
  load the DSP code successfully.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the DSP was successfully loaded and started, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="file" type="FILE_INDEX">
          <document>
            <description>The DSP code to load.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Kalimba" lifestage="UNIMPLEMENTED" name="KalimbaPowerOff" processor="CSR" tmi="2" trapset="KALIMBA">
      <document>
        <description>Turns off power to Kalimba </description>
        <documentation>

   @note
   This functionality fails when the operator(s) are running.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the kalimba is powered-off, otherwise FALSE</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Kalimba" lifestage="UNIMPLEMENTED" name="KalimbaSendMessage" processor="CSR" tmi="3" trapset="KALIMBA">
      <document>
        <description>Sends a four word message to Kalimba. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="message" type="uint16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
        <param name="a" type="uint16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
        <param name="b" type="uint16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
        <param name="c" type="uint16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
        <param name="d" type="uint16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Kalimba" lifestage="UNIMPLEMENTED" name="KalimbaSendLongMessage" processor="CSR" tmi="4" trapset="KALIMBA">
      <document>
        <description>Send a long message to Kalimba</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the message was sent, FALSE if the send failed.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="message" type="uint16">
          <document>
            <description>the id of the message </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="len" type="uint16">
          <document>
            <description> the length of the data (limited to 64) </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="data" type="const uint16 *">
          <document>
            <description> the actual data to be sent</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Message" lifestage="UNIMPLEMENTED" name="MessageKalimbaTask" processor="CSR" tmi="5" trapset="KALIMBA">
      <document>
        <description>Register a task to handle messages from Kalimba.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The previous task, if any, or zero otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>This task will receive #MESSAGE_FROM_KALIMBA and #MESSAGE_FROM_KALIMBA_LONG messages.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Pio" lifestage="UNIMPLEMENTED" name="PioGetKalimbaControl32" processor="CSR" tmi="6" trapset="KALIMBA">
      <document>
        <description>Find out which pins are under kalimba control. Note: Only some BlueCore variants have access to more than 16 PIO lines.</description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Pio" lifestage="UNIMPLEMENTED" name="PioSetKalimbaControl32" processor="CSR" tmi="7" trapset="KALIMBA">
      <document>
        <description>Modify which pins are under control of the Kalimba DSP. </description>
        <documentation>

  Aspects the DSP has control over include the direction (input or output)
  of a PIO, and the level driven when used as an output.
  
  </documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in that mask is high then control of that PIO could not be given to Kalimba and the trap call failed. Note: Only some BlueCore variants have access to more than 16 PIO lines.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mask" type="uint32">
          <document>
            <description>The bit mask to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32">
          <document>
            <description>The pins to set.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="I2c" lifestage="" name="I2cTransfer" processor="CSR" tmi="75" trapset="IIC">
      <document>
        <description>Allows transfer of data across the i2c interface. </description>
        <documentation>

     Perform a composite transfer consisting of a sequence of writes followed by a sequence of reads. These will be separated by a repeated start condition (Sr) and slave address if both reads and writes are performed.

     The general sequence of operations performed is:
     - Start condition (S).
     - Write slave address and direction byte (address | 0).
     - Write \e tx_len data bytes from the buffer at \e tx.
     - Repeated start condition (Sr) if \e tx_len and \e rx_len are non-zero.
     - Write slave address and direction byte (address | 1) if \e tx_len and \e rx_len are non-zero.
     - Read \e rx_len data bytes into the buffer at \e rx, acknowledging all but the final byte.
     - Stop condition (P).

     If \e tx_len is non-zero and \e rx_len is zero then the sequence reduces to:
     - Start condition (S).
     - Write slave address and direction byte (address | 0).
     - Write \e tx_len data bytes from the buffer at \e tx.
     - Stop condition (P).

     Alternatively, if \e tx_len is zero and \e rx_len is non-zero then the sequence reduces to:
     - Start condition (S).
     - Write slave address and direction byte (address | 1).
     - Read \e rx_len data bytes, acknowledging all but the final byte.
     - Stop condition (P).

     Finally, if both \e tx_len and \e rx_len are zero then the following minimal sequence is used:
     - Start condition (S).
     - Write slave address and direction byte (address | 1).
     - Stop condition (P).

     The transfer will be aborted if either the slave address or a byte being written is not acknowledged. The stop condition (P) will still be driven to reset the bus.

     Note also that the address is not shifted before being combined with the direction bit, i.e. the slave address should occupy bits 7 to 1 of address. This allows the R/W bit to be forced to 1 for composite write/read transfers without a repeated start condition (Sr).

     If either \e tx_len or \e rx_len exceeds 64, failure may be returned or performance may be impaired; for instance, audio streaming may be disrupted.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>The number of bytes acknowledged including the address bytes and the final data byte (which isn't strictly acknowledged).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="address" type="uint16">
          <document>
            <description>The device address of the slave for this transfer. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="tx" type="const uint8 *">
          <document>
            <description> A pointer to the data we wish to transmit. One octet per word. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="tx_len" type="uint16">
          <document>
            <description> The length of the data we wish to transmit. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="rx" type="uint8 *">
          <document>
            <description> A pointer to the memory we wish to read received data into. One octet per word. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="rx_len" type="uint16">
          <document>
            <description> The length of the data we wish to receive. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamI2cSource" processor="CSR" tmi="76" trapset="IICSTREAM">
      <document>
        <description>Return a source with the contents of the specified I2C address. </description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Source">
        <document>
          <description>The source associated with the I2C stream.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="slave_addr" type="uint16">
          <document>
            <description>The slave address of the device to read data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="array_addr" type="uint16">
          <document>
            <description>The array address to read data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="uint16">
          <document>
            <description>The amount of data (in bytes) to read.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Os" lifestage="" name="OsInit" processor="APP" tmi="77" trapset="CORE">
      <document>
        <description>Initialises the P1 Operating System. Must be called before doing anything else.</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Test" lifestage="UNIMPLEMENTED" name="TestPerform_" processor="CSR" tmi="0" trapset="TEST">
      <document>
        <description>Internal function. Don't call this function directly. Don't rely on this being present.</description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="len" type="uint16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
        <param name="args" type="const uint16 *">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Test" lifestage="" name="TestPause" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Radio test pause.</description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, else FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Test" lifestage="" name="TestTxStart" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Radio test tx start. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, else FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="lo_freq" type="uint16">
          <document>
            <description> The lo_freq to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="level" type="uint16">
          <document>
            <description>The level to use. The lower 8 bits are the internal gain. The upper 8 bits are the external gain. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="mod_freq" type="uint16">
          <document>
            <description>The mod_freq to use.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Test" lifestage="" name="TestTxData1" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Radio test tx data 1. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, else FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="lo_freq" type="uint16">
          <document>
            <description> Local oscillator frequency to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="level" type="uint16">
          <document>
            <description> Transmit level to use. The lower 8 bits are the internal gain. The upper 8 bits are the external gain.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Test" lifestage="" name="TestTxData2" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Radio test tx data 2. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, else FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="cc" type="uint16">
          <document>
            <description>The cc to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="level" type="uint16">
          <document>
            <description>The level to use. The lower 8 bits are the internal gain. The upper 8 bits are the external gain.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Test" lifestage="" name="TestRxStart" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Radio test rx. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, else FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="lo_freq" type="uint16">
          <document>
            <description>The lo_freq to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="highside" type="uint16">
          <document>
            <description>The high side to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="attn" type="uint16">
          <document>
            <description>The attn to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Test" lifestage="UNIMPLEMENTED" name="TestDeepSleep" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Radio test deep sleep.</description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Test" lifestage="UNIMPLEMENTED" name="TestPcmLb" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Configure hardware loopback for PCM port. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="pcm_mode" type="uint16">
          <document>
            <description> Chosen loopback mode. Valid values: 0, 1, 2</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Test" lifestage="" name="TestLoopback" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Radio test loop back. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE on success, else FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="lo_freq" type="uint16">
          <document>
            <description>The lo_freq to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="level" type="uint16">
          <document>
            <description>The level to use.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Test" lifestage="UNIMPLEMENTED" name="TestPcmExtLb" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Configure external hardware loopback for PCM port. A block of random data is written to the PCM output port and is read back again on the PCM input port. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="pcm_mode" type="uint16">
          <document>
            <description> Chosen loopback mode. Valid values: 0, 1, 2</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Test" lifestage="UNIMPLEMENTED" name="TestCfgXtalFtrim" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Radio test for configuring the crystal trim value. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="xtal_ftrim" type="uint16">
          <document>
            <description>Selected crystal trim value.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Test" lifestage="UNIMPLEMENTED" name="TestPcmTone" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Play a constant tone on the PCM port (or the codec for BC02 with PSKEY_HOSTIO_MAP_SCO_CODEC set). </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="freq" type="uint16">
          <document>
            <description> Chosen frequency. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="ampl" type="uint16">
          <document>
            <description> Chosen amplitude. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="dc" type="uint16">
          <document>
            <description> Specifies a constant offset to add to the audio data.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Test" lifestage="UNIMPLEMENTED" name="TestCodecStereoLb" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Turn on codec hardware for stereo loopback </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="samp_rate" type="uint16">
          <document>
            <description> Sampling rate. Valid values: 8000, 11025, 16000, 22050, 24000, 32000 and 44100 </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="reroute_optn" type="uint16">
          <document>
            <description> Routing option. Valid values: 0, 1, 2, 3</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Test" lifestage="UNIMPLEMENTED" name="TestPcmToneIf" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Play a constant tone on the PCM port (or the codec for BC02 with PSKEY_HOSTIO_MAP_SCO_CODEC set). </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if successful, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="freq" type="uint16">
          <document>
            <description> Chosen frequency. Valid range: 0 (low) to 3 (high). </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="ampl" type="uint16">
          <document>
            <description> Chosen amplitude. Valid range: 0 (minimum) to 8 (maximum). </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="dc" type="uint16">
          <document>
            <description> Specifies a constant offset to add to the audio data. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="interface" type="uint16">
          <document>
            <description>Chosen PCM interface. A value from the #audio_instance enumeration. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Test" lifestage="UNIMPLEMENTED" name="TestPcmLbIf" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Configure hardware loopback for PCM port. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if successful, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="pcm_mode" type="uint16">
          <document>
            <description> Chosen mode. Valid values: 0 (slave), 1 (master), 2 (Manchester slave) </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="interface" type="uint16">
          <document>
            <description>Chosen PCM interface. A value from the #audio_instance enumeration. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Test" lifestage="UNIMPLEMENTED" name="TestPcmExtLbIf" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Configure external hardware loopback for PCM port. A block of random data is written to the PCM output port and is read back again on the PCM input port. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if successful, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="pcm_mode" type="uint16">
          <document>
            <description> Chosen mode. Valid values: 0 (slave), 1 (master), 2 (Manchester slave) </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="interface" type="uint16">
          <document>
            <description>Chosen PCM interface. A value from the #audio_instance enumeration. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Energy" lifestage="" name="EnergyEstimationSetBounds" processor="CSR" tmi="0" trapset="ENERGY">
      <document>
        <description>Turn on energy estimation with both upper and lower thresholds.</description>
        <documentation>

   One #MESSAGE_ENERGY_CHANGED message will be sent to the task associated
   with the SCO stream when estimated energy content goes outside the bounds.
   The message payload will indicate if the energy content went above the
   upper threshold, or below the lower one. The task must then
   reenable the energy estimation if it wishes to receive further messages.

   Estimation is automatically stopped when the SCO connection is closed.
   It can be stopped under program control using EnergyEstimationOff().

            </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>FALSE if the sink does not correspond to a SCO connection.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sco" type="Sink">
          <document>
            <description> The SCO stream to enable energy estimation on. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="lower" type="uint16">
          <document>
            <description> The lower bound on energy </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="upper" type="uint16">
          <document>
            <description> The upper bound on energy</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Energy" lifestage="" name="EnergyEstimationOff" processor="CSR" tmi="1" trapset="ENERGY">
      <document>
        <description>Disable estimation on the specified SCO connection. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>FALSE if the sink does not correspond to a SCO connection.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sco" type="Sink">
          <document>
            <description>The SCO connection to disable energy estimation on. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Usb" lifestage="" name="UsbAttachedStatus" processor="APP" tmi="0" trapset="USB">
      <document>
        <description>Determine if USB connection is attached or detached </description>
        <documentation>

    Consult the USB battery charging specification available at www.usb.org
    for more details on the difference between a dedicated charger and a standard host.

    Note that BlueCore will only report a correct AttachedStatus if PSKEY_USB_PIO_VBUS
    is set correctly and either a PIO or the internal battery charger (if available) is
    connected to the USB VBUS pin.
</documentation>
        <comment />
      </document>
      <return type="usb_attached_status">
        <document>
          <description>A value to indicate whether the USB connection is currently attached or detached. If USB charger detection is enabled then, if attached, the value returned will give information as to the type of device you are attached to (for example, a standard host/hub or a dedicated charger).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    
    <trap autogen="p0_non_block" blocking="true" header="Usb_Hub" lifestage="" name="UsbHubAttach" processor="APP" tmi="0" trapset="USB_HUB">
      <document>
        <description>Attach USB device to the hub</description>
        <documentation>

    Device freezes all descriptors and starts attachment to the host by
    attaching to the hub. Changes to the descriptors are no longer allowed
    and correspondent traps will fail.
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>FALSE if something has gone wrong.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    
    <trap autogen="true" blocking="true" header="Usb_Hub" lifestage="" name="UsbHubDetach" processor="APP" tmi="1" trapset="USB_HUB">
      <document>
        <description>Detach USB device from the hub</description>
        <documentation>

    Detaches USB device from the hub and hence from the host so that
    USB descriptors can be modified.
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>FALSE if something has gone wrong.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>

    <trap autogen="p0_non_block" blocking="true" header="Usb_Hub" lifestage="" name="UsbHubConfigure" processor="APP" tmi="2" trapset="USB_HUB">
      <document>
        <description>Configure USB device</description>
        <documentation>
        Re-configure USB device using supplied parameters or 
        parameters from MIB keys (if "device_params" == NULL).
        Any descriptors previously added will be destroyed.
        Device must not be attached to the hub.
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if finished successfully,
          FALSE if something has gone wrong.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="device_params" type="const usb_device_parameters *">
          <document>
            <description>Pointer to a structure with USB device parameters
            (can be de-allocated after the trap call). If "NULL" is supplied,
            then parameters are taken from MIB keys.
            </description>
            <documentation />
            <comment />
          </document>
        </param>

      </params>
    </trap>
    
    <trap autogen="p0_non_block" blocking="true" header="Usb" lifestage="" name="UsbAddInterface" processor="APP" tmi="1" trapset="USB">
      <document>
        <description>Adds a USB interface. See the USB2.0 spec section 9.6.5 </description>
        <documentation>

   

   This API is used to register both the USB interface descriptor details, and any class specific
   descriptors to be returned to the host. 

   If there are no class specific descriptors then the type, if_descriptor, and
   descriptor_length parameters must be set to 0, NULL, 0 respectively.
   Otherwise, usb_interface_error is returned. 
</documentation>
        <comment />
      </document>
      <return type="UsbInterface">
        <document>
          <description>An interface number on success, else returns usb_interface_error. Possible reasons for usb_interface_error include insufficient pmalloc space for new firmware data structures, BlueCore is already enumerated on the bus, PSKEY_HOST_INTERFACE is not set to USB or PSKEY_USB_VM_CONTROL is FALSE, invalid combination of "descriptor_length" and "type" field.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="codes" type="const UsbCodes *">
          <document>
            <description>Defines the USB class, sub-class and protocol. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="type" type="uint16">
          <document>
            <description>Defines the class specific descriptor type. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="if_descriptor" type="const uint8 *">
          <document>
            <description>Points to the class specific descriptor. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="descriptor_length" type="uint16">
          <document>
            <description>The length in bytes of if_descriptor.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Usb" lifestage="" name="UsbAddEndPoints" processor="CSR" tmi="2" trapset="USB">
      <document>
        <description>Adds USB endpoints to the interface passed. See the USB2.0 spec section 9.6.6 </description>
        <documentation>

   </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the endpoints were successfully added, else FALSE. Possible reasons for a FALSE return value include an invalid "interface" parameter, insufficient pmalloc space for new firmware data structures, BlueCore is already enumerated on the bus, PSKEY_HOST_INTERFACE is not set to USB or PSKEY_USB_VM_CONTROL is FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="interface" type="UsbInterface">
          <document>
            <description>The interface to add endpoints to (returned by a call to UsbAddInterface()). </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="num_end_points" type="uint16">
          <document>
            <description>The number of endpoints to be added. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="end_point_info" type="const EndPointInfo *">
          <document>
            <description>Points to an array of endpoint definitions.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Usb" lifestage="" name="UsbAddDescriptor" processor="APP" tmi="3" trapset="USB">
      <document>
        <description>Adds a USB descriptor to an interface or endpoint. </description>
        <documentation>

   </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the descriptor was successfully added, else FALSE. Descriptor type for a class specific endpoint descriptor will contain the address of the endpoint in the upper 8 bits. The upper 8 bits should be 0 otherwise. This API is normally used to add HID report or class specific endpoint descriptors.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="interface" type="UsbInterface">
          <document>
            <description>The interface to add the descriptor to. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="type" type="uint16">
          <document>
            <description>Descriptor type (lower 8 bits). </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="descriptor" type="const uint8 *">
          <document>
            <description>Pointer to the descriptor to add. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="descriptor_length" type="uint16">
          <document>
            <description>The length of the descriptor in bytes.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Usb" lifestage="" name="UsbAddStringDescriptor" processor="APP" tmi="4" trapset="USB">
      <document>
        <description>Adds a USB String Descriptor. See the USB2.0 spec section 9.6.7 </description>
        <documentation>

  

  The string_descriptor passed is in UTF16 format and MUST be NUL terminated.
  The NUL terminator will not be passed to USB host as part of the string
  descriptor when a string descriptor request is received, it is simply
  to denote the end of the string.

  Example:
  In order to register string descriptor 11 as "Test".

  UsbAddStringDescriptor(11, myStringDescriptor);
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the descriptor was added, else FALSE. A FALSE value will be returned if an invalid string_index parameter is given.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="string_index" type="uint8">
          <document>
            <description>The USB String Descriptor number. Only index in the range 5 to 255 can be used as 1 to 4 are reserved. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="string_descriptor" type="const uint16 *">
          <document>
            <description>A pointer to the string descriptor.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Usb" lifestage="" name="UsbAddInterfaceAssociationDescriptor" processor="APP" tmi="5" trapset="USB">
      <document>
        <description>Add an Interface Association Descriptor to a USB interface </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the Interface Association descriptor was added correctly, else FALSE. A FALSE value will be returned if an invalid if_num is given.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="if_num" type="uint16">
          <document>
            <description>The interface number returned by a call to UsbAddInterface() </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="ia_descriptor" type="const uint8 *">
          <document>
            <description>A pointer to the Interface Association descriptor in VM address space </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="descriptor_length" type="uint16">
          <document>
            <description>The length of the Interface Association descriptor pointed to by ia_descriptor. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Usb" lifestage="UNIMPLEMENTED" name="UsbAddDfuInterface" processor="APP" tmi="6" trapset="USB">
      <document>
        <description>Adds a DFU interface to the USB port.</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamUsbClassSink" processor="APP" tmi="7" trapset="USB">
      <document>
        <description>Return the USB Class Request Sink. </description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="interface" type="UsbInterface">
          <document>
            <description>The USB interface (returned by UsbAddInterface) to fetch the Sink for. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamUsbEndPointSink" processor="APP" tmi="8" trapset="USB">
      <document>
        <description>Return the USB Request Sink associated with the USB transport. </description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="end_point" type="uint16">
          <document>
            <description>The USB endpoint (bEndPointAddress field in EndPointInfo structure) to fetch the Sink for.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamUsbVendorSink" processor="APP" tmi="9" trapset="USB">
      <document>
        <description>Return the USB Vendor Sink associated with the USB transport.</description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Psu" lifestage="" name="PsuGetVregEn" processor="CSR" tmi="0" trapset="PSU">
      <document>
        <description>Returns TRUE if VREG_EN(_H) is raised.</description>
        <documentation>

  This is only supported on BlueCore variants with charger hardware. 
  On BlueCore variants prior to BC5 this must be polled if we wish to 
  detect if the level of VREG_EN(_H) has changed. On BlueCore variants 
  from BC5 onwards changes in the VREG_EN(_H) level can generate events;
  See MessageChargerTask documentation for details.

  (Typically an ON/OFF button is wired to VREG_EN.  When the button is
  pressed, VREG_EN goes high, the chip powers up, and the firmware
  latches the SMPSU regulator as part of the early boot sequence.
  VREG_EN can then be removed. To turn off the chip using the same
  button we need to have visibility of VREG_EN.)
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Psu" lifestage="" name="PsuConfigure" processor="CSR" tmi="1" trapset="PSU">
      <document>
        <description>Configures PSU regulators </description>
        <documentation>

    

    Various BlueCore models have different numbers and types of power supplies/ regulators.
    This means the actual power supply controlled by any psu_id may change between different
    BlueCore models. Consult the datasheet for your BlueCore variant for more information.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the psu_id is valid, the key is valid and the input value corresponding to the key is in valid, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="psu" type="psu_id">
          <document>
            <description>Which power supply to reconfigure </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key" type="psu_config_key">
          <document>
            <description>Which aspect of the PSU to configure </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint16">
          <document>
            <description>Which value to use</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmGetPowerSource" processor="CSR" tmi="2" trapset="PSU">
      <document>
        <description>Returns a bit pattern representing the source of the voltage regulator enable signal on (re)boot.</description>
        <documentation>

           When the voltage regulators of a CSR8670 or CSR8670-like chip are 
           enabled as part of the turn-on sequence or during reset, a value is 
           stored indicating the source of the signals responsible for enabling 
           the chip's power supplies.  This value can be retrieved by a VM app and 
           is a bit-pattern composed of the enumerated values defined in the 
           #vm_power_enabler type.

           See the type definition for more information.

     </documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>A bit pattern representing regulator enabling signals. See the #vm_power_enabler type definition.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Charger" lifestage="" name="ChargerConfigure" processor="CSR" tmi="0" trapset="CHARGER">
      <document>
        <description>Configuration of the onchip battery charger present on some BlueCore variants </description>
        <documentation>

  

  Consult the datasheet for your BlueCore variant and the documentation for the
  #charger_config_key type for more information.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the key is valid and the input value correspoding to the key is in valid, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="charger_config_key">
          <document>
            <description>Which aspect of the charger hardware to configure </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint16">
          <document>
            <description>Which value to use</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Charger" lifestage="" name="ChargerStatus" processor="CSR" tmi="1" trapset="CHARGER">
      <document>
        <description>Get the status of the charging hardware.</description>
        <documentation>

  Reports information on the state of the on chip battery charger.
  This is only supported on BlueCore variants with charger hardware.
</documentation>
        <comment />
      </document>
      <return type="charger_status">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageChargerTask" processor="CSR" tmi="0" trapset="CHARGERMESSAGE">
      <document>
        <description>Register a task to handle messages from the onchip battery charger and power system hardware. </description>
        <documentation />
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The old task (or zero).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>This task will receive #MESSAGE_CHARGER_CHANGED messages when parts of the charger or power system hardware changes. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Charger" lifestage="" name="ChargerDebounce" processor="CSR" tmi="1" trapset="CHARGERMESSAGE">
      <document>
        <description>Enables charger events and configures their debouncing. </description>
        <documentation>

    A #MESSAGE_CHARGER_CHANGED message will be delivered to the task setup by MessageChargerTask()
    when the debounced state of the charger pins has changed.

    For example calling ChargerDebounce((CHARGER_VREG_EVENT | CHARGER_CONNECT_EVENT), 4, 1000)
    will enable the VREGEN_H and the charger attach/detach events. The application will
    receive a #MESSAGE_CHARGER_CHANGED message after the charger pins value has changed and then 
    remained stable for 4 consecutive reads 1000 milliseconds apart. 
    For CSR8670 or CSR8670-like chips this same call would also enable a #MESSAGE_CHARGER_CHANGED
    message to be received when VREG_EN has been detected pressed for four consecutive readings,
    each 1000mS apart.
    
    In ADK6 firmware, CHARGER_CONNECT_EVENT Debounce configuration through this trap will not be supported.
    #MESSAGE_CHARGER_CHANGED message will be received when charger has been detected 
    using the ChargerInsertionDebounceTime and ChargerRemovalDebounceTime. 

</documentation>
        <comment />
      </document>
      <return type="charger_events">
        <document>
          <description>A charger_events bit mask where any bit set high indicates an invalid event bit passed in the "events_to_enable" parameter. Any invalid event will result in the ChargerDebounce() request being rejected. Returns 0 on success.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="events_to_enable" type="charger_events">
          <document>
            <description>Each bit position enables a charger event. See the #charger_events enum for details of the events. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="count" type="uint16">
          <document>
            <description>The number of times to read from the charger pins before notifying the application </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="period" type="uint16">
          <document>
            <description>The delay in milliseconds between reads.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Micbias" lifestage="" name="MicbiasConfigure" processor="CSR" tmi="0" trapset="MICBIAS">
      <document>
        <description>Control of Microphone bias hardware </description>
        <documentation>

    

    Note: The dedicated mic bias pin is only present on some BlueCore variants.
    Only chips from BC5 onwards have this feature. In addition at least one ADC
    or DAC on chip must be enabled for the MicBias hardware to operate.

    Consult the datasheet for your BlueCore variant for more information.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the "mic" parameter is valid and the input value is in valid range, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mic" type="mic_bias_id">
          <document>
            <description>Which microphone bias pin to configure </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key" type="mic_bias_config_key">
          <document>
            <description>Which aspect of the microphone bias to configure </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint16">
          <document>
            <description>Which value to use</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Led" lifestage="" name="LedConfigure" processor="APP" tmi="0" trapset="LED">
      <document>
        <description>Control the LED hardware present on some BlueCore variants</description>
        <documentation>

    More detailed information on the keys and values can be found in led_if.h
    See the data sheet for accurate information on which LED hardware a given BlueCore
    variant supports.
    Before using this trap at least one PIO needs to be assigned to the LED controller.
    This is done by using PioSetMapPins32Bank to put the PIO under HW control and then
    PioSetFunction to set the function to LED. If there is an LED pad that can be used
    by an LED controller instance and that LED controller instance does not have any PIO
    assigned to it, then the LED pad will be automatically configured for the LED function
    on the first call to this trap.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the #led_id is valid and the input value is in valid range and there is at least one PIO assigned to the LED controller using PioSetFunction, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="led" type="led_id">
          <document>
            <description>The LED to configure </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key" type="led_config_key">
          <document>
            <description>Which LED parameter to configure. See ::led_config_key for the documentation of each key. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint16">
          <document>
            <description>The value the parameter specified by "key" should be set to </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Font" lifestage="UNIMPLEMENTED" name="FontInit" processor="CSR" tmi="0" trapset="FONT">
      <document>
        <description>Initalise the font subsystem.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="FontId">
        <document>
          <description>The number of fonts found, or zero if no fonts were found (for example, if the fonts.app file wasn't found in the filesystem).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Font" lifestage="UNIMPLEMENTED" name="FontGetGlyph" processor="CSR" tmi="1" trapset="FONT">
      <document>
        <description>Retrieve one character glyph from a font.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="size_t">
        <document>
          <description>The width of the glyph if it was found and fits in the buffer provided (or no buffer was provided), otherwise returns (size_t) -1.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="font" type="FontId">
          <document>
            <description>The index of the font to get the glyph from </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="c" type="ucs2char">
          <document>
            <description>The character to get from that font </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="glyph" type="uint16 *">
          <document>
            <description>A buffer to write the glyph data into </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="max_glyph_wid" type="size_t">
          <document>
            <description>The number of words which can be written to glyph (must be zero if glyph is NULL)</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="UNIMPLEMENTED" name="StreamFastPipeSink" processor="CSR" tmi="0" trapset="FASTPIPE">
      <document>
        <description>Return the FastPipe Sink for the pipe requested. </description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="id" type="uint16">
          <document>
            <description>The ID of the pipe needed.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="UNIMPLEMENTED" name="StreamShuntSink" processor="CSR" tmi="0" trapset="SHUNT">
      <document>
        <description>Return the sink corresponding to the shunt for the given L2CAP CID on the given ACL </description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="acl" type="uint16">
          <document>
            <description>the ACL connection handle (from the host) </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="cid" type="uint16">
          <document>
            <description>the L2CAP connection id (from the host)</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Sram" lifestage="UNIMPLEMENTED" name="SramMap" processor="CSR" tmi="0" trapset="SRAM">
      <document>
        <description>Maps external SRAM into the VM memory space</description>
        <documentation>

  

  At the first invocation this finds a sufficient window in the VM's
  data address space and makes the requested portion of external SRAM
  visible; the application can then access external SRAM through the
  returned pointer (see below for the limitations). Subsequent
  invocations can map in different portions of SRAM, at which point
  any existing pointers into the old portion become invalid. (In
  general, accesses through such pointers cannot be trapped by the VM,
  so may cause subtly wrong behaviour rather than panicking the
  application).

  There are restrictions on the use of external SRAM mapped in this
  way. The application may read and write to the SRAM directly, but
  pointers into it may not be passed into most traps; if an attempt is
  made to do so, the application will be stopped. Only a few traps
  fully support operations on pointers into SRAM -- currently memset,
  memmove, and Util* traps.

  If the requested size is greater than the maximum supported, or
  mapping fails for some other reason, a NULL pointer is returned.

  To use external SRAM, the BlueCore device and firmware must both
  support it, and the application circuit must connect up the SRAM
  appropriately, including a PIO to select it (which will be
  unavailable for any other use). PSKEY_SRAM_PIO must be set to
  indicate this PIO to the firmware; by default the PSKEY is not set,
  and if not set, SramMap() will always return NULL. Please refer to
  appropriate product data sheet for the PIO value.

  External SRAM is only supported in certain BlueCore firmware.
  Please refer the appropriate product data sheet for external SRAM
  support and refer CS-307510-AN and CS-324244-AN for usage and other
  details.

  Example Usage:
        ptr = PanicNull(SramMap(...));

</documentation>
        <comment />
      </document>
      <return type="uint16 *">
        <document>
          <description>Pointer to start of mapped SRAM, NULL if cannot map</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sram_addr" type="uint32">
          <document>
            <description>External SRAM physical address to map </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="uint16">
          <document>
            <description>Size (in uint16s) of SRAM to map</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmGetTemperatureBySensor" processor="CSR" tmi="65" trapset="CORE">
      <document>
        <description>Reads the temperature sensors on BlueCore BC7+ chips</description>
        <documentation>

  

       Sensor       Action
    TSENSOR_MAIN    Reads cached temp from main sensor
    TSENSOR_PMU     Reads temp from PMU sensor
        xxx         All other sensor numbers return INVALID_SENSOR
</documentation>
        <comment />
      </document>
      <return type="int16">
        <document>
          <description>Temperature in degrees Celsius, or INVALID_TEMPERATURE if it could not be read.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sensor" type="vm_temp_sensor">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="false" header="Vm" lifestage="" name="VmTransmitPowerMessagesEnable" processor="CSR" tmi="66" trapset="CORE">
      <document>
        <description>Allows one #MESSAGE_TX_POWER_CHANGE_EVENT to be sent to the system task. </description>
        <documentation>

  This is a one-shot enable, i.e., it allows exactly one power change
  message to be sent to the task registered with MessageSystemTask().
  Once that message has been sent, VmTransmitPowerMessagesEnable()
  must be called again to allow the next power change message to be
  sent. This gives the application the opportunity to limit the rate
  at which power change messages arrive, which can be quite frequent
  if unchecked.

  Calling VmTransmitPowerMessagesEnable(TRUE) again before a power
  change message has been received has no effect.
</documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="enable" type="bool">
          <document>
            <description>TRUE to permit power change messages to be sent, FALSE to stop them.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioSetFunction" processor="CSR" tmi="78" trapset="CORE">
      <document>
        <description>Sets a supported function for particular pio pin </description>
        <documentation>
  if a pin can be mapped as LED, UART, BITSERIAL, ANALOGUE etc, then this
  function can be used to set the pin for one of the supported functions.

  Consult the device's data sheet to understand what functions are supported
  for each PIO pins.

  A pin can support only few functions. Trying to set a function which is NOT
  supported by the pin will return FALSE without affecting/modifying the
  existing pin function.

  Before this trap can be used, it is necessary to use PioSetMapPins32Bank to
  put the PIO in HW mode.

  For functions corresponding to other susbystems the OTHER function ID must be
  used. This reverts the PIOs to the initial unmapped state. Any further use by
  the app needs remapping.

  PioSetFunction() Usage Example:
  if PIO[20] can be mapped to UART/BITSERIAL/LED/PIO and currently PIO[20] is
  mapped as PIO, then App should call the PioSetMapPins32Bank() to unmap it
  from PIO and then call PioSetFunction() to map to (UART/BITSERIAL/LED/PIO)
  function.

  Unmap PIO[20] so that it can be mapped to a function
  PioSetMapPins32Bank(0, 1&lt;&lt;20, 0&lt;&lt;20);

  This will map PIO[20] line as UART_RX
  PioSetFunction(20, UART_RX);  

  To map back the PIO[20] as a PIO, PioSetMapPins32Bank() should be used.
  PioSetMapPins32Bank(0, 1&lt;&lt;20, 1&lt;&lt;20);

</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if successful, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="pin" type="uint16">
          <document>
            <description> Pin that requires a function change; the pin value ranges from 0 to 95. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="function" type="pin_function_id">
          <document>
            <description> Supported function that needs to be set for the specified pin. Refer #pin_function_id</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioSetDriveStrength32Bank" processor="CSR" tmi="79" trapset="CORE">
      <document>
        <description>Sets the drive strength for given PIOs </description>
        <documentation>
Depending on the PIO in question there may be several options for the drive strength.
Please consult the datasheet to see which pins support which drive strength values.
</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>A 32 bit mask. If any bit in this mask is high then that PIO could not be set to use the given drive strength ID; note that no action will have been taken on any PIOs.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="mask" type="uint32">
          <document>
            <description>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="drive_strength" type="pin_drive_strength_id">
          <document>
            <description>Supported drive strength that needs to be set for the specified PIOs. Refer to #pin_drive_strength_id .</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGetDriveStrength" processor="CSR" tmi="80" trapset="CORE">
      <document>
        <description>Read the drive strength setting of a particular PIO pin.</description>
        <documentation />
        <comment />
      </document>
      <return type="pin_drive_strength_id">
        <document>
          <description> - Supported drive strength configured for the specified pin.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="pin" type="uint16">
          <document>
            <description> - Pin that requires a drive strength read.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Vm" lifestage="" name="VmGetResetSource" processor="CSR" tmi="0" trapset="CORE">
      <document>
        <description>Returns an enum value relating to the cause of the last reset.</description>
        <documentation>

           When a system reset occurs on BC7 chips a value is stored which 
           relates to the cause of the reset.  This value can be retrieved by a 
           VM app and takes the enumerated values defined in the #vm_reset_source 
           type. Any value not covered by this definition cannot be determined 
           and is deemed an unexpected reset.

           See the type definition for more information.

     </documentation>
        <comment />
      </document>
      <return type="vm_reset_source">
        <document>
          <description>A #vm_reset_source type indicating the source of the last reset.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Vm" lifestage="" name="VmSendAttPrim" processor="CSR" tmi="0" trapset="ATT">
      <document>
        <description>Sends an ATT Bluestack primitive. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="prim" type="void *">
          <document>
            <description>A pointer to the primitive to send. The memory must have been dynamically allocated.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamAttSource" processor="CSR" tmi="1" trapset="ATT">
      <document>
        <description>Find the Source corresponding to an ATT connection with a specific connection id and attribute handle. </description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Source">
        <document>
          <description>Source on success or zero on failure.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="cid" type="uint16">
          <document>
            <description>The channel id to get the connection source id for. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="handle" type="uint16">
          <document>
            <description>The attribute handle to get the connection source id for.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmClearAdvertisingReportFilter" processor="CSR" tmi="2" trapset="ATT">
      <document>
        <description>Remvoes all the advertising filters, allowing all advert reports through to the host.</description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmAddAdvertisingReportFilter" processor="CSR" tmi="3" trapset="ATT">
      <document>
        <description>This helps in controlling how BlueCore filters advertising report events by BLE advertising data content. </description>
        <documentation>
        Filtering is based only on the contents of advertising
        data. Since directed connectable adverts do not contain advertising
        data, and they are expressly intended for the receiving device,
        they are always passed to the host and are unaffected by this
        filter. The event type, Bluetooth device address of the sender and 
        other properties of the advertising reports are ignored by the 
        filter.

        With no filter present, all advertising packets received during 
        scanning are passed to the host in LE Advertising Report Events, 
        subject to advert flood protection. The filter is used to select 
        advertising reports based on the contents of the advertising data
        (AD) and send to the host only the matching reports, thus saving
        the host being woken up unnecessarily.
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the advertising filter pattern is added successfully, otherwise FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="operation" type="uint16">
          <document>
            <description> Describes the relationship between multiple filters. Currently the only valid operation is OR (0x00), meaning that adverts will be sent to the host if they are matched by any of the filters.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="ad_type" type="uint16">
          <document>
            <description>The AD type of the AD structure to match. The filter will only match adverts containing an AD structure of this type. Enum as defined in Bluetooth Assigned Numbers.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="interval" type="uint16">
          <document>
            <description>The interval for repeated attempts to match the pattern in the data portion of the AD structure. For example, if the interval is 4 then we attempt to match at offsets, 0, 4, 8, 12, etc in the data portion of the AD structure. If interval is 0 then we only attempt to match at offset 0. If interval is 0xffff, then exact match is required.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="pattern_length" type="uint16">
          <document>
            <description>The length of the pattern data, i.e. number of uint8s pattern data present in location pointed by @a pattern_addr.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="pattern_addr" type="uint8 *">
          <document>
            <description>A pointer to the malloc'd space where pattern data is present. Each pattern data is 8bit data and no two pattern data should be packed inside uint16. BlueCore will only consider lower 8 bit of each pattern data for pattern matching. If pattern_addr is NULL, then no pattern matching. The allocated memory for pattern data will be freed by the firmware.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Stream" lifestage="unless HIDE_SPIFLASH" name="StreamSpiflashSource" processor="APP" tmi="0" trapset="SPIFLASH">
      <document>
        <description>Return a source with the contents of the specified SPI flash address. </description>
        <documentation />
        <comment />
      </document>
      <return type="Source">
        <document>
          <description>The source associated with the SPI flash stream.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="address" type="uint32">
          <document>
            <description>The array address to read data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size" type="uint16">
          <document>
            <description> The amount of data (in octets )to read. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="CapacitiveSensor" lifestage="DEAD" name="CapacitiveSensorConfigure" processor="CSR" tmi="0" trapset="CAPACITIVE_SENSOR">
      <document>
        <description>Configure general parameters of touch sensor hardware. </description>
        <documentation>

    </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if successful, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="capacitive_sensor_config_key">
          <document>
            <description>Keys are defined in #capacitive_sensor_config_key. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint16">
          <document>
            <description>The value to set \e key to.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="CapacitiveSensor" lifestage="DEAD" name="CapacitiveSensorConfigurePad" processor="CSR" tmi="1" trapset="CAPACITIVE_SENSOR">
      <document>
        <description>Configure pad parameters of touch sensor hardware. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if successful, else FALSE.</description>
          <documentation>
          Please note that this trap may return FALSE for misuses of \c CapacitiveSensorConfigure.
          </documentation>
          <comment />
        </document>
      </return>
      <params>
        <param name="pad" type="uint16">
          <document>
            <description>Pad to configure. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key" type="capacitive_sensor_config_pad_key">
          <document>
            <description>Keys are defined in #capacitive_sensor_config_pad_key. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint16">
          <document>
            <description>The value to set \e key to.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="CapacitiveSensor" lifestage="" name="CapacitiveSensorPadQuery" processor="CSR" tmi="2" trapset="CAPACITIVE_SENSOR">
      <document>
        <description>Get the current status of the capacitive touch pads. </description>
        <documentation>

    The current state of each of the pads will be written to the
    corresponding element of the results array.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if successful, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="count" type="uint16">
          <document>
            <description>The number of pad states to read. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="pads" type="const uint16*">
          <document>
            <description>count values each specifying a pad. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="results" type="capacitive_sensor_pad_state *">
          <document>
            <description>count values to be written to. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Message" lifestage="" name="MessageCapacitiveSensorTask" processor="CSR" tmi="3" trapset="CAPACITIVE_SENSOR">
      <document>
        <description>Register a task to handle touch sensor messages. </description>
        <documentation>

    </documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The old task (or zero).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task which will receive the messages.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="CapacitiveSensor" lifestage="" name="CapacitiveSensorConfigureMultiPad" processor="CSR" tmi="4" trapset="CAPACITIVE_SENSOR">
     <document>
       <description>Configure a set of CapacitiveSensor channels</description>
       <documentation>
        This call enables the common parameters of a set of CapacitiveSensor channels 
        (perhaps all of them) to be set in the hardware.
       </documentation>
       <comment/>
     </document>
     <return type="bool">
      <document>
       <description>Returns TRUE if configuration was successful</description>
       <documentation/>
       <comment/>
      </document>
     </return>
     <params>
       <param name="count" type="uint16">
        <document>
         <description>Number of pads to be configured</description>
         <documentation/>
         <comment/>
        </document>
       </param>
       <param name="pads" type="const uint16 *">
        <document>
         <description>List of \c count pads to be configured</description>
         <documentation/>
         <comment/>
        </document>
       </param>
       <param name="common_config" type="const CAPACITIVE_SENSOR_PAD_CONFIG *">
        <document>
         <description>Pointer to a single \c CAPACITIVE_SENSOR_PAD_CONFIG instance</description>
         <documentation>
         The supplied parameter values will be applied to all the indicated pads
         </documentation>
         <comment/>
        </document>
       </param>
     </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="CapacitiveSensor" lifestage="" name="CapacitiveSensorEnablePads" processor="CSR" tmi="5" trapset="CAPACITIVE_SENSOR">
     <document>
       <description>Enable the supplied set of CapacitiveSensor pads</description>
       <documentation>
       To enable a channel, it is necessary to supply a "preload" value, which
       should be as close as possible to the "natural" capacitance of the pad,
       plus on- and off-trigger levels, which contain the change in the 
       measured capacitance (i.e. current level - background level) to indicate 
       respectively a touch-on when there is currently no detected touch, and
       a touch-off when there is currently a detected touch.
       PIO setup is not handled by this trap but can be done at any point.
       XIO pads need to be configured as analogue pins. This is done by using
       PioSetMapPins32Bank to put the PIO under HW control and then
       PioSetFunction to set the function to XIO_ANALOGUE.
       </documentation>
       <comment/>
     </document>
     <return type="bool">
      <document>
       <description>Returns TRUE if enabling was successful</description>
       <documentation>
          Please note that this trap may return FALSE for misuses of \c CapacitiveSensorConfigureMultiPad.
       </documentation>
       <comment/>
      </document>
     </return>
     <params>
       <param name="count" type="uint16">
        <document>
         <description>Number of pads to be enabled</description>
         <documentation/>
         <comment/>
        </document>
       </param>
       <param name="pads" type="const uint16 *">
        <document>
         <description>List of \c count pads to be enabled</description>
         <documentation>
         These pads must all already be configured!
         </documentation>
         <comment/>
        </document>
       </param>
       <param name="pad_levels" type="const CAPACITIVE_SENSOR_PAD_LEVELS *">
        <document>
         <description>Array of \c count \c CAPACITIVE_SENSOR_PAD_LEVELS, containing the
         preload and trigger levels for each pad to be enabled</description>
         <documentation/>
         <comment/>
        </document>
       </param>
     </params>
    </trap>
    <trap autogen="true" blocking="true" header="CapacitiveSensor" lifestage="" name="CapacitiveSensorConfigureTouchOffset" processor="CSR" tmi="6" trapset="CAPACITIVE_SENSOR">
     <document>
       <description>Configure the touch offset for a CapacitiveSensor channel.</description>
       <documentation>
        This call sets the touch offset for a specific CapacitiveSensor channel. This
        is meant to be used by the APP to take out the capacitance added by a
        touch to avoid the situation where a long touch eventually becomes part
        of the background from the point of view of the background capacitance
        tracker.
        Please note that this value is subtracted from the reading.
       </documentation>
       <comment/>
     </document>
     <return type="bool">
      <document>
       <description>Returns TRUE if configuration was successful</description>
       <documentation/>
       <comment/>
      </document>
     </return>
     <params>
       <param name="pad" type="uint16">
        <document>
         <description>Pad to be configured</description>
         <documentation/>
         <comment/>
        </document>
       </param>
       <param name="touch_offset" type="uint32">
        <document>
         <description>Touch offset value.</description>
         <documentation>
         This is expressed in fF.
         </documentation>
         <comment/>
        </document>
       </param>
     </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Usb" lifestage="" name="UsbAddConfiguration" processor="APP" tmi="10" trapset="USB">
      <document>
        <description>Creates an additional USB configuration. </description>
        <documentation>
    All devices initially have one configuration (with iConfiguration,
    bmAttributes and bMaxPower in the configuration descriptor being provided
    by pskeys), and for most devices one configuration is all you want.
    However, if desired, this function can be used to create additional
    configurations. It will add a new configuration each time it is called,
    it can be called repeatedly, but must be called before any interfaces
    have been added.
    The support for multiple configurations is limited in that the
    interfaces/endpoints have to be the same for all configurations, the
    only values that can be different are the iConfiguration, bmAttributes and
    bMaxPower fields in the configuration descriptor. For the new
    configuration, these values are provided by the members of 'desc_info'.
    Each member of 'desc_info' can be set to the special value
    SAME_AS_FIRST_CONFIG in which case the corresponding entry in the
    configuration descriptor for the new configuration will just be copied
    over from the first configuration.
</documentation>
        <comment />
      </document>
      <return type="uint16">
        <document>
          <description>On success, returns a value corresponding to the bConfigurationValue of the new configuration. This will start at 2 for the first extra configuration created. On error, returns zero. Possible reasons for an error include calling the function after interfaces have been added, insufficient pmalloc space for new firmware data structures, BlueCore is already enumerated on the bus, PSKEY_HOST_INTERFACE is not set to USB or PSKEY_USB_VM_CONTROL is FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="desc_info" type="const ConfigDescriptorInfo *">
          <document>
            <description>Points to info for the new configuration descriptor.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Usb" lifestage="DEAD" name="UsbEnableSuspendResumeMessages" processor="APP" tmi="11" trapset="USB">
      <document>
        <description>Allows MESSAGE_USB_SUSPENDED to be sent to the system task for USB devices. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="enable" type="bool">
          <document>
            <description>TRUE to permit USB resume and suspend messages to be sent, FALSE to stop them. For self-powered USB devices, the system task receives MESSAGE_USB_SUSPENDED messages on a USB suspend or resume. Previously bus-powered devices would never receive these message, however this function can opt-in to receiving resume messages, which include the suspend duration. This permits the VM App to have different behaviour after a 100 ms suspend compared to a 1 hour suspend. This function can be called with enable set to FALSE to opt-out of USB resume and suspend messages for self-powered devices. Note: Bus-powered devices will only receive USB resume messages, not suspend messages.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Otp" lifestage="" name="OtpReadData" processor="CSR" tmi="0" trapset="OTP">
      <document>
        <description>Allows to read the contents of OTP memory. </description>
        <documentation>   
  
  Note that this trap supports reading only 128 bits of OTP memory accessible to customers in ADK6 firmware. 
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if successful, else FALSE. This function allows the VM Application to read the content of the OTP memory. This function assumes the first word written on the OTP memory starts from eFuse 0 (zero). Application should provide the starting location in words starting from word 0 in OTP memory and should provide the number of words to be read from the starting offset. After the completion of the API call, the supplied buffer will contain the read data in following order as shown in example. If the word offset is 12 and 3 words need to be read then the buffer[0] will contain data from offset 12, and buffer[2] will contain data from offset 14. Note: It will return FALSE if the total number of words to be read from starting location exceeds the size of OTP or the supplied location is more than the size of OTP. OTP size can be different on different chips. The maximum possible offset will be OTP size -1 as the 1st word is marked as offset zero. So for a 16 word OTP, the maximum offset will be 15 and the first word will be at offset 0.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="read_value" type="uint16 *">
          <document>
            <description>buffer for storing the data read from OTP. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="start_word" type="uint16">
          <document>
            <description>offset in words where to start reading from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="length_words" type="uint16">
          <document>
            <description>length of data to be read in words. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Otp" lifestage="" name="OtpWriteData" processor="CSR" tmi="1" trapset="OTP">
      <document>
        <description>Allows to write into OTP memory. </description>
        <documentation>   

  This function allows the VM Application to write contents into 128 bits of customer accessible OTP memory. 
  This function assumes the first word written on the OTP memory starts from eFuse 0 (zero). 
  Application should provide the starting location in words starting from word 0 in OTP memory 
  and should provide the number of words to be written from the starting offset. After the 
  completion of the API call, return value will specify if the write worked or not. 
  If the word offset is 2 and 3 words need to be written then the buffer[0] will be 
  written to offset 2 and buffer[2] at offset 4. 
  
  Note: It will return FALSE if the total number of words to write from starting 
  location exceeds the size of OTP or the supplied location is more than the size of OTP. 
  OTP size can be different on different chips. The maximum possible offset will be 
  OTP size -1 as the 1st word is marked as offset zero. So for a 8 word OTP, 
  the maximum offset will be 7 and the first word will be at offset 0.
  Note: If write is successful then chip needs to be reset before reading to confirm those values.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if successful, else FALSE.  </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="write_value" type="const uint16 *">
          <document>
            <description>buffer for data to write to OTP. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="start_word" type="uint16">
          <document>
            <description>offset in words where to start write from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="length_words" type="uint16">
          <document>
            <description>length of data to be written in words. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Lcd" lifestage="UNIMPLEMENTED" name="LcdConfigure" processor="CSR" tmi="0" trapset="LCD">
      <document>
        <description>Configures the LCD hardware. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if successful, otherwise FALSE More detailed information on the keys and values can be found in lcd_if.h</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="uint16">
          <document>
            <description>Keys are defined in #lcd_config_key. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint16">
          <document>
            <description>Depends on the key, and is defined in lcd_if.h </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Pio" lifestage="UNIMPLEMENTED" name="PioSetLcdPins" processor="CSR" trapset="__SPECIAL_INLINE">
      <document>
        <description>Grabs PIOs for use by the LCD block. </description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>zero if successful, otherwise bad bits returned and nothing done.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mask" type="uint32">
          <document>
            <description>These are the required LCD segments. b0-PIO0, b31=PIO31. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="pins" type="uint32">
          <document>
            <description>These should be set to one. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="common_pin" type="uint16">
          <document>
            <description>The PIO that will be connected to the LCD common. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Lcd" lifestage="UNIMPLEMENTED" name="LcdSet" processor="CSR" tmi="1" trapset="LCD">
      <document>
        <description>Controls the activation of lcd segments. These segments must have been specified using VM trap PioSetLcdPins(). </description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>All zeros if sucessful, otherwise incorrect bits</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mask" type="uint32">
          <document>
            <description>Each bit in the mask corresponds to a PIO line, where b0=PIO0. Bits set to 1 will be modified. Bits set to 0 will not be modified. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32">
          <document>
            <description>Each bit specifies a PIO's LCD activation: 1=on, 0=off. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Charger" lifestage="UNIMPLEMENTED" name="ChargerGetBatteryStatusAtBoot" processor="CSR" tmi="0" trapset="CHARGER2">
      <document>
        <description>Returns the state of the battery recorded at boot time.</description>
        <documentation>

    </documentation>
        <comment />
      </document>
      <return type="charger_battery_status">
        <document>
          <description>the status of the battery at boot, as described in #charger_battery_status</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageAttTask" processor="CSR" tmi="4" trapset="ATT">
      <document>
        <description>Register a task to handle BlueStack ATT primitives.</description>
        <documentation />
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The old task (or zero).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>This task will receive #MESSAGE_BLUESTACK_ATT_PRIM. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Usb" lifestage="" name="UsbDeviceState" processor="APP" tmi="12" trapset="USB">
      <document>
        <description>Determine the state of the USB device </description>
        <documentation />
        <comment />
      </document>
      <return type="usb_device_state">
        <document>
          <description>The current state of the USB device from #usb_device_state</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGetUnusedPins32" processor="CSR" tmi="67" trapset="CORE">
      <document>
        <description>Determine which physically existing PIOs are currently not in use by firmware or VM apps. </description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>Those PIOs which are available for use. b31 = PIO31 thru b0 = PIO0. A '1' indicates available.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Pio" lifestage="" name="PioGetUnusedPins32Bank" processor="CSR" tmi="68" trapset="CORE">
      <document>
        <description>Determine which physically existing PIOs are currently not in use by firmware or VM apps. </description>
        <documentation />
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>Those PIOs which are available for use. b31 = PIO31 thru b0 = PIO0. A '1' indicates available.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description>PIO bank number.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Vm" lifestage="" name="VmGetBdAddrtFromCid" processor="CSR" tmi="11" trapset="BLUESTACK">
      <document>
        <description>Retrives the tp_bdaddr value from the given CID value.</description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if an address was found for a given CID, FALSE otherwise. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="cid" type="uint16">
          <document>
            <description>The connection identifier to fetch the Bluetooth address from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param direction="OUT" name="tpaddr" type="tp_bdaddr *">
          <document>
            <description>If the address is found it will be returned to the location pointed at by this value. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamAttSourceAddHandle" processor="CSR" tmi="5" trapset="ATT">
      <document>
        <description>Add an attribute handle corresponding to an ATT connection with a specific connection id.</description>
        <documentation />
        <comment />
      </document>
      <return type="Source">
        <document>
          <description>Source in case of successful addition or zero on failure.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="cid" type="uint16">
          <document>
            <description>The channel id to get the connection source id for. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="handle" type="uint16">
          <document>
            <description>The attribute handle to get the connection source id for. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="UNIMPLEMENTED" name="TransformHid" processor="CSR" tmi="0" trapset="HIDDONGLE">
      <document>
        <description>Generic HID transform supporting the following devices a) Boot mode mouse b) Report mode mouse c) Boot mode keyboard d) Report mode keyboard</description>
        <documentation>

  

</documentation>
        <comment />
      </document>
      <return type="Transform">
        <document>
          <description>An already started transform on success, or zero on failure.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The Source data will be taken from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description>The Sink data will be written to.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeGetInfo" processor="CSR" tmi="0" trapset="IMAGEUPGRADE">
      <document>
        <description>Get information about an image section. </description>
        <documentation>
  @note
  It's expected that the application will only invoke this trap when the image is running from the boot image bank in the input QSPI device.
  
  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>Successful in getting the requested information about an image section. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="qspi" type="uint16">
          <document>
            <description>QSPI device number where the image section is written. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="image_section" type="image_section_id">
          <document>
            <description>Image section.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key" type="image_info_key">
          <document>
            <description>Image upgrade info key. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32 *">
          <document>
            <description>Address to return the value of the key. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeStreamGetSink" processor="CSR" tmi="1" trapset="IMAGEUPGRADE">
      <document>
        <description>Get the stream sink handle for the image section. </description>
        <documentation>
  @note
  The sink handle returned should be used to write
  the image section data into the QSPI device using the stream traps.
  Application shouldn't use this sink handle to connect to any other stream
  types using StreamConnect() trap.
  It's expected that the application will only invoke this trap when the image is running from the boot image bank in the input QSPI device.
  </documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description>Stream sink handle for writing the image section in the QSPI device. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="qspi" type="uint16">
          <document>
            <description>QSPI device number where the image section is written. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="image_section" type="image_section_id">
          <document>
            <description>Image section.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="first_word" type="uint32">
          <document>
            <description>First 4 bytes of the image section which is written when the stream is closed. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeSinkGetPosition" processor="CSR" tmi="2" trapset="IMAGEUPGRADE">
      <document>
        <description>Get the current sink write position (in bytes) of the image section sink stream, skipping the first 4 bytes.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>Successful in getting the offset for the input sink. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>Sink handle for the image upgrade stream. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="offset" type="uint32 *">
          <document>
            <description>Address to return the current sink write position. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="false" header="ImageUpgrade" lifestage="" name="ImageUpgradeErase" processor="CSR" tmi="3" trapset="IMAGEUPGRADE">
      <document>
        <description>Erase the other image bank in all QSPI devices.</description>
        <documentation>
  @note
  It's expected that the application will only invoke this trap when images are running from the boot image bank in all QSPI devices.

  </documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeSwapTry" processor="CSR" tmi="5" trapset="IMAGEUPGRADE">
      <document>
        <description>Reset the chip, load and run using the images (if present) from the other image bank in all QSPI devices.</description>
        <documentation>
  @note
  It's expected that the application will only invoke this trap when images are running from the boot image bank in all QSPI devices, and there are 
  valid images in the other (new) image bank in all QSPI devices.
  
  </documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeSwapTryStatus" processor="CSR" tmi="6" trapset="IMAGEUPGRADE">
      <document>
        <description>Get the status of images (if present) running from the other image bank in all QSPI devices.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>Images successfully running from the other image bank. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
  </trap>
    <trap autogen="p0_non_block" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeSwapCommit" processor="CSR" tmi="7" trapset="IMAGEUPGRADE">
      <document>
        <description>Swap the image bank by modifying the boot image in the QSPI device.</description>
        <documentation>
  @note
  It's expected that the application will only invoke this trap when images are running from the other (new) image bank in all QSPI devices.
  
  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>Boot image successfully updated. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeHashInitialise" processor="CSR" tmi="8" trapset="IMAGEUPGRADE">
      <document>
        <description>Initialise a hash algorithm context for image upgrade. </description>
        <documentation>
  @note
  The returned context doesn't need to be interpreted by the application, but should be
  passed in the subsequent image upgrade hash traps to update and finalise the hash data to the same context.
  The created context can be freed by invoking ImageUpgradeHashFinalise trap with NULL hash pointer.
  </documentation>
        <comment />
      </document>
      <return type="hash_context_t">
        <document>
          <description>Hash context pointer. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="algo" type="hash_algo_t">
          <document>
            <description>Hash algorithm. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeHashSectionUpdate" processor="CSR" tmi="9" trapset="IMAGEUPGRADE">
      <document>
        <description>Update the image upgrade hash context with the image section data read from the other image bank. </description>
        <documentation>
  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the hash context is successfully updated, else FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="context" type="hash_context_t">
          <document>
            <description>Hash context. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="image_section" type="image_section_id">
          <document>
            <description>Image section.</description>
            <documentation />
            <comment />
          </document>
        </param>
     </params>
    </trap>
    <trap autogen="true" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeHashMsgUpdate" processor="CSR" tmi="10" trapset="IMAGEUPGRADE">
      <document>
        <description>Update the image upgrade hash context with the input message. </description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the image upgrade hash context is successfully updated, else FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="context" type="hash_context_t">
          <document>
            <description>Hash context. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="msg" type="const uint8 *">
          <document>
            <description>Pointer to the input message.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="msg_len_bytes" type="uint16">
          <document>
            <description>Length (in bytes) of the input message.</description>
            <documentation />
            <comment />
          </document>
        </param>
     </params>
    </trap>
    <trap autogen="true" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeHashFinalise" processor="CSR" tmi="11" trapset="IMAGEUPGRADE">
      <document>
        <description>Calculate the hash for the image upgrade hash context. </description>
        <documentation>
  @note
  The context can be freed by invoking ImageUpgradeHashFinalise trap with NULL hash pointer.
  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the image upgrade hash is successfully calculated, else FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="context" type="hash_context_t">
          <document>
            <description>Hash context. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="hash" type="uint8 *">
          <document>
            <description>Pointer to return the hash.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="hash_len_bytes" type="uint16">
          <document>
            <description>Length (in bytes) of the expected hash.</description>
            <documentation />
            <comment />
          </document>
        </param>
     </params>
    </trap>
    <trap autogen="p0_non_block" blocking="false" header="ImageUpgrade" lifestage="" name="ImageUpgradeCopy" processor="CSR" tmi="12" trapset="IMAGEUPGRADE">
    <document>
      <description>Copy unmodified image sections to the new image bank.</description>
      <documentation>
      
   @note
   The application should invoke this trap to copy unmodified image sections during an image upgrade from the boot image bank 
   to the new image bank before resetting the chip using the new image bank.
   It's expected that the application shall abort copying of the image sections by invoking ImageUpgradeAbortCommand() trap
   if the Host application aborts the image update in between.
   It's expected that the application will only invoke this trap when images are running from the boot image bank in all QSPI devices.
    </documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="ImageUpgrade" lifestage="" name="ImageUpgradeAbortCommand" processor="CSR" tmi="13" trapset="IMAGEUPGRADE">
    <document>
      <description>Abort an ongoing image upgrade trap activity.</description>
      <documentation>
      
   @note
   For now, only an ongoing ImageUpgradeCopy trap execution will be aborted by invoking ImageUpgradeAbortCommand trap.
    </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if aborting an ongoing image upgrade activity is successful, else FALSE. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="false" header="ImageUpgrade" lifestage="" name="ImageUpgradeAudio" processor="CSR" tmi="14" trapset="IMAGEUPGRADE">
    <document>
      <description>Erase the other image bank in the Audio QSPI and copy the new audio image from Apps QSPI to Audio QSPI device.</description>
      <documentation>
      
   @note
   The application should invoke this trap before invoking the trap to try the new image (ImageUpgradeSwapTry) to copy the new audio image 
   from the Apps QSPI to the Audio QSPI on platforms in which the audio is running from the external QSPI (flash) device.
   As Apps P0 has to get exclusive access to the Audio QSPI to do the copy, it's expected that the all the
   audio services are stopped before invoking this trap. 
   Also, no new audio services should be started before the Apps P0 returns the status of the trap in 
   #MessageImageUpgradeAudioStatus.
    </documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="false" header="ImageUpgrade" lifestage="" name="ImageUpgradeHashAllSectionsUpdate" processor="CSR" tmi="15" trapset="IMAGEUPGRADE">
    <document>
      <description>Update the image upgrade hash validation context data with all the unerased image sections in the other image bank.</description>
      <documentation>
      
   @note
   The application should invoke this trap to add all the image sections included in an image upgrade to the hash validation context created in
   ImageUpgradeHashInitialise() trap. Apps P0 shall update the hash context in the background and shall return the status of 
   the trap in #MessageImageUpgradeHashAllSectionsUpdateStatus.
   This trap should be invoked before copying (ImageUpgradeCopy trap) the missing image sections from the boot image bank to 
   the other image bank during a partial image upgrade.
   This trap should be invoked as an alternative to the ImageUpgradeHashSectionUpdate() trap in which the Apps P0 updates the input image section blocking the Apps P1. 
   It's not expected that the application will invoke both ImageUpgradeHashSectionUpdate() and ImageUpgradeHashAllSectionsUpdate() to add image sections to the 
   same hash context.
    </documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="context" type="hash_context_t">
          <document>
            <description>Hash context. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="UNIMPLEMENTED" name="StreamPartitionOverwriteSink" processor="CSR" tmi="0" trapset="PARTITION">
      <document>
        <description>Open a sink to erase and write to an external flash partition. This function will perform a flash erase on the entire partition specified and then provide a Sink to allow it to be written from the start.</description>
        <documentation>

  

  \note
  If the VM application uses the VM software watchdog functionality, BlueCore
  firmware automatically extends the VM software watchdog before the erase of
  an external serial flash memory. Erasing of the external serial flash memory
  is time consuming. This ensures that the VM application is given enough time
  to kick the VM software watchdog when the operation has completed.

  \note
  This trap expects all the partitions in the #PARTITION_SERIAL_FLASH 
  device to be sector aligned. If partition is not sector aligned then
  firmware will erase shared sectors (i.e., end of previous partition's 
  sector or start of next partition's sector).

</documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description>Sink if partition found and erased successfully, otherwise zero</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="device" type="partition_filesystem_devices">
          <document>
            <description>device to which to write, cannot be internal flash, see #partition_filesystem_devices</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="partition" type="uint16">
          <document>
            <description>partition number to overwrite</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Partition" lifestage="UNIMPLEMENTED" name="PartitionMountFilesystem" processor="CSR" tmi="1" trapset="PARTITION">
      <document>
        <description>Mount a partition to the union file system</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if partition found and mounted successfully, otherwise FALSE</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="device" type="partition_filesystem_devices">
          <document>
            <description>device to which to mount, see #partition_filesystem_devices </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="partition" type="uint16">
          <document>
            <description>number of partition to mount </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="priority" type="partition_filesystem_priority">
          <document>
            <description>mount at higher or lower priority to already mounted file systems, see #partition_filesystem_priority</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamAttSourceRemoveAllHandles" processor="CSR" tmi="6" trapset="ATT">
      <document>
        <description>Remove all attribute handles corresponding to an ATT connection registered with StreamAttSourceAddHandle. </description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>bool TRUE in case of successful deletion otherwise FALSE</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="cid" type="uint16">
          <document>
            <description> The channel id of the ATT connection</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Partition" lifestage="UNIMPLEMENTED" name="PartitionGetInfo" processor="CSR" tmi="2" trapset="PARTITION">
      <document>
        <description>Get information about a partition</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if partition found and queried successfully, otherwise FALSE</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="device" type="partition_filesystem_devices">
          <document>
            <description>device to query, see #partition_filesystem_devices </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="partition" type="uint16">
          <document>
            <description>number of partition to query </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="key" type="partition_info_key">
          <document>
            <description>specifies information requested, see #partition_info_key </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32 *">
          <document>
            <description>returned value as specified by #key</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Partition" lifestage="UNIMPLEMENTED" name="PartitionSetMessageDigest" processor="CSR" tmi="3" trapset="PARTITION">
      <document>
        <description>Set a message digest for a stream writing to flash partition. Message digest data will be copied and stored by the firmware. When a flash partition is written to, the first word is not immediately written. Instead it is saved in RAM until the stream is closed. At this point the flash partition is read back and verified against the stored message digest. If the verification is successful, the first word is written to flash. This protects against partly or incorrectly written partitions. If this trap is not called against a partition write sink, the verification will not be performed, but the first word will not be written until the stream is closed, protecting against partly written partitions.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if sink is valid, data is correct length and message digest set successfully, otherwise FALSE</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>sink that is writing to the partition </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="md_type" type="partition_message_digest_type">
          <document>
            <description>the type of message digest, see #partition_message_digest_type </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="data" type="uint16 *">
          <document>
            <description>pointer to message digest </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="len" type="uint16">
          <document>
            <description>length of message digest</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="UNIMPLEMENTED" name="TransformRtpEncode" processor="CSR" tmi="8" trapset="KALIMBA">
      <document>
        <description>Packs Audio frames from the DSP into RTP packets. This trap attaches RTP stamping for the Audio packets arriving from DSP. It configures default codec type as SBC and also sets payload header size for SBC. The sequence of function calls in a VM Application which is acting as an encoder would be: 1. Call the TransformRtpEncode trap. 2. Using the TransformConfigure trap configure the required parameters: 2.1 Codec type (APTX / SBC / ATRAC / MP3 / AAC) 2.2 Manage Timing (Yes/No) 2.3 Payload header size 2.4 SCMS Enable (Yes/No) 2.5 SCMS Bits 2.6 Frame period 2.7 Packet size 3. Call the TransformStart trap.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Transform">
        <document>
          <description>The transform if successful, or zero on failure.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The media Source. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description>The sink receiving the Audio Digital stream (typically corresponding to a Kalimba port).</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Transform" lifestage="UNIMPLEMENTED" name="TransformRtpDecode" processor="CSR" tmi="9" trapset="KALIMBA">
      <document>
        <description>Unpacks Audio frames from Audio-RTP packets. It configures default codec type as SBC and also sets payload header size for SBC.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Transform">
        <document>
          <description>The transform if successful, or zero on failure.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source containing the Audio Digital stream (typically corresponding to a Kalimba port). </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description>The media Sink.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Loader" lifestage="UNIMPLEMENTED" name="LoaderModeEnter" processor="CSR" tmi="69" trapset="CORE">
      <document>
        <description>This API will reboot the firmware in "loader" mode. This trap can be used to trigger a DFU process based on an external event, for example: " A combination of keys being pressed at the device".</description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Partition" lifestage="UNIMPLEMENTED" name="PartitionGetRawSerialSource" processor="CSR" tmi="4" trapset="PARTITION">
      <document>
        <description>This API will return the source with the contents of the specified raw serial partition </description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Source">
        <document>
          <description>The source associated with the raw partition stream.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="device" type="uint16">
          <document>
            <description>device to query, see #partition_filesystem_devices </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="partition" type="uint16">
          <document>
            <description>number of partition to read raw data</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Feature" lifestage="" name="VmSoftwareWdKick" processor="CSR" tmi="70" trapset="CORE">
      <document>
        <description>By default, the VM software watchdog is disabled. Calling this trap with a valid timeout value will initiate/reset the VM software watchdog timer. If the VM software watchdog timer expires, then a VM Panic will be raised with Panic code PANIC_VM_SW_WD_EXPIRED and it will reset the chip.</description>
        <documentation>

   

    \note
    The purpose of the 3-stage disable sequence is to ensure that rogue
    applications do not randomly disable the watchdog by kicking it with some
    single disable codes. The return value of the this trap is designed to
    indicate to the user that either the watchdog kick has succeeded due to a
    valid timeout within the specified range or that the entire 3-stage disable
    sequence has succeeded. Returning TRUE for a call on the first disable sequence
    alone would actually go against the notion that the operation of disabling the
    watchdog has succeeded. In-fact at that moment (after having kicked with the
    first disable code), there is no guarantee of whether the disabling is either
    being done deliberately (in a valid manner) or the kick has been called by
    some rouge code. Hence, unless the entire disable operation does not succeed,
    the VM must not return TRUE.

</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>returns TRUE, 1.Whenever the VM software watchdog is kicked i.e., valid range (1-300 seconds). Eg: VmsoftwareWDKick(20); - Returns TRUE 2.Whenever the 3-stage disable sequence is followed as per the requirement. Eg: VmsoftwareWDKick(20); - Returns TRUE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE1); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE2); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE3); - Returns TRUE returns FALSE, 1.Whenever the VM software watchdog timeout doesn't fall under 1-300 seconds range. 2.Whenever the VM software watchdog doesn't follow the 3-stage sequence or disabling the VM software watchdog fails. Eg: VmsoftwareWDKick(20); - Returns TRUE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE2); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE1); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE3); - Returns FALSE</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="timeout" type="uint16">
          <document>
            <description>The timeout period in seconds, in the range 1 to 300 or the specific disable codes VM_SW_WATCHDOG_DISABLE_CODE1, VM_SW_WATCHDOG_DISABLE_CODE2, VM_SW_WATCHDOG_DISABLE_CODE3.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="UNIMPLEMENTED" name="StreamReformatSerialFlashSink" processor="CSR" tmi="0" trapset="REFORMATSQIF">
      <document>
        <description>Open a sink to erase and write to an external serial flash. This function will perform a chip erase on the entire serial flash including partition table and then provide a Sink to allow it to be written from the start.</description>
        <documentation>

  

  \note
  If the VM software watchdog is not disabled, BlueCore firmware
  extends the VM software watchdog before chip erase operation. Erase
  to an external serial flash is time consuming. This ensures that the
  VM application is given enough time to kick the VM software watchdog
  once erase to an external serial flash is over.
</documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description>The sink associated with reformatting of the serial flash.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="device" type="partition_filesystem_devices">
          <document>
            <description>device which needs to be reformatted, cannot be internal flash</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Loader" lifestage="UNIMPLEMENTED" name="LoaderPerformDfuFromSqif" processor="CSR" tmi="71" trapset="CORE">
      <document>
        <description>Reboots the firmware in "loader" mode to perform DFU from SQIF operation</description>
        <documentation>

  This trap can be used to trigger the DFU process from SQIF after the
  VM application writes the DFU file onto one of the serial flash
  partitions. Partition type should be a raw partition type.

  Once the DFU process is over and the device reboots back into "stack" mode,
  the VM application's system task then receives MESSAGE_DFU_SQIF_STATUS message
  containing the status of DFU operation.
  If there is a power loss during the DFU process, the VM application will
  not receive the MESSAGE_DFU_SQIF_STATUS message.

  \note
  This trap will only work if the loader supports the DFU process from SQIF.
  If the "loader" does not have the knowledge of the DFU process from SQIF, then
  this trap will reboot the device into "loader" mode and the loader will
  wait for wired DFU command from the host.

  \note
  This trap performs basic validation of the partition number and the DFU
  file and reboots the device into the "loader" mode. Hence, the control
  does not comes back to the VM application. If the device is not rebooted into
  the "loader" mode due to validation failure, then the controls returns back
  to the VM application and appropriate action should be taken by the
  VM application.

  \note
  A value of 0xFFFD, 0xFFFE and 0xFFFF MUST not be used for partition
  number since these values are reserved for internal use. If these
  values are passed, then trap will return to the VM application
  without any impact.

</documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="partition" type="uint16">
          <document>
            <description>A valid SQIF partition containing the DFU file</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Message" lifestage="UNIMPLEMENTED" name="MessageInfraredTask" processor="CSR" tmi="0" trapset="INFRARED">
      <document>
        <description>Register a task to handle infrared messages.</description>
        <documentation>

  </documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The old task (or zero).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task which will receive the messages.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Infrared" lifestage="UNIMPLEMENTED" name="InfraredConfigure" processor="CSR" tmi="1" trapset="INFRARED">
      <document>
        <description>Control the infrared receiver </description>
        <documentation>

    More detailed information on the keys and values can be found in irfrared_if.h
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the key is valid and the input value is in valid range, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="infrared_config_key">
          <document>
            <description>Which Infrared parameter to configure Parameters are defined in #infrared_config_key </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32">
          <document>
            <description>The value the parameter specified by "key" should be set to </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Loader" lifestage="DEAD" name="LoaderUpgrade" processor="CSR" tmi="0" trapset="LDRUPGRADE">
      <document>
        <description>Performs the "Loader Upgrade" operation and reboots the device in stack mode</description>
        <documentation>

  This trap is used to trigger the upgrade of loader using new loader files 
  stored as application files in internal flash file system. The File System 
  containing the loader file in app format (loader_xdv.app and loader_xpv.app) 
  would have been already written to the device using classic DFU method.

  If there is any failure during verification phase (before starting the upgrade) 
  an error code indicating the reason for failure will be returned. If there is
  any failure due to flash write error during upgrade, then there are chances that 
  the existing loader is corrupted and device could be in a non-bootable state. 
  The device can be recovered using any of the alternate means only (for
  example SPI).

  \note
  Device will reboot in stack after writing the new loader file to the internal 
  flash and no status will be returned to VM application. Invoking this trap 
  again on a device which is already upgraded successfully will return an 
  error code indicating that the loader is already upgraded.
 

  </documentation>
        <comment />
      </document>
      <return type="ldr_upgrade_failure_status">
        <document>
          <description>the failure code #ldr_upgrade_failure_status</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Ble3dd" lifestage="DEAD" name="Ble3ddConfigure" processor="CSR" tmi="0" trapset="BLE3DD">
      <document>
        <description>Enable the 3DD controls</description>
        <documentation>

  

  More detailed information on the keys and values can be found in ble3dd_if.h
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the key is valid and the input value is in valid range, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="ble3dd_config_key">
          <document>
            <description>Which 3dd parameter to configure Parameters are defined in #ble3dd_config_key </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32">
          <document>
            <description>The value the parameter specified by "key" should be set to</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Codec_" lifestage="" name="CodecSetIirFilter16Bit" processor="CSR" tmi="0" trapset="IIR16BIT">
      <document>
        <description>IIR Filter coefficients are configurable on some Bluecore variants. This trap is used to program set of 16-bit-coefficients to multiple IIR filters on ADC channels. This trap is licensed and can be used only with licensed devices.</description>
        <documentation>
  Note that the DSP operator framework must be loaded before setting the configuration parameters.
  Check OperatorFrameworkEnable documentation for more details.

  Example:
  if channel_mask = 0x0003, IIR Filters of ADC A and ADC B are updated with the
  given set of coefficients.

</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the filter was configured/disabled as requested, else FALSE. This will return FALSE if IIR feature is not licensed. An invalid coefficient address or an invalid mask will also result in a FALSE return.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="channel_mask" type="uint16">
          <document>
            <description>ADC channel bit mask to configure IIR coefficients on multiple ADC channels. It is a bitmask with 6 valid bits, each bit representing an ADC channel. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="enable" type="bool">
          <document>
            <description>Enables (TRUE) or disables (FALSE) the filter. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="iir_coefficients" type="IIR_COEFFICIENTS *">
          <document>
            <description>A pointer to structure (IIR_COEFFICIENTS) containing 16-bit IIR coefficients.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="UNIMPLEMENTED" name="StreamPartitionResumeSink" processor="CSR" tmi="5" trapset="PARTITION">
      <document>
        <description>Resume external flash sink partition after a controlled power failure.</description>
        <documentation>

  

  This VM trap is used to resume sink stream to write into external flash
  partition which got interrupted while writing previously. This trap returns
  the sink stream by reopening the stream for the interrupted external flash
  partition. This trap will not erase the contents of the partition.
  See #PartitionSinkGetPosition trap description to know how to retrieve the
  sink position from which the data can be written.

</documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description>Sink if partition found or sink already exists, else return NULL </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="device" type="partition_filesystem_devices">
          <document>
            <description>device to which to write, cannot be internal flash, see #partition_filesystem_devices. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="partition_no" type="uint16">
          <document>
            <description>partition number of the sink partition to be resumed. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="first_word" type="uint16">
          <document>
            <description>first word of the sink partition to be resumed.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Partition" lifestage="UNIMPLEMENTED" name="PartitionSinkGetPosition" processor="CSR" tmi="6" trapset="PARTITION">
      <document>
        <description>Get the sink position of the partition sink stream.</description>
        <documentation>

  

  This VM trap is used to get the sink position of the specified sink partition in 
  octets. Firmware returns a sink position from which, each word has a value of 
  0xFFFF till the end of the partition. Firmware assumes that the partition 
  contents before the sink position (except first word) are successfully written.

</documentation>
        <comment />
      </document>
      <return type="uint32">
        <document>
          <description>sink position of the specified sink partition.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>sink stream.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Feature" lifestage="" name="FeatureVerifyLicense" processor="CSR" tmi="72" trapset="CORE">
      <document>
        <description>This trap checks whether a feature is licensed for a device.</description>
        <documentation>

    

    This trap verifies whether a device is licensed to use a given feature.
 
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if device has valid license for feature, else FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="feature" type="feature_id">
          <document>
            <description>Identifier for a given feature. Refer #feature_id</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Ps" lifestage="UNIMPLEMENTED" name="PsStoreFsTab" processor="CSR" tmi="7" trapset="PARTITION">
      <document>
        <description>Copy the specified memory buffer into PSKEY_FSTAB within the persistent store</description>
        <documentation>

  The function operates in a similar manner to \see PsStore but only operates
  on the PSKEY_FSTAB persistent store key. The parameter commit is used to set
  which store the value will be written to. The data to write must always be
  passed to the function.

  </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the operation succeeded or FALSE if it failed</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="buff" type="const void *">
          <document>
            <description>The memory buffer to copy data from. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="words" type="uint16">
          <document>
            <description>The number of words to copy. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="commit" type="bool">
          <document>
            <description>Write the new FSTAB to non-volatile memory or not. If FALSE then the new FSTAB will only be stable across warm reboots; this feature can be used to enable the newly upgrade application to perform system checks before setting the FSTAB in the non-volatile store.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Ps" lifestage="UNIMPLEMENTED" name="PsSetStore" processor="CSR" tmi="73" trapset="CORE">
      <document>
        <description>Set the PS Store that are used for subsequent PS operations </description>
        <documentation>

  \note
  Any store in the BlueCore firmware can be set as default using this trap.
</documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="store" type="PsStores">
          <document>
            <description>The PS store to be used</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Ps" lifestage="UNIMPLEMENTED" name="PsGetStore" processor="CSR" tmi="74" trapset="CORE">
      <document>
        <description>Returns the current PS store used for PS operations. </description>
        <documentation />
        <comment />
      </document>
      <return type="PsStores">
        <document>
          <description>The PS store currently used.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorCreate" processor="CSR" tmi="0" trapset="OPERATOR">
      <document>
        <description>Creates a new operator that instantiates the requested capability </description>
        <documentation>
  Note that the DSP software/operator framework must be loaded before creating an operator. 
  Check OperatorFrameworkEnable documentation for more details.

  If the loaded DSP software supports the requested capability then DSP creates
  an operator in stopped state. If it does not support the requested capability,
  then this trap returns zero(0).

  @note
  If DSP is already loaded with DSP software that does not support operators
  then BlueCore firmware returns zero(0) on a call to this trap, till the DSP
  gets powered off.
</documentation>
        <comment />
      </document>
      <return type="Operator">
        <document>
          <description>Operator ID if the operator was created successfully, zero(0) otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="cap_id" type="uint16">
          <document>
            <description>Type of the operator (or Capability ID). </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="num_keys" type="uint16">
          <document>
            <description>Number of key-value pairs specified. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="info" type="OperatorCreateKeys *">
          <document>
            <description>Points to list of key-value pairs for setting certain parameters for the operator at the time of its creation. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorDestroyMultiple" processor="CSR" tmi="1" trapset="OPERATOR">
      <document>
        <description>Destroys one or more operators </description>
        <documentation>

  This trap destroys all the operator(s) passed to it as a list. If DSP fails
  to destroy one of the operators then no attempt is made to destroy the
  subsequent operator(s) in the list. The number of successfully destroyed 
  operator(s) is placed in @a success_ops parameter, which is passed by
  reference.
  
  @note
  VM application must handle the allocation and de-allocation of memory space
  for API parameters. If an operator is running, any attempt to destroy the
  operator will fail. An operator can only be destroyed when it has been
  stopped. To destroy a single operator, refer # OperatorDestroy.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if all operator(s) were successfully destroyed, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="n_ops" type="uint16">
          <document>
            <description>Number of operators to destroy </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="oplist" type="Operator *">
          <document>
            <description>List of operators to destroy </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="success_ops" type="uint16 *">
          <document>
            <description>Number of successfully destroyed operators, which is passed by reference. If set to NULL then this parameter is ignored and application will only know that some (or all) operators could not be destroyed from the return status. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorStartMultiple" processor="CSR" tmi="2" trapset="OPERATOR">
      <document>
        <description>Starts one or more operators </description>
        <documentation>

  This starts all the operator(s) passed to it as a list. If DSP fails to
  start one of the operators then no attempt is made to start the subsequent
  operator(s). The number of successfully started operator(s) is placed in
  @a success_ops parameter, which is passed by reference.

  @note
  VM application must handle the allocation and de-allocation of memory space
  for API parameters. It is permitted to start an operator that has already been
  started. Starting an operator that has nothing connected to it, or has
  insufficient connections, may fail (depending on the capability).
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if all operator(s) were successfully started, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="n_ops" type="uint16">
          <document>
            <description>Number of operators to start </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="oplist" type="Operator *">
          <document>
            <description>List of operators to start </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="success_ops" type="uint16 *">
          <document>
            <description>Number of successfully started operators, which is passed by reference. If set to NULL then this parameter is ignored and application will only know that some (or all) operators could not be started from the return status. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorStopMultiple" processor="CSR" tmi="3" trapset="OPERATOR">
      <document>
        <description>Stops one or more operators </description>
        <documentation>

  This API stops all the operator(s) passed to it as a list. If DSP fails to 
  stop one of the operators then no attempt is made to stop the subsequent
  operator(s). The number of successfully stopped operator(s) is placed
  in @a success_ops parameter only if it is not NULL.

  @note
  VM application must handle the allocation and de-allocation of memory space
  for API parameters. It is permitted to stop an operator that has never been
  started or has already been stopped.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if all operator(s) were successfully stopped, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="n_ops" type="uint16">
          <document>
            <description>Number of operators to stop </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="oplist" type="Operator *">
          <document>
            <description>List of operators to stop </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="success_ops" type="uint16 *">
          <document>
            <description>Number of successfully stopped operators, which is passed by reference. If set to NULL then this parameter is ignored and application will only know that some (or all) operators could not be stopped from the return status. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorResetMultiple" processor="CSR" tmi="4" trapset="OPERATOR">
      <document>
        <description>Resets one or more operators </description>
        <documentation>

  This API resets all the operator(s) passed to it as a list. If DSP fails
  to reset one of the operators then no attempt is made to reset the subsequent
  operator(s). The number of operators have successfully been reset is placed
  in @a success_ops parameter only if it is not NULL.

  @note
  VM application must handle the allocation and de-allocation of memory space
  for API parameters. It is permitted to reset an operator that has never been
  started or has already been stopped.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if all the operator(s) have successfully been reset, FALSE otherwise. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="n_ops" type="uint16">
          <document>
            <description>Number of operators to reset </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="oplist" type="Operator *">
          <document>
            <description>List of operators to reset </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="success_ops" type="uint16 *">
          <document>
            <description>Number of operators have successfully been reset, which is passed by reference. If set to NULL, then this parameter is ignored and application will only know that some (or all) operators could not be reset from the return status. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorMessage" processor="CSR" tmi="5" trapset="OPERATOR">
      <document>
        <description>Sends a message to the operator </description>
        <documentation>
  @note
  VM application must handle the allocation and de-allocation of memory space
  for API parameters. Determining the size of the message to be sent and that
  of the corresponding response-message to be received depends on the
  respective structures being used for the message to be sent and received.

  @note
  If DSP is already loaded with DSP software that does not support operators
  then BlueCore firmware returns FALSE for any operator message request
  till DSP gets powered off.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if it gets a response from the specific operator, otherwise FALSE. The messages that are available and their meaning depend on the specific capability that the operator instantiates.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="opid" type="Operator">
          <document>
            <description>Operator to which VM application sends a message </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param array="true" name="send_msg" type="const uint16 *">
          <document>
            <description>Message to the operator </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="send_len_words" type="uint16">
          <document>
            <description>Length of the message to be sent in units of uint16s </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param array="true" direction="OUT" name="recv_msg" type="uint16 *">
          <document>
            <description>Message response, which will be received from the DSP in response to the sent message </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="recv_len_words" type="uint16">
          <document>
            <description>Length of the response message in units of uint16s </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageOperatorTask" processor="CSR" tmi="6" trapset="OPERATOR">
      <document>
        <description>Registers a task to get the unsolicited messages from operator </description>
        <documentation>

  

  VM application should register a task for each operator to get the
  unsolicited messages from the operator. The operator posts unsolicited
  messages to the registered task, if they have any.
</documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The previous task, if any, or zero otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="opid" type="Operator">
          <document>
            <description>operator which registers the task </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="task" type="Task">
          <document>
            <description>Task which will receive the unsolicited messages from the operator</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Stream" lifestage="" name="StreamSourceFromOperatorTerminal" processor="CSR" tmi="7" trapset="OPERATOR">
      <document>
        <description>Gets operator source stream for the operator </description>
        <documentation>

  This trap checks validity of the operator and its specified source terminal
  number. If the supplied input parameters are valid then it provides the
  operator source stream.

  @note
  This API returns zero(0) in either one of the below mentioned scenarios:
  1. Operator is not valid
  2. Source terminal ID is not valid with regards to the supplied operator.
</documentation>
        <comment />
      </document>
      <return type="Source">
        <document>
          <description>Operator source stream, if it is successful, otherwise zero(0).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="opid" type="Operator">
          <document>
            <description>Operator, which was created in the DSP </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="terminal" type="uint16">
          <document>
            <description>Source stream connection number for the specified operator </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="true" header="Stream" lifestage="" name="StreamSinkFromOperatorTerminal" processor="CSR" tmi="8" trapset="OPERATOR">
      <document>
        <description>Gets operator sink stream for the operator </description>
        <documentation>

  This API checks validity of the operator and its specified sink terminal
  number. If the supplied input parameters are valid then it provides the
  operator sink stream.

  @note
  This API returns zero(0) in either one of the below specified scenarios:
  1. Operator is not valid
  2. Sink terminal ID is not valid with regards to the supplied operator.
</documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description>Operator sink stream, if it is successful, otherwise zero(0).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="opid" type="Operator">
          <document>
            <description>Operator, which was created in the DSP </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="terminal" type="uint16">
          <document>
            <description>Sink stream connection number for the specified operator </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorBundleLoad" processor="CSR" tmi="9" trapset="OPERATOR">
      <document>
        <description>Load a "bundle" file containing one or more audio processing capabilities into the audio subsystem.</description>
        <documentation>  This causes code to be loaded from a file in the application subsystem's filesystem
  into the audio subsystem, ready for OperatorCreate() to be invoked to instantiate any of the newly available
  capabilities (a .dkcs file may implement more than one capability). The downloaded bundle will occupy resources
  until unloaded with OperatorBundleUnload(), or the audio subsystem is shut down with OperatorFrameworkEnable().
  It is not possible to load or unload capabilities within a single .dkcs selectively.
</documentation>
        <comment />
      </document>
      <return type="BundleID">
        <document>
          <description>A handle for the resources occupied by the loaded code which can be passed to OperatorBundleUnload().</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="index" type="FILE_INDEX">
          <document>
            <description>Specifies a .dkcs file containing capability code.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="processor" type="uint16">
          <document>
            <description>Indicates which audio processor the code is intended to run on.
 FIXME: we don't know yet if this is a hard restriction or just a hint.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorBundleUnload" processor="CSR" tmi="10" trapset="OPERATOR">
      <document>
        <description>Unload previously loaded capability/ies from the audio subsystem.</description>
        <documentation></documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the resources were freed, FALSE if not.
 This call can fail if any operators are currently instantiated from this bundle.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
         <param name="bundle" type="BundleID">
          <document>
            <description>A BundleID previously returned from OperatorBundleLoad().</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorFrameworkConfigurationSet" processor="CSR" tmi="11" trapset="OPERATOR">
      <document>
        <description>Sets DSP operator framework configuration parameters </description>
        <documentation>
Note that the DSP operator framework must be loaded before setting the configuration parameters. 
Check OperatorFrameworkEnable documentation for more details.
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the DSP operator framework parameters have successfully been set, FALSE otherwise.</description>
           <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="uint16">
          <document>
            <description>Configuration parameter identifier </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="send_msg" type="const uint16 *">
          <document>
            <description>Message containing configuration parameters to be set </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="send_len_words" type="uint16">
          <document>
            <description>Length of message to be sent in units of uint16s </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorFrameworkConfigurationGet" processor="CSR" tmi="12" trapset="OPERATOR">
      <document>
        <description>Gets DSP operator framework configuration parameters </description>
        <documentation>
Note that the DSP operator framework must be loaded before getting the configuration parameters. 
Check OperatorFrameworkEnable documentation for more details.

  @note
  send_msg specifies more about what exactly is to be fetched.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if it gets a response from the DSP framework, otherwise FALSE.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="uint16">
          <document>
            <description>Configuration parameter identifier </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="send_msg" type="const uint16 *">
          <document>
            <description>Message to DSP framework for getting the configuration parameters </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="send_len_words" type="uint16">
          <document>
            <description>Length of message to be sent in units of uint16s </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param array="true" direction="OUT" name="recv_msg" type="uint16 *">
          <document>
            <description>The response message containing the requested configuration parameters </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="recv_len_words" type="uint16">
          <document>
            <description>Length of the response message in units of uint16s </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorFrameworkEnable" processor="CSR" tmi="13" trapset="OPERATOR">
      <document>
        <description>Loads DSP operator framework / powers-off DSP </description>
        <documentation>

  @note
  Multiple VM libraries or the application can load and power-off DSP
  independently. All the VM libraries and application MUST follow the
  below sequences to reduce system power consumption by powering-off DSP.

  Step-1: OperatorFrameworkEnable (ON);
  Step-2: Create operators / Download a new capability
  Step-3: Perform operator actions / Send message to operators
  Step-4: Destroy operators / Remove downloaded capability
  Step-5: OperatorFrameworkEnable (OFF);

  The VM library / application cannot assume DSP being powered off even
  after receiving a TRUE return from OperatorFrameworkEnable(OFF) because
  some other part of the application might keep it on.

  The VM library / application should not rely on getting a FALSE return for
  OperatorFrameworkEnable(OFF) as the FALSE return could be because of an
  error made a long time ago. It is at most an opportunity to detect errors.
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if DSP operator framework is loaded / unloaded successfully, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="state" type="OperatorFrameworkPowerState">
          <document>
            <description>DSP operator framework power state for specific DSP core </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageOperatorFrameworkTask" processor="CSR" tmi="14" trapset="OPERATOR">
      <document>
        <description>Registers a task to get the unsolicited messages from DSP framework </description>
        <documentation>
Note that the DSP operator framework must be loaded before registering the task to receive
unsolicited messages. Check OperatorFrameworkEnable documentation for more details.
        </documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The previous task, if any, or zero otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>Task which will receive the unsolicited messages from DSP framework </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageStreamTaskFromSource" processor="CSR" tmi="41" trapset="STREAM">
      <document>
        <description>Associate a task with a source.</description>
        <documentation>

  

  @note
  # Task cannot be registered for operator source which is not
    connected to a sink.
  # Task cannot be registered for operator source which is connected
    to an operator sink.
  # Task can be registered on all streams irrespective of whether
    they are connected or not.
</documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The previous task for this source, if any, or zero(0) otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to use </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="task" type="Task">
          <document>
            <description>The task to associate with</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageStreamGetTaskFromSource" processor="CSR" tmi="42" trapset="STREAM">
      <document>
        <description>Get the task currently associated with a source. </description>
        <documentation />
        <comment />
      </document>
      <return type="Task">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to use.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageStreamTaskFromSinkHiPri" processor="CSR" tmi="43" trapset="STREAM">
      <document>
        <description>Associate a Task with a Sink to be run at high priority</description>
        <documentation>
 When asynchronous data flow notifications (MessageMoreData, MessageMoreSpace) are 
 received for any Source or Sink associated with this Task, the handler function
 is run immediately in a special mode that "pre-empts" any non-fast blocking 
 trap that may currently be in progress.  
 
 @note: The task handler may only call non-blocking or fast blocking traps while
 running in this mode; any other trap call will result in an assertion failure.
 
 However, in every other way, this Task is like any other.  In particular, it 
 can receive and process other messages, and it *can* call non-fast blocking
 traps when processing non-system messages because it won't process these in 
 the high-priority context.
 
  @note
  # Task cannot be registered for operator sink which is not
     connected to a source.
  # Task cannot be registered for operator sink which is connected
     to an operator source.
  # Task can be registered on all streams irrespective of whether
     they are connected or not.
</documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The previous task for this sink, if any, or zero(0) otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The sink to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="task" type="Task">
          <document>
            <description>The task to associate.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageStreamTaskFromSourceHiPri" processor="CSR" tmi="44" trapset="STREAM">
      <document>
        <description>Associate a task with a source to be run at high priority</description>
        <documentation>
 When asynchronous data flow notifications (MessageMoreData, MessageMoreSpace) are 
 received for any Source or Sink associated with this Task, the handler function
 is run immediately in a special mode that "pre-empts" any non-fast blocking 
 trap that may currently be in progress.  
 
 @note: The task handler may only call non-blocking or fast blocking traps while
 running in this mode; any other trap call will result in an assertion failure.
 
 However, in every other way, this Task is like any other.  In particular, it 
 can receive and process other messages, and it *can* call non-fast blocking
 traps when processing non-system messages because it won't process these in 
 the high-priority context.
 
  @note
  # Task cannot be registered for operator source which is not
    connected to a sink.
  # Task cannot be registered for operator source which is connected
    to an operator sink.
  # Task can be registered on all streams irrespective of whether
    they are connected or not.
</documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The previous task for this source, if any, or zero(0) otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to use </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="task" type="Task">
          <document>
            <description>The task to associate with</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="nfc" lifestage="" name="NfcSendPrim" processor="APP" tmi="0" trapset="NFC">
      <document>
         <description> Send an NFC primitive from APP P1 to APP P0. It is 
            recommended not to use this function directly.  A separate function 
            is provided to send each primitive, use these instead as it 
            abstracts the details that may change. The implementation of these 
            function is provided in nfc.c and nfc.h.
             </description>
          <documentation />
          <comment />
      </document>
      <return type="void">
        <document>
          <description />
            <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="msg" type="void *">
          <document>
            <description> Content of an NFC primitive.  The nfc primitives are 
            defined in the header file "nfc_prim.h".  
            </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamNfcSink" processor="APP" tmi="1" trapset="NFC">
      <document>
         <description> Create an NFC Stream object and return the associated
            sink. This is used for the data information to be sent to the NFC
            module on P0.
             </description>
          <documentation />
          <comment />
      </document>
      <return type="Sink">
        <document>
          <description />
            <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageNfcTask" processor="APP" tmi="1" trapset="NFC">
      <document>
          <description> Register a task to receive NFC primitives on APP P1 sent 
            from APP P0. The nfc primitives to be received are defined in the 
            header file "nfc_prim.h".
              </description> 
          <documentation/>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description> The old task (or zero). </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description> The task which will receive the 
                messages.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="voltsense" lifestage="" name="XioMeasureVoltage" processor="APP" tmi="10" trapset="XIO">
      <document>
        <description>API to measure voltage on an XIO. </description>
        <documentation>
    PIO setup is not handled by this trap but can be done at any point. XIO pads need to be configured as analogue pins.
This is done by using PioSetMapPins32Bank to put the PIO under HW control and then PioSetFunction to set the function to
XIO_ANALOGUE.
        </documentation>
        <comment />
      </document>
      <return type="trap_voltsense_result">
        <document>
          <description>result, success, failure, failure with reason</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task to which the message containing the voltage reading will be delivered</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="first_xio" type="xio_source">
          <document>
            <description>xio or first xio in difference pair to use for input</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="second_xio" type="xio_source">
          <document>
            <description>xio or second xio in difference pair to use for input</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="voltage_gain" type="vga_gain">
          <document>
            <description>VGA value, 0.85, 1, 2, 4, 8</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="voltsense" lifestage="" name="DacEnable" processor="APP" tmi="11" trapset="XIO">
      <document>
        <description>Enables or disables the DAC
        </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>True if 'enable' or 'disable' has occurred.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="enable" type="bool">
          <document>
            <description>TRUE if setting up the DAC or FALSE if releasing the DAC. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="voltsense" lifestage="" name="DacSetGain" processor="APP" tmi="12" trapset="XIO">
      <document>
        <description>Sets the DAC buffer gain to the value supplied. 
                     Note the DAC buffer gain will be either 1 or 0.9.
        </description>
        <documentation>
    PIO setup is not handled by this trap but can be done at any point. XIO 12 needs to be configured as analogue pin.
This is done by using PioSetMapPins32Bank to put the PIO under HW control and then PioSetFunction to set the function to
XIO_ANALOGUE.
        </documentation>
        <comment />
      </document>
      <return type="trap_voltsense_result">
        <document>
          <description>result, success, or failure with reason</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="gain" type="dac_buffer_gain">
          <document>
            <description>gain, 0.9, 1</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="voltsense" lifestage="" name="DacSetLevel" processor="APP" tmi="13" trapset="XIO">
      <document>
        <description>Sets the output level on the DAC to the value supplied. 
                     Note that the auxiliary DAC level drops to 0V when BlueCore enters
                     deep sleep for power-saving.
        </description>
        <documentation />
        <comment />
      </document>
      <return type="trap_voltsense_result">
        <document>
          <description>result, success, or failure with reason</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="level" type="uint16">
          <document>
            <description>Required Level (10 bit digital value)</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Pio" lifestage="" name="PioSetWakeupStateBank" processor="CSR" tmi="75" trapset="CORE">
      <document>
        <description>Controls the state for each PIO line that will wake 
the chip from deep sleep. The PIO lines must already have 
been configured to wake the chip. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description> The bank index of the PIO lines. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="mask" type="uint32">
          <document>
            <description> Bitmask to select the PIO lines to update within the given bank. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32">
          <document>
            <description> Each bit corresponds to a PIO line in the selected bank. 
Setting a bit high will result in the chip waking when that 
line goes high, setting the bit low will cause the chip to 
wake when the line goes low. Default is wakeup when line goes high.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Pio" lifestage="" name="PioSetDeepSleepEitherLevelBank" processor="CSR" tmi="76" trapset="CORE">
      <document>
        <description>Allows the chip to deep sleep irrespective of the level of the PIO 
lines. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="bank" type="uint16">
          <document>
            <description> The bank index of the PIO lines. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="mask" type="uint32">
          <document>
            <description> Bitmask to select the PIO lines to update within the given bank. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32">
          <document>
            <description> Each bit corresponds to a PIO line in the selected bank. 
Traditionally BlueCore chips will stay out of deep sleep when 
any PIO line configured as an input is high. This behaviour can be 
modified with PioSetWakeupStateBank()
Setting a bit high will result in the chip waking when that 
line goes high, setting the bit low will cause the chip to 
wake when the line goes low. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Vm" lifestage="" name="VmDeepSleepWakeSourcesEnable" processor="CSR" tmi="77" trapset="CORE">
      <document>
        <description>Enables or disables some deep sleep wake sources. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the operation was successful, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="wake_source" type="vm_wake_source_type">
          <document>
             <description>Wake source ID to enable or disable.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="en" type="bool">
          <document>
             <description>TRUE if wake source should be enabled, FALSE otherwise. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamCsbSink" processor="CSR" tmi="0" trapset="CSB">
      <document>
        <description>Find the Sink corresponding to a CSB transmitter stream.</description>
        <documentation />
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description> Sink if CSB transmitter stream exists for a given lt_addr otherwise 
NULL.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="lt_addr" type="uint16">
          <document>
            <description>The logical transport address used for CSB link.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamCsbSource" processor="CSR" tmi="1" trapset="CSB">
      <document>
        <description>Find the Source corresponding to a CSB receiver stream.</description>
        <documentation />
        <comment />
      </document>
      <return type="Source">
        <document>
          <description> Source if CSB receiver stream exists for a given parameters otherwise 
NULL.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param direction="IN" name="remote_addr" type="const bdaddr *">
          <document>
            <description>The remote device Bluetooth address.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="lt_addr" type="uint16">
          <document>
            <description>The logical transport address used for CSB link.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Csb" lifestage="" name="CsbReceiverSetAfhMap" processor="CSR"  tmi="2" trapset="CSB">
      <document>
        <description>Apply AFH map data on CSB receiver. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>False if addr and lt_addr do not identify an existing CSB transport otherwise TRUE. \note 1. If the afh_instant provided is already passed then new channel map is applied immediately. 2. If afh_instant for previous set channel map command is not reached and new command is received, then new channel map and instant will overwrite the previous one. In this case the older channel map will not be applied. Firmware will only store and apply the latest channel map at it's instant. 3. In order to apply AfhMap, minimum 20 channels are required to be set otherwise AfhMap will not be applied.
          </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="remote_addr" type="const bdaddr *">
          <document>
            <description>The remote device bluetooth address. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="lt_addr" type="uint16">
          <document>
            <description>The logical transport address used for CSB link. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="afh_map" type="AfhMap *">
          <document>
            <description>New AFH channel map data. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="afh_instant" type="uint32">
          <document>
            <description>Piconet clock at which new AFH channel map is to be applied. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Csb" lifestage="" name="CsbTransmitterSetAfhMap" processor="CSR" tmi="3" trapset="CSB">
      <document>
        <description>Apply AFH map data on CSB transmitter. </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>False if lt_addr do not identify an existing CSB transport otherwise TRUE. \note 1. If the afh_instant provided is already passed then new channel map is applied immediately. 2. If afh_instant for previous set channel map command is not reached and new command is received, then new channel map and instant will overwrite the previous one. In this case the older channel map will not be applied. Firmware will only store and apply the latest channel map at it's instant. 3. In order to apply AfhMap, minimum 20 channels are required to be set otherwise AfhMap will not be applied.
          </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="lt_addr" type="uint16">
          <document>
            <description>The logical transport address used for CSB link. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="afh_map" type="AfhMap *">
          <document>
            <description>New AFH channel map data. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="afh_instant" type="uint32">
          <document>
            <description>Piconet clock at which new AFH channel map is to be applied. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Csb" lifestage="" name="CsbEnableNewAfhMapEvent" processor="CSR" tmi="4" trapset="CSB">
      <document>
        <description>Enables or disables new AFH map event at CSB transmitter/receiver. </description>
        <documentation />
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="enable" type="bool">
          <document>
            <description>If enable (TRUE) then an event (i.e. HCI_CSB_AFH_MAP_AVAILABLE) should be raised when new AFH map is available at CSB transmitter/receiver.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Sink" lifestage="" name="SinkGetWallclock" processor="CSR" tmi="45" trapset="STREAM">
      <document>
        <description>Read Bluetooth wallclock information of ACL link for sink. </description>
        <documentation>

  The wallclock information contains the bluetooth piconet clock counter value  
  and system timestamp at which the piconet clock value was updated.
  BT clock counter ticks in units of 312.5 microseconds (i.e. half a Bluetooth slot)
  and system timestamp is reported in microseconds. The wallclock information 
  also contains change counter which is incremented on each change in 
  wallclock information due to ACL role switch. 
  
  @note
  The sink must be a L2CAP sink stream otherwise it always returns Zero.
  The application must enable the wallclock feature by using SinkConfigure or 
  SourceConfigure before calling this function.
 
</documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the sink identifies an ACL link and the wallclock information could be read, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>Identifies the underlying ACL link</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param direction="OUT" name="wallclock" type="bt_wallclock_info *">
          <document>
            <description>If wallclock information could be read, it will be returned
            to the location pointed at by this value </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Dormant" lifestage="" name="DormantConfigure" processor="CSR" tmi="46" trapset="CORE">
      <document>
        <description>Configures the dormant mode. All the configurable settings are defined in #dormant_config_key.</description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the key is valid and the input value corresponding to the key is valid, else FALSE.
                       Please note that if the request to go into dormant mode is successful the trap will never return.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="key" type="dormant_config_key">
          <document>
            <description>Which aspect of dormant to configure. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="value" type="uint32">
          <document>
            <description>Which value to use. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Vm" lifestage="" name="VmGetPublicAddress" processor="CSR" tmi="12" trapset="BLUESTACK">
      <document>
        <description>Retrieves public address for a given random address.
                     Note: To be used only on an established link.</description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if public address was found for a given resolvable random address, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="random_addr" type="const tp_bdaddr *">
          <document>
            <description>Random address. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param direction="OUT" name="public_addr" type="tp_bdaddr *">
          <document>
            <description>If the public address is found it will be returned to the location pointed at by this value. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="Audio_Pwm" lifestage="" name="AudioPwmPowerEnable" processor="APP" tmi="0" trapset="AUDIO_PWM">
      <document>
        <description>Enables/disables power PIO of the external audio pwm
        amplifier.
        </description>
        <documentation>Note that the external amplifier's power PIO
        (and assert PIO) must be configured via AudioPwmPios MIB key.
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if firmware enables/disables the external
          audio amplifier's power PIO, otherwise FALSE. A failure here only
          indicates that power PIO level has not been changed. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="enable" type="bool">
          <document>
            <description> Enables (TRUE) or disables (FALSE) power to the
            external audio amplifier. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="false" header="Audio_Pwm" lifestage="" name="AudioPwmMute" processor="APP" tmi="1" trapset="AUDIO_PWM">
      <document>
        <description>Mute/unmute the audio pwm signal. </description>
        <documentation>Note that the external amplifier's power PIO
        (and assert PIO) must be configured via AudioPwmPios MIB key.
        </documentation>
        <comment />
      </document>
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="enable" type="bool">
          <document>
            <description> Mute (TRUE) or unmute (FALSE) the audio pwm signal. 
            </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="true" blocking="true" header="crypto" lifestage="" name="CryptoAes128Ctr" processor="CSR" tmi="0" trapset="CRYPTO">
        <document>
            <description>Encrypt data using the AES128-CTR algorithm.</description>
            <documentation />
            <comment />
        </document>
        <return type="bool">
            <document>
                <description>TRUE - Operation completed successfully, FALSE - Some input parameters were invalid.</description>
                <documentation />
                <comment />
            </document>
        </return>
        <params>
            <param name="key" type="const uint8 *">
              <document>
                  <description>Pointer to the 128-bit cryptographic key</description>
                  <documentation />
                  <comment />
              </document>
            </param>
            <param name="nonce" type="const uint8 *">
              <document>
                  <description>Pointer to the 128-bit initial vector</description>
                  <documentation>This value is XORed with the counter</documentation>
                  <comment />
              </document>
            </param>
            <param name="flags" type="uint16">
              <document>
                  <description>Provides control over how the cryptographic algorithm is run e.g. whether parameters are big or little endian</description>
                  <documentation>Use a value of 0 for the standard operation or CRYPTO_FLAGS_AES_BIG_ENDIAN_COUNTER for a counter value that is applied to the upper bits of the initial vector.</documentation>
                  <comment />
              </document>
            </param>
            <param name="counter" type="uint32">
              <document>
                  <description>Counter value to use for the first block of data. It will be incremented and applied to each block in turn.</description>
                  <documentation />
                  <comment />
              </document>
            </param>
            <param name="source_data" type="const uint8 *">
              <document>
                  <description>Pointer to the data to feed into the algorithm</description>
                  <documentation />
                  <comment />
              </document>
            </param>
            <param name="source_data_len_bytes" type="uint16">
              <document>
                  <description>Length of the source data</description>
                  <documentation />
                  <comment />
              </document>
            </param>
            <param name="dest_data" type="uint8 *">
              <document>
                  <description>Pointer to the memory where the output data from the algorithm is to be written</description>
                  <documentation>This can be the same pointer as source_data in which case the source data will be over-written with the output data</documentation>
                  <comment />
              </document>
            </param>
            <param name="dest_data_len_bytes" type="uint16">
              <document>
                  <description>Length of the memory available at the dest_data pointer</description>
                  <documentation />
                  <comment />
              </document>
            </param>
        </params>
    </trap>
    <trap autogen="true" blocking="true" header="crypto" lifestage="" name="CryptoAes128Cbc" processor="CSR" tmi="1" trapset="CRYPTO">
        <document>
            <description>Encrypt, Decrypt or hash data using the AES128-CBC algorithm.</description>
            <documentation />
            <comment />
        </document>
        <return type="bool">
            <document>
                <description>TRUE - Operation completed successfully, FALSE - Some input parameters were invalid.</description>
                <documentation />
                <comment />
            </document>
        </return>
        <params>
            <param name="encrypt" type="bool">
              <document>
                  <description>TRUE for an encryption or FALSE for decryption</description>
                  <documentation />
                  <comment />
              </document>
            </param>
            <param name="key" type="const uint8 *">
              <document>
                  <description>Pointer to the 128-bit cryptographic key</description>
                  <documentation />
                  <comment />
              </document>
            </param>
            <param name="nonce" type="uint8 *">
              <document>
                  <description>Pointer to the 128-bit number to be used as the initial vector</description>
                  <documentation>This is over-written with the final vector from the operation. This can be used as a hash of the source data or as the initial vector for a further (chained) operation.</documentation>
                  <comment />
              </document>
            </param>
            <param name="flags" type="uint16">
              <document>
                  <description>Reserved for future use to control aspects of the cryptographic operation.</description>
                  <documentation>Use a value of 0 for the standard operation.</documentation>
                  <comment />
              </document>
            </param>
            <param name="source_data" type="const uint8 *">
              <document>
                  <description>Pointer to the data to feed into the algorithm</description>
                  <documentation />
                  <comment />
              </document>
            </param>
            <param name="source_data_len_bytes" type="uint16">
              <document>
                  <description>Length of the source data</description>
                  <documentation />
                  <comment />
              </document>
            </param>
            <param name="dest_data" type="uint8 *">
              <document>
                  <description>Pointer to the memory where the output data from the algorithm is to be written</description>
                  <documentation>This may be NULL if the operation is being used as a hash. In that case the hash result is found in the nonce location.
                  This can be the same pointer as source_data in which case the source data will be over-written with the output data</documentation>
                  <comment />
              </document>
            </param>
            <param name="dest_data_len_bytes" type="uint16">
              <document>
                  <description>Length of the memory available at the dest_data pointer</description>
                  <documentation />
                  <comment />
              </document>
            </param>
        </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Audio_Mclk" lifestage="" name="AudioMasterClockConfigure" processor="APP" tmi="0" trapset="AUDIO_MCLK">
      <document>
        <description>Configure the audio master clock (MCLK). </description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if configuration succeeded, FALSE otherwise. MCLK cannot be reconfigured while in use. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="use_external" type="bool">
          <document>
            <description>TRUE if the MCLK is supplied externally, FALSE if generated internally,
            which uses a dedicated clock generator that consumes extra power when in use. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="frequency" type="uint32">
          <document>
            <description>If use_external is TRUE, this specifies the nominal
            frequency of the input in Hz. If zero, the frequency of the input
            will be measured each time MCLK is required (when Source/SinkMasterClockEnable() is
            called). If the measured frequency is not within 1% of the required frequency (configured
            by STREAM_{PCM, I2S}_SYNC_RATE and STREAM_{PCM, I2S}_MASTER_MCLK_MULT), enabling MCLK
            will fail.
            Ignored if use_external is FALSE. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Audio_Mclk" lifestage="" name="SourceMasterClockEnable" processor="APP" tmi="1" trapset="AUDIO_MCLK">
      <document>
        <description>Output or use the audio master clock (MCLK) for a source interface. </description>
        <documentation>
It is only valid to call this function for an audio source whose CLK_SOURCE has
been set to MCLK. Interfaces for which this can be done are #AUDIO_HARDWARE_I2S
and #AUDIO_HARDWARE_PCM.

For such a source, this function must be called with one of the ENABLE values
before the source is taken into use (with StreamConnect()), and source use must
stop (Source disconnected) before the MCLK can be DISABLEd.

The master clock used is as configured with AudioMasterClockConfigure() (all
interfaces use the same master clock signal and configuration).

Once this function has been called with one of the ENABLE values, it is not 
possible to reconfigure the source in any way (with SourceConfigure()) or to
reconfigure the MCLK (with AudioMasterClockConfigure()) until it is called
again with #MCLK_DISABLE.

This function does not itself cause any activity on audio interface pins (other
than the MCLK pin, if configured) or cause audio to start flowing. It does
cause the internal MPLL to be enabled (if configured) or the external MCLK
signal's frequency to be measured (if configured).

If AudioMasterClockConfigure() is set to generate an MCLK signal internally,
the frequency of any MCLK output signal will be the interface sample rate 
(#STREAM_I2S_SYNC_RATE) multipled by #STREAM_I2S_MASTER_MCLK_MULT (or similar 
for a PCM interface).
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the clock was enabled/disabled, FALSE if it failed. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="source" type="Source">
          <document>
            <description>The source to configure MCLK use on. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="enable" type="vm_mclk_enable">
          <document>
            <description>The MCLK enable state. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Audio_Mclk" lifestage="" name="SinkMasterClockEnable" processor="APP" tmi="2" trapset="AUDIO_MCLK">
      <document>
        <description>Output or use the audio master clock (MCLK) for a sink interface. </description>
        <documentation>
It is only valid to call this function for an audio sink whose CLK_SOURCE has
been set to MCLK. Interfaces for which this can be done are #AUDIO_HARDWARE_I2S,
#AUDIO_HARDWARE_PCM and #AUDIO_HARDWARE_SPDIF.

For such a sink, this function must be called with one of the ENABLE values
before the sink is taken into use (with StreamConnect()), and sink use must stop
(Sink disconnected) before the MCLK can be DISABLEd.

The master clock used is as configured with AudioMasterClockConfigure() (all
interfaces use the same master clock signal and configuration).

Once this function has been called with one of the ENABLE values, it is not 
possible to reconfigure the source in any way (with SinkConfigure()) or to
reconfigure the MCLK (with AudioMasterClockConfigure()) until it is called
again with #MCLK_DISABLE.

This function does not itself cause any activity on audio interface pins (other
than the MCLK pin, if configured) or cause audio to start flowing. It does
cause the internal MPLL to be enabled (if configured) or the external MCLK
signal's frequency to be measured (if configured).

If AudioMasterClockConfigure() is set to generate an MCLK signal internally,
the frequency of any MCLK output signal will be the interface sample rate 
(#STREAM_I2S_SYNC_RATE) multipled by #STREAM_I2S_MASTER_MCLK_MULT (or similar 
for a PCM interface).
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the clock was enabled/disabled, FALSE if it failed. </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description>The sink to configure MCLK use on. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="enable" type="vm_mclk_enable">
          <document>
            <description>The MCLK enable state. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Audio_Anc" lifestage="" name="AudioAncStreamEnable" processor="APP" tmi="0" trapset="AUDIO_ANC">
      <document>
        <description>This command controls the enabling/disabling of ANC.</description>
        <documentation>
Note that the DSP software/operator framework must be loaded before enabling/disabling ANC.
Check OperatorFrameworkEnable documentation for more details.
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the ANC stream was enabled, FALSE if the function failed.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="anc_enable_0" type="uint16">
          <document>
            <description>The anc_enable_0 parameter is a bit field that enables the ANC input and output paths of the ANC0 instance.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="anc_enable_1" type="uint16">
          <document>
            <description>The anc_enable_1 parameter is a bit field that enables the ANC input and output paths of the ANC1 instance.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
        
    <trap autogen="p0_non_block" blocking="true" header="Audio_Anc" lifestage="" name="AudioAncFilterLpfSet" processor="APP" tmi="1" trapset="AUDIO_ANC">
      <document>
        <description>This command allows configuration of the ANC LPF filter for each ANC channel instance.</description>
        <documentation>
Note that the DSP software/operator framework must be loaded before configuring ANC.
Check OperatorFrameworkEnable documentation for more details.
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the ANC LPF filter was set, FALSE if the function failed.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="anc_instance" type="audio_anc_instance">
          <document>
            <description>The anc_instance parameter is an ID that identifies the ANC channel instance to which the configuration is to be applied (ANC0/ANC1).</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="path_id" type="audio_anc_path_id">
          <document>
            <description>The path_id parameter is an ID that specifies the ANC path and hence the LPF filter instance to be configured.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="shift1" type="uint16">
          <document>
            <description>The shift1 parameter is used to derive the first LPF coefficient.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="shift2" type="uint16">
          <document>
            <description>The shift2 parameter is used to derive the second LPF coefficient.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Audio_Anc" lifestage="" name="AudioAncFilterIirSet" processor="APP" tmi="2" trapset="AUDIO_ANC">
      <document>
        <description>This command allows configuration of the ANC IIR filter for each ANC channel instance.</description>
        <documentation>
Note that the DSP software/operator framework must be loaded before configuring ANC.
Check OperatorFrameworkEnable documentation for more details.
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if the ANC LPF filter was set, FALSE if the function failed.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="anc_instance" type="audio_anc_instance">
          <document>
            <description>The anc_instance parameter is an ID that identifies the ANC channel instance to which the configuration is to be applied (ANC0/ANC1).</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="path_id" type="audio_anc_path_id">
          <document>
            <description>The path_id parameter is an ID that specifies the ANC path and hence the IIR filter instance to be configured.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="num_coeffs" type="uint16">
          <document>
            <description>The num_coeffs parameter specifies the number of IIR coefficients to be configured.</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="coeffs" type="const uint16 *">
          <document>
            <description>An array of filter coefficients; length is given by the num_coeffs parameter.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Bitserial_api" lifestage="" name="BitserialOpen" processor="APP" tmi="0" trapset="BITSERIAL">
      <document>
        <description>Init and configure Bitserial hardware.</description>
        <documentation>
        Init and configure Bitserial hardware, preparing it for Bitserial
        operations.
        PIOs can be assigned to the Bitserial at any point. This is done by
        using PioSetMapPins32Bank to put the PIO under HW control and then
        PioSetFunction to set the function to one of the Bitserial signals.
        Please note that one PIO can be assigned for multiple signals at the
        same time. All Bitserial signals are initially muxed to
        PIO 96 (which doesn't exist) to make sure there are no conflicts. Once a
        PIO is muxed to a Bitserial signal, that signal cannot be muxed back to
        PIO 96.
        </documentation>
        <comment />
      </document>
      
      <return type="bitserial_handle">
        <document>
          <description>Bitserial handle to be used with all Bitserial traps.</description>
          <documentation>
          BITSERIAL_HANDLE_ERROR is returned if Bitserial hardware or resources
          coudn't be obtained.
          </documentation>
          <comment />
        </document>
      </return>
      
      <params>
        <param name="block_index" type="bitserial_block_index">
          <document>
            <description>Bitserial hardware instance to work with.</description>
            <documentation>
            This makes sense if more than one instance of Bitserial hardware is supported.
            </documentation>
            <comment />
          </document>
        </param>
        
        <param name="config" type="const bitserial_config *">
          <document>
            <description>Bitserial hardware configuration.</description>
            <documentation>
            Data structure describing Bitserial mode and configuration parameters.
            </documentation>
            <comment />
          </document>
        </param>
      </params>
    </trap>  

    <trap autogen="p0_non_block" blocking="true" header="Bitserial_api" lifestage="" name="BitserialClose" processor="APP" tmi="1" trapset="BITSERIAL">
      <document>
        <description>Close and deconfigure Bitserial instance.</description>
        <documentation>
        Close and deconfigure Bitserial hardware and resources. Please note that
        this does not affect PIO settings.
        </documentation>
        <comment />
      </document>
      
      <return type="void">
        <document>
          <description />
          <documentation />
          <comment />
        </document>
      </return>
      
      <params>
        <param name="handle" type="bitserial_handle">
          <document>
            <description>Bitserial handle obtained with BitserialOpen().</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    
    <trap autogen="false" blocking="false" header="Message" lifestage="" name="MessageBitserialTask" processor="APP" tmi="2" trapset="BITSERIAL">
      <document>
          <description>Register Bitserial events task.</description>
          <documentation>
          Register a task to receive MESSAGE_BITSERIAL_EVENT message
          on transfer completion. 
          </documentation>
        <comment />
      </document>
      <return type="Task">
        <document>
          <description>The old task (or zero).</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="task" type="Task">
          <document>
            <description>The task which will receive the messages.</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>

    <trap autogen="p0_non_block" blocking="true" header="Bitserial_api" lifestage="" name="BitserialTransfer" processor="APP" tmi="3" trapset="BITSERIAL">
      <document>
        <description>Perform a combined Bitserial write + read operation.</description>
        <documentation>
        Peforms Bitserial write followed by read without deasserting CS (SPI) / 
        sending STOP (I2C) in between.
        
        Depending on parameters, one of the following three sequences can be requested:
        TX RX: rx_data/tx_data != NULL, rx_size/tx_size != 0;
        RX: rx_data != NULL, rx_size != 0, tx_data == NULL, tx_size == 0; 
        TX: tx_data != NULL, tx_size != 0, rx_data == NULL, rx_size == 0.
        
        "transfer_handle_ptr" controls whether MESSAGE_BITSERIAL_EVENT message
        is sent on transfer completion. If transfer_handle_ptr ==
        BITSERIAL_NO_MSG ("NULL"), then no message is sent on completion.
        
        For this trap "transfer_handle_ptr" has additional effect: if
        transfer_handle_ptr == BITSERIAL_NO_MSG, then blocking operation
        is performed, otherwise the operation is non-blocking.
        </documentation>
        <comment />
      </document>
      
      <return type="bitserial_result">
        <document>
          <description>Result of transfer queueing or completion.</description>
          <documentation>
          For blocking transfers (transfer_handle_ptr == BITSERIAL_NO_MSG)
          transfer result is returned.
          
          Otherwise, for non-blocking transfers, the result indicates whether
          the transfer has been successfully queued.
          </documentation>
          <comment />
        </document>
      </return>
      
      <params>
        <param name="handle" type="bitserial_handle">
          <document>
            <description>Bitserial handle</description>
            <documentation>
            Bitserial handle obtained with BitserialOpen().
            </documentation>
            <comment />
          </document>
        </param>

        <param name="transfer_handle_ptr" type="bitserial_transfer_handle *">
          <document>
            <description>Location for returning transfer handle.</description>
            <documentation>
            If transfer_handle_ptr == BITSERIAL_NO_MSG ("NULL"), no message
            is sent on transfer completion and the trap is blocking.
            
            Otherwise must be a valid pointer. The trap stores transfer handle
            at this location. The handle can be then used to match the corresponding
            Bitserial event message. MESSAGE_BITSERIAL_EVENT is sent 
            on completion to a task registered with MessageBitserialTask().
            In this case trap is non-blocking.
            </documentation>
            <comment />
          </document>
        </param>

        <param name="tx_data" type="const uint8 *">
          <document>
            <description>Data for transmission</description>
            <documentation>
            Points at the block of data to be transmitted.
            If "NULL", TX is not requested and tx_size has to be "0".
            </documentation>
            <comment />
          </document>
        </param>

        <param name="tx_size" type="uint16">
          <document>
            <description>Transmission size.</description>
            <documentation>
            Size in bytes of the block of data to be transmitted.
            If "0" TX is not requested and tx_data pointer has to be "NULL".
            </documentation>
            <comment />
          </document>
        </param>

        <param name="rx_data" type="uint8 *">
          <document>
            <description>Location for received data.</description>
            <documentation>
            Points at the writeable location to store received data.
            If "NULL", RX is not requested and rx_size has to be "0".
            </documentation>
            <comment />
          </document>
        </param>

        <param name="rx_size" type="uint16">
          <document>
            <description>Amount of data to receive.</description>
            <documentation>
            Number of bytes to receive and store in the location provided.
            If "0" RX is not requested and rx_data pointer has to be "NULL".
            </documentation>
            <comment />
          </document>
        </param>
      </params>
    </trap>
  
    <trap autogen="p0_non_block" blocking="true" header="Bitserial_api" lifestage="" name="BitserialWrite" processor="APP" tmi="4" trapset="BITSERIAL">
      <document>
        <description>Perform a Bitserial write operation</description>
        <documentation>
        Performs a Bitserial write operation. The "flags" argument allows
        control over transfer parameters.
        
        Blocking operation can be requested by setting BITSERIAL_FLAG_BLOCK
        in "flags". Otherwise the operation is non-blocking.
        
        "transfer_handle_ptr" controls whether MESSAGE_BITSERIAL_EVENT message
        is sent on transfer completion. If transfer_handle_ptr ==
        BITSERIAL_NO_MSG ("NULL"), then no message is sent on completion.
        </documentation>
        <comment />
      </document>
      
      <return type="bitserial_result">
        <document>
          <description>Result of transfer queueing or completion.</description>
          <documentation>
          For blocking transfers (BITSERIAL_FLAG_BLOCK is set in "flags")
          transfer result is returned.
          
          Otherwise, for non-blocking transfers, the result indicates whether
          the transfer has been successfully queued.
          </documentation>
          <comment />
        </document>
      </return>
      
      <params>
        <param name="handle" type="bitserial_handle">
          <document>
            <description>Bitserial handle</description>
            <documentation>
            Bitserial handle obtained with BitserialOpen().
            </documentation>
            <comment />
          </document>
        </param>

        <param name="transfer_handle_ptr" type="bitserial_transfer_handle *">
          <document>
            <description>Location for returning transfer handle.</description>
            <documentation>
            If transfer_handle_ptr == BITSERIAL_NO_MSG ("NULL"), no message
            is sent on transfer completion.
            
            Otherwise must be a valid pointer. The trap stores transfer handle
            at this location. The handle can be then used to match the corresponding
            Bitserial event message. MESSAGE_BITSERIAL_EVENT is sent 
            on completion to a task registered with MessageBitserialTask().
            </documentation>
            <comment />
          </document>
        </param>
        
        <param name="data" type="const uint8 *">
          <document>
            <description>Data for transmission</description>
            <documentation>
            Points at the block of data to be transmitted.
            </documentation>
            <comment />
          </document>
        </param>

        <param name="size" type="uint16">
          <document>
            <description>Transmission size.</description>
            <documentation>
            Size in bytes of the block of data to be transmitted.
            </documentation>
            <comment />
          </document>
        </param>

        <param name="flags" type="bitserial_transfer_flags">
          <document>
            <description>Bitserial transfer flags.</description>
            <documentation>
            Bitserial transfer flags for controling transfer parameters.
            </documentation>
            <comment />
          </document>
        </param>
      </params>
    </trap>
    
    <trap autogen="p0_non_block" blocking="true" header="Bitserial_api" lifestage="" name="BitserialRead" processor="APP" tmi="5" trapset="BITSERIAL">
      <document>
        <description>Perform a Bitsrial read operation</description>
        <documentation>
        Performs a Bitserial read operation. The "flags" argument allows
        control over transfer parameters.
        
        Blocking operation can be requested by setting BITSERIAL_FLAG_BLOCK
        in "flags". Otherwise the operation is non-blocking.
        
        "transfer_handle_ptr" controls whether MESSAGE_BITSERIAL_EVENT message
        is sent on transfer completion. If transfer_handle_ptr ==
        BITSERIAL_NO_MSG ("NULL"), then no message is sent on completion.
        </documentation>
        <comment />
      </document>
      
      <return type="bitserial_result">
        <document>
          <description>Result of transfer queueing or completion.</description>
          <documentation>
          For blocking transfers (BITSERIAL_FLAG_BLOCK is set in "flags")
          transfer result is returned.
          
          Otherwise, for non-blocking transfers, the result indicates whether
          the transfer has been successfully queued.
          </documentation>
          <comment />
        </document>
      </return>
      
      <params>
        <param name="handle" type="bitserial_handle">
          <document>
            <description>Bitserial handle</description>
            <documentation>
            Bitserial handle obtained with BitserialOpen().
            </documentation>
            <comment />
          </document>
        </param>

        <param name="transfer_handle_ptr" type="bitserial_transfer_handle *">
          <document>
            <description>Location for returning transfer handle.</description>
            <documentation>
            If transfer_handle_ptr == BITSERIAL_NO_MSG ("NULL"), no message
            is sent on transfer completion.
            
            Otherwise must be a valid pointer. The trap stores transfer handle
            at this location. The handle can be then used to match the corresponding
            Bitserial event message. MESSAGE_BITSERIAL_EVENT is sent 
            on completion to a task registered with MessageBitserialTask()
            </documentation>
            <comment />
          </document>
        </param>
      
        <param name="data" type="uint8 *">
          <document>
            <description>Location for received data.</description>
            <documentation>
            Points at the writeable location to store received data.
            </documentation>
            <comment />
          </document>
        </param>

        <param name="size" type="uint16">
          <document>
            <description>Amount of data to receive.</description>
            <documentation>
            Number of bytes to receive and store in the provided location.
            </documentation>
            <comment />
          </document>
        </param>

        <param name="flags" type="bitserial_transfer_flags">
          <document>
            <description>Bitserial transfer flags.</description>
            <documentation>
            Bitserial transfer flags for controling transfer parameters.
            </documentation>
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmRequestRunTimeProfile" processor="CSR" tmi="0" trapset="PROFILE">
      <document>
        <description>Request a profile to apply.</description>
        <documentation>
            On supported products, a profile configures the hardware to allow for enhanced performance at the 
            expense of power consumption. The improvement seen in performance and the power consumption impact 
            is product specific. \c vm_runtime_profile defines the available profiles.
            For example, on \Stretto, \c VM_PERFORMANCE profile will configure the application CPU and the 
            flash interface to 80 MHz offering additional code and flash performance.
            Profile changes can be requested by the application at runtime during execution. However profile changes 
            cannot always be accepted if it is determined that it affects functionality. The request will still be noted 
            and will be applied when possible. The higher performance profiles are usually applied immediately.
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>
            \return TRUE if the profile could be applied immediately. 
            FALSE if the profile change could not be accepted. The profile will be applied when possible.
          </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="profile" type="vm_runtime_profile">
          <document>
            <description>
            Runtime profile selection. The profiles available are chip specific. \sa vm_runtime_profile, VmGetRunTimeProfile()
            </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Vm" lifestage="" name="VmGetRunTimeProfile" processor="CSR" tmi="1" trapset="PROFILE">
      <document>
        <description>Retrieve the current profile applied.</description>
        <documentation>
        The current profile being used is returned.
        </documentation>
        <comment />
      </document>
      <return type="vm_runtime_profile">
        <document>
            <description>
            Runtime profile in use. The profiles available are chip specific. \sa vm_runtime_profile, VmRequestRunTimeProfile()
            </description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>

    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorFrameworkTriggerNotificationStart" processor="CSR" tmi="0" trapset="WAKE_ON_AUDIO">
      <document>
        <description>Starts trigger notification from audio-DSP in low power mode operation</description>
        <documentation>
Before calling this function the application should register a task to handle
messages from the operator using the MessageOperatorTask() call.
Messages will be sent to the task when the trigger conditions occur.
The audio graph of the operator passed to this trigger function will
remain running after a call to OperatorFrameworkEnable(0). In this low 
power mode the operator will continue to produce messages in response 
to the trigger. The low power mode can be exited by calling 
OperatorFrameworkTriggerNotificationStop().
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if trigger notification start request has succeeded, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="type" type="OperatorFrameworkTriggerType">
          <document>
            <description>Type of trigger notification </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="opid" type="Operator">
          <document>
            <description>Operator used to trigger the notification </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorFrameworkTriggerNotificationStop" processor="CSR" tmi="1" trapset="WAKE_ON_AUDIO">
      <document>
        <description>Stops trigger notification from audio-DSP in low power mode operation</description>
        <documentation />
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if trigger notification stop request has succeeded, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorDataLoad" processor="CSR" tmi="2" trapset="WAKE_ON_AUDIO">
      <document>
        <description>Load configuration data file for an operator.</description>
        <documentation>  This causes operator configuration data from a file in 
the application subsystem's filesystem to be loaded into the audio-DSP 
operator framework. This should be done before calling OperatorStart() 
so that the operator capability can use the configuration data during 
it's operation. Application should call OperatorMessage() to setup the 
operator to use the downloaded operator data. The downloaded data will 
occupy resources until unloaded with OperatorDataUnload(), or the 
audio-DSP is powered off by using OperatorFrameworkEnable(MAIN_PROCESSOR_OFF)
without starting trigger notification. However, the application can 
request operator framework to unload the operator data on calling 
OperatorDestroy() for the operator configured to use it.
@note
The SVA capability expects the detection phrase as downloaded operator
data. This api can be used to download the SVA trigger phrase to operator 
framework before starting SVA capability. 
        </documentation>
        <comment />
      </document>
      <return type="DataFileID">
        <document>
          <description>A handle for the resources occupied by the loaded data file which can be passed to OperatorDataUnload().</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="index" type="FILE_INDEX">
          <document>
            <description>Index of the file containing operator data</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="type" type="OperatorDataFileType">
          <document>
            <description>Type of operator data file</description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="auto_remove" type="bool">
          <document>
            <description>TRUE if operator data needs to be removed on operator destroy, FALSE othewise</description>
            <documentation>
             The application should specify whether loaded operator data needs to be removed on operator destroy by 
             using this parameter. If this is FALSE, the application must call OperatorDataUnload on operator destroy. 
             If this is set to TRUE, the operator data will be removed automatically while destroying the operator. 
            </documentation>
            <comment />
          </document>
        </param>
        </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Operator" lifestage="" name="OperatorDataUnload" processor="CSR" tmi="3" trapset="WAKE_ON_AUDIO">
      <document>
      <description>Unload operator configuration data file which has been previously loaded by using OperatorDataLoad()</description>
      <documentation />
      <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if operator data file has been unloaded, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
      <param name="file_id" type="DataFileID">
        <document>
          <description>A handle for the operator data file to be unloaded.</description>
          <documentation />
          <comment />
        </document>
      </param>
      </params>
      </trap>
    <trap autogen="p0_non_block" blocking="true" header="Audio_clock" lifestage="" name="AudioDspClockConfigure" processor="CSR" tmi="4" trapset="WAKE_ON_AUDIO">
      <document>
        <description>Configures audio-DSP clock in different operation modes.</description>
        <documentation>
Application can configure audio-DSP clock in below operation modes:  
1) Active mode - Application can put audio-DSP in active mode by calling 
OperatorFrameworkEnable(MAIN_PROCESSOR_ON). 
2) Low-power mode - Application can put audio-DSP in low-power mode by first 
calling OperatorFrameworkTriggerNotificationStart() and then switching off 
main processor by using OperatorFrameworkEnable(MAIN_PROCESSOR_OFF). 
3) Trigger Mode - If audio-DSP is configured to operate in low-power mode, 
it needs a different clock configuration during transistion from low-power to
active mode. 

The default clock frequency in different modes can be obtained by 
using AudioDspGetClock().

@note
1) The application must power on audio-DSP by using 
OperatorFrameworkEnable(MAIN_PROCESSOR_ON) before using this API.
2) The clock configuration will reset to default settings if application 
decides to power-off audio-DSP without enabling trigger notification in 
low-power mode. Check OperatorFrameworkTriggerNotificationStart documentation
for more details.
3) The active mode clock configuration must be selected carefully in order to
run the audio use case with optimum power consumption.
4) The application must stop all operators while changing the active mode 
clock configuration to avoid undesirable audio output. 
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if clock configuration request has succeeded, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="clock_config" type="audio_dsp_clock_configuration *">
          <document>
            <description> Pointer to audio-dsp clock configuration </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Audio_clock" lifestage="" name="AudioDspGetClock" processor="CSR" tmi="5" trapset="WAKE_ON_AUDIO">
      <document>
        <description>Read audio-DSP clock values in different operation modes.</description>
        <documentation>
Application can read audio-DSP clock values in different operation modes
by using this API. 
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if clock values have been read successfully, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param direction="OUT" name="dsp_clock" type="audio_dsp_clock *">
          <document>
            <description> Pointer to location where clock values will be  
            written if read succeeds </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Audio_power" lifestage="" name="AudioPowerSaveModeSet" processor="CSR" tmi="6" trapset="WAKE_ON_AUDIO">
      <document>
        <description>Configure audio power save mode.</description>
        <documentation>
        </documentation>
        <comment />
      </document>
      <return type="bool">
        <document>
          <description>TRUE if power save mode has been set successfully, FALSE otherwise.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="mode" type="audio_power_save_mode">
          <document>
            <description> Power save mode to set </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>
    <trap autogen="p0_non_block" blocking="true" header="Audio_power" lifestage="" name="AudioPowerSaveModeGet" processor="CSR" tmi="7" trapset="WAKE_ON_AUDIO">
      <document>
        <description>Read audio power save mode in use.</description>
        <documentation>
        </documentation>
        <comment />
      </document>
      <return type="audio_power_save_mode">
        <document>
          <description>Current power save mode, 0 if get request failed.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="" type="void">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>

    <trap autogen="true" blocking="true" header="Stream" lifestage="" name="StreamAttSink" processor="CSR" tmi="7" trapset="ATT">
      <document>
        <description>Find the Sink corresponding to an ATT connection with a specific connection id and attribute handle. </description>
        <documentation>

        </documentation>
        <comment />
      </document>
      <return type="Sink">
        <document>
          <description>Sink on success or zero on failure.</description>
          <documentation />
          <comment />
        </document>
      </return>
      <params>
        <param name="cid" type="uint16">
          <document>
            <description>The channel id to get the connection sink id for. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </trap>

    </traps>

  <messages base="0x8000">
    <message msgidx="SYSTEM_MESSAGE_BASE_" name="MESSAGE_BLUESTACK_BASE_">
      <document>
        <description />
        <documentation>/*
   These Id's *must* correspond to the same primitive classes defined for
   BlueStack in app/bluestack/bluetooth.h, but we don't want to pull in those
   headers here.

   The message points to the actual primitive.
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 1" name="MESSAGE_BLUESTACK_LC_PRIM">
      <document>
        <description />
        <documentation> Link Controller primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 2" name="MESSAGE_BLUESTACK_LM_PRIM">
      <document>
        <description />
        <documentation> Link Manager primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 3" name="MESSAGE_BLUESTACK_HCI_PRIM">
      <document>
        <description />
        <documentation> Host Controller Interface primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 4" name="MESSAGE_BLUESTACK_DM_PRIM">
      <document>
        <description />
        <documentation> Device Manager primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 5" name="MESSAGE_BLUESTACK_L2CAP_PRIM">
      <document>
        <description />
        <documentation> L2CAP primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 6" name="MESSAGE_BLUESTACK_RFCOMM_PRIM">
      <document>
        <description />
        <documentation> RFCOM primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 7" name="MESSAGE_BLUESTACK_SDP_PRIM">
      <document>
        <description />
        <documentation> Service Discovery Protocol primitive.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 8" name="MESSAGE_BLUESTACK_BCSP_LM_PRIM">
      <document>
        <description />
        <documentation> BCSP LM primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 9" name="MESSAGE_BLUESTACK_BCSP_HQ_PRIM">
      <document>
        <description />
        <documentation> BCSP HQ primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 10" name="MESSAGE_BLUESTACK_BCSP_BCCMD_PRIM">
      <document>
        <description />
        <documentation> BCSP BCCMD primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 11" name="MESSAGE_BLUESTACK_CALLBACK_PRIM">
      <document>
        <description />
        <documentation> Callback primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 12" name="MESSAGE_BLUESTACK_TCS_PRIM">
      <document>
        <description />
        <documentation> TCS primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 13" name="MESSAGE_BLUESTACK_BNEP_PRIM">
      <document>
        <description />
        <documentation> BNEP primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 14" name="MESSAGE_BLUESTACK_TCP_PRIM">
      <document>
        <description />
        <documentation> TCP primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 15" name="MESSAGE_BLUESTACK_UDP_PRIM">
      <document>
        <description />
        <documentation> UDP primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 16" name="MESSAGE_BLUESTACK_FB_PRIM">
      <document>
        <description />
        <documentation> FB primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 18" name="MESSAGE_BLUESTACK_ATT_PRIM">
      <document>
        <description />
        <documentation> ATT primitive from Bluestack.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="MESSAGE_BLUESTACK_BASE_ + 19" name="MESSAGE_BLUESTACK_END_">
      <document>
        <description />
        <documentation> End of Bluestack primitives.</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 32" name="MESSAGE_FROM_HOST">
      <document>
        <description />
        <documentation>/*
    Word-oriented message over the 'host' TestTunnel. Message is the 16-bit
    word-format with length+type+payload.
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 33" name="MESSAGE_MORE_DATA">
      <document>
        <description />
        <documentation>  A Source has more data. The message content is a #MessageMoreData.
  This message is sent to the stream's registered task.
  Tasks can be registered with any of the following API calls:

  # MessageStreamTaskFromSink()
  # MessageStreamTaskFromSource()
  # MessageStreamTaskFromSinkHiPri()
  # MessageStreamTaskFromSourceHiPri()

  The frequency of this message can be controlled with #VM_SOURCE_MESSAGES.
</documentation>
        <comment />
      </document>
      <params>
        <param name="source" type="Source">
          <document>
            <description> The source which has more data. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 34" name="MESSAGE_MORE_SPACE">
      <document>
        <description />
        <documentation>  A Sink has more space. The message content is a #MessageMoreSpace.
  This message is sent to the stream's registered task.
  Tasks can be registered with any of the following API calls:

  # MessageStreamTaskFromSink()
  # MessageStreamTaskFromSource()
  # MessageStreamTaskFromSinkHiPri()
  # MessageStreamTaskFromSourceHiPri()

  The frequency of this message can be controlled with #VM_SINK_MESSAGES.
</documentation>
        <comment />
      </document>
      <params>
        <param name="sink" type="Sink">
          <document>
            <description> The sink which has more space. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 35" name="MESSAGE_PIO_CHANGED">
      <document>
        <description />
        <documentation>  A PIO has changed. The message content is a #MessagePioChanged.

  This message is sent to the task registered with MessagePioTask().
</documentation>
        <comment />
      </document>
      <params>
        <param name="state" type="uint16">
          <document>
            <description> The state of PIO lines 0..15 when this message was sent. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="time" type="uint32">
          <document>
            <description> The time at which that state was valid. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="state16to31" type="uint16">
          <document>
            <description> The state of PIO lines 16..31 when this messsage was sent. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="bank" type="uint16">
          <document>
            <description> The bank index of the PIO lines. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 36" name="MESSAGE_FROM_KALIMBA">
      <document>
        <description />
        <documentation>  A message from Kalimba has arrived. The message content is a
  #MessageFromKalimba.

  This message is sent to the task registered with MessageKalimbaTask().
</documentation>
        <comment />
      </document>
      <params>
        <param name="id" type="uint16">
          <document>
            <description> The message id sent by Kalimba </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="data[4]" type="uint16">
          <document>
            <description> The message payload </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 37" name="MESSAGE_ADC_RESULT">
      <document>
        <description />
        <documentation>  A requested ADC measurement has completed. The message content is
  a #MessageAdcResult.

  This message is sent to the task passed to AdcRequest().
</documentation>
        <comment />
      </document>
      <params>
        <param name="adc_source" type="vm_adc_source_type">
          <document>
            <description> The ADC source for which the reading was made. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="reading" type="uint16">
          <document>
            <description> The reading derived from the hardware. See adc.h for how to interpret this reading. </description>
            <documentation />
            <comment />
          </document>
        </param>        
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 38" name="MESSAGE_STREAM_DISCONNECT">
      <document>
        <description />
        <documentation>  A stream has disconnected. The message content is a
  #MessageStreamDisconnect.

  This message is sent to the stream's registered task.
  Tasks can be registered with any of the following API calls:

  # MessageStreamTaskFromSink()
  # MessageStreamTaskFromSource()
  # MessageStreamTaskFromSinkHiPri()
  # MessageStreamTaskFromSourceHiPri()
</documentation>
        <comment />
      </document>
      <params>
        <param name="source" type="Source">
          <document>
            <description> The source which was involved in the connection. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="sink" type="Sink">
          <document>
            <description> The sink which was involved in the connection. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 39" name="MESSAGE_ENERGY_CHANGED">
      <document>
        <description />
        <documentation>  The energy level in a SCO stream has changed. The message content is a
  #MessageEnergyChanged.

   This message is sent to the stream's registered task.
   Tasks can be registered with any of the following API calls:

   # MessageStreamTaskFromSink()
   # MessageStreamTaskFromSource()
   # MessageStreamTaskFromSinkHiPri()
   # MessageStreamTaskFromSourceHiPri()

  It is enabled with EnergyEstimationSetBounds().
</documentation>
        <comment />
      </document>
      <params>
        <param name="sco_sink" type="Sink">
          <document>
            <description> The SCO sink on which the estimated energy level has passed the configured threshold. </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="over_threshold" type="bool">
          <document>
            <description> TRUE if the threshold was exceeded, else FALSE. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 40" name="MESSAGE_STATUS_CHANGED">
      <document>
        <description />
        <documentation>  The values returned by StatusQuery() may have changed. (No message content.)

  This message is sent to the task registered with MessageStatusTask().
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 41" name="MESSAGE_SOURCE_EMPTY">
      <document>
        <description />
        <documentation>  A Source is empty. The message content is a #MessageSourceEmpty.
   This message is sent to the stream's registered task.
   Tasks can be registered with any of the following API calls:

   # MessageStreamTaskFromSink()
   # MessageStreamTaskFromSource()
   # MessageStreamTaskFromSinkHiPri()
   # MessageStreamTaskFromSourceHiPri()
</documentation>
        <comment />
      </document>
      <params>
        <param name="source" type="Source">
          <document>
            <description> The source which is empty. </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 42" name="MESSAGE_FROM_KALIMBA_LONG">
      <document>
        <description />
        <documentation>  A long message from Kalimba has arrived. The message content is a
  #MessageFromKalimbaLong.

  This message is sent to the task registered with MessageKalimbaTask().
</documentation>
        <comment />
      </document>
      <params>
        <param name="id" type="uint16">
          <document>
            <description> The message id sent by Kalimba </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="len" type="uint16">
          <document>
            <description> The length of the message payload </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="data[1]" type="uint16">
          <document>
            <description> len words of message payload </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 43" name="MESSAGE_USB_ENUMERATED">
      <document>
        <description />
        <documentation>  BlueCore has enumerated as a USB device. The message content is a
  #MessageUsbConfigValue, telling you which configuration has been
  set by the host.

  This message is sent to the task registered with MessageSystemTask().
</documentation>
        <comment />
      </document>
      <params>
        <param name="config_value" type="uint16">
          <document>
            <description> bConfigurationValue for the selected configuration </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 44" name="MESSAGE_USB_SUSPENDED">
      <document>
        <description />
        <documentation>  BlueCore has suspended or resumed as a USB device; the message
  is a #MessageUsbSuspended and indicates which.

  This message is not sent if BlueCore is bus powered.

  Note that only the most recent change is reported, so adjacent
  messages may report the same status.

  This message is sent to the task registered with MessageSystemTask().
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 45" name="MESSAGE_CHARGER_CHANGED">
      <document>
        <description />
        <documentation>  The charger hardware has changed state.

  Note when user removes the charger, the firmware has already selected
  the battery as the power source, i.e. equivalent to VM executing
  PsuConfigure(PSU_VBAT_SWITCH, PSU_SMPS_INPUT_SEL_VBAT, 1).

  The message content is a #MessageChargerChanged.

  This message is sent to the task registered with MessageChargerTask().
</documentation>
        <comment />
      </document>
      <params>
        <param name="charger_connected" type="bool">
          <document>
            <description> TRUE if the charger is connected, FALSE if it is not </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="vreg_en_high" type="bool">
          <document>
            <description> TRUE if VREG_EN is high, FALSE if it is not </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="status" type="charger_status">
          <document>
            <description> Status of the charger </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 46" name="MESSAGE_PSFL_FAULT">
      <document>
        <description />
        <documentation>  A fault was detected in flash-based PS. (No message content.)

  This message is sent to the task registered with MessageSystemTask().
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 47" name="MESSAGE_USB_DECONFIGURED">
      <document>
        <description />
        <documentation>  BlueCore has been deconfigured as a USB device. To maintain symmetry
  with the MESSAGE_USB_ENUMERATED case, this message also contains a
  #MessageUsbConfigValue, although in this case the config_value will
  always be zero.

  This message is sent to the task registered with MessageSystemTask().
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 48" name="MESSAGE_USB_ALT_INTERFACE">
      <document>
        <description />
        <documentation>  BlueCore has changed to alternate settings for a USB interface. The
  message content is a #MessageUsbAltInterface.

  In order to receive MESSAGE_USB_ALT_INTERFACE, an application must first explicitly register
  an interest in this message by using StreamConfigure(#VM_STREAM_USB_ALT_IF_MSG_ENABLED, 1).

  This message is sent to the task registered with MessageSystemTask().
</documentation>
        <comment />
      </document>
      <params>
        <param name="interface" type="uint16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
        <param name="altsetting" type="uint16">
          <document>
            <description />
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 49" name="MESSAGE_USB_ATTACHED">
      <document>
        <description />
        <documentation>  Bluecore has detected USB Vbus transition from low to high,
  indicating the device is now attached. (No message content.)

  In order to receive MESSAGE_USB_ATTACHED or MESSAGE_USB_DETACHED, an application must first
  explicitly register an interest in these messages by using StreamConfigure(#VM_STREAM_USB_ATTACH_MSG_ENABLED, 1).

  This message is sent to the task registered with MessageSystemTask().
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 50" name="MESSAGE_USB_DETACHED">
      <document>
        <description />
        <documentation>  Bluecore has detected USB Vbus transition from high to low,
  indicating the device is now detached. (No message content.)

  In order to receive MESSAGE_USB_ATTACHED or MESSAGE_USB_DETACHED, an application must first
  explicitly register an interest in these messages by using StreamConfigure(#VM_STREAM_USB_ATTACH_MSG_ENABLED, 1).

  This message is sent to the task registered with MessageSystemTask().
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 51" name="MESSAGE_KALIMBA_WATCHDOG_EVENT">
      <document>
        <description />
        <documentation>  Bluecore has detected a Kalimba watchdog event indicating
  that the DSP must be restarted. (No message content.)

  This message is sent to the task registered with MessageKalimbaTask().
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 52" name="MESSAGE_TX_POWER_CHANGE_EVENT">
      <document>
        <description />
        <documentation>  Bluecore has changed Bluetooth transmission power. (No message
  content).

  In order to receive a MESSAGE_TX_POWER_CHANGE_EVENT an
  application must first explicitly register an interest in this
  message by using VmTransmitPowerMessagesEnable(TRUE).  This must be
  done each time the message is received to re-register interest.

  This message can apply to any BR/EDR link; it is the responsibility
  of the application to determine which links, if any, have actually
  changed (the application should be prepared to handle the case where
  there is no net change to the power on any links). Applications
  concerned to catch all power change events should reenable this
  message using VmTransmitPowerMessagesEnable() before checking the
  power on the links.

  If this message is explicitly disabled with
  VmTransmitPowerMessagesEnable(FALSE), it is possible for one last
  event to occur if it was already queued.  Applications concerned by
  this should cancel pending messages.

  This message is sent to the task registered with MessageSystemTask().
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 53" name="MESSAGE_CAPACITIVE_SENSOR_CHANGED">
      <document>
        <description />
        <documentation>   A Capacitive Sensor pad has changed. The message content is a 
MessageCapacitiveSensorChanged. This message is sent to the task registered with 
MessageCapacitiveSensorTask().
</documentation>
        <comment />
      </document>
      <params>
        <param name="num_events" type="uint16">
          <document>
            <description> number of events described in this message </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="event[1]" type="capacitive_sensor_event">
          <document>
            <description> array of events (length of num_events) </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 55" name="MESSAGE_STREAM_SET_DIGEST">
      <document>
        <description />
        <documentation>    Message Id 54 is not in use
</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 56" name="MESSAGE_STREAM_PARTITION_VERIFY">
      <document>
        <description />
        <documentation>   Verification of a file system written to serial flash has completed.
   The message content is a MessageStreamPartitionVerify.
   This message is sent to the stream's registered task.
   Tasks can be registered with any of the following API calls:

   # MessageStreamTaskFromSink()
   # MessageStreamTaskFromSource()
   # MessageStreamTaskFromSinkHiPri()
   # MessageStreamTaskFromSourceHiPri()

</documentation>
        <comment />
      </document>
      <params>
        <param name="device" type="partition_filesystem_devices">
          <document>
            <description> file system device written to </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="partition" type="uint16">
          <document>
            <description> partition written to </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="verify_result" type="partition_verify_result">
          <document>
            <description> result of verification, see #partition_verify_result </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 57" name="MESSAGE_STREAM_REFORMAT_VERIFY">
      <document>
        <description />
        <documentation>   Verification of the reformatting of the serial flash has completed.
   The message content is a MessageStreamReformatVerify.
   This message is sent to the stream's registered task.
   Tasks can be registered with any of the following API calls:

   # MessageStreamTaskFromSink()
   # MessageStreamTaskFromSource()
   # MessageStreamTaskFromSinkHiPri()
   # MessageStreamTaskFromSourceHiPri()
</documentation>
        <comment />
      </document>
      <params>
        <param name="device" type="partition_filesystem_devices">
          <document>
            <description> file system device written to </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="verify_result" type="partition_verify_result">
          <document>
            <description> result of verification, see #partition_verify_result </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 58" name="MESSAGE_INFRARED_EVENT">
      <document>
        <description />
        <documentation>   An infrared button has been pressed or released. The message content
   is a MessageInfraRedEvent.
   This message is sent to the task registered with MessageInfraRedTask()
</documentation>
        <comment />
      </document>
      <params>
        <param name="event" type="infrared_event">
          <document>
            <description> Event type </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="protocol" type="infrared_protocol">
          <document>
            <description> Infra-red protocol </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="time" type="uint32">
          <document>
            <description> Time in milliseconds event occurred </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="address" type="uint16">
          <document>
            <description> Protocol specific device address </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="size_data" type="uint16">
          <document>
            <description> Size of data[] field </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="data[1]" type="uint8">
          <document>
            <description> Protocol specific event data </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 59" name="MESSAGE_DFU_SQIF_STATUS">
      <document>
        <description />
        <documentation>   Reports the status of DFU from SQIF operation to the task registered with
   MessageSystemTask(). The message content is a #MessageDFUFromSQifStatus
   
</documentation>
        <comment />
      </document>
      <params>
        <param name="status" type="vm_dfu_sqif_status">
          <document>
            <description> result of DFU from SQIF process, see #vm_dfu_sqif_status</description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 60" name="MESSAGE_FROM_OPERATOR">
      <document>
        <description />
        <documentation>  A message from Operator has arrived. The message content is a
  #MessageFromOperator.

  This message is sent to the task registered with specific operator ID.
</documentation>
        <comment />
      </document>
      <params>
        <param name="len" type="uint16">
          <document>
            <description> The length of the message payload </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="message[1]" type="uint16">
          <document>
            <description> Unsolicited message from operator </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 61" name="MESSAGE_EXE_FS_VALIDATION_STATUS">
      <document>
        <description />
        <documentation>  Report the validation result of an executable FS. The message content is a
  MessageExeFsValidationResult.

</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 62" name="MESSAGE_FROM_OPERATOR_FRAMEWORK">
      <document>
        <description />
        <documentation>  A message from Operator framework has arrived. 
        The message content is a #MessageFromOperatorFramework.

  This message is sent to the task registered with specific operator ID.
</documentation>
        <comment />
      </document>
      <params>
        <param name="key" type="uint16">
          <document>
            <description> The key corresponding to the type of message </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="len" type="uint16">
          <document>
            <description> The length of the message payload </description>
            <documentation />
            <comment />
          </document>
        </param>
        <param name="message[1]" type="uint16">
          <document>
            <description> Unsolicited message from operator framework </description>
            <documentation />
            <comment />
          </document>
        </param>
      </params>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 63" name="MESSAGE_IMAGE_UPGRADE_ERASE_STATUS">
      <document>
        <description />
        <documentation>  A message to indicate that the image upgrade erase is successful.
          This message is sent to the task registered with MessageSystemTask().
          The message content is a #MessageImageUpgradeEraseStatus.

        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 64" name="MESSAGE_CHARGER_DETECTED">
      <document>
        <description />
        <documentation>  A message to indicate what type of charger detected.
          This message is sent to the task registered with MessageChargerTask().
          The message content is a #MessageChargerDetected.

        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 65" name="MESSAGE_CHARGER_STATUS">
      <document>
        <description />
        <documentation>  A message to indicate unswitched status from charger.
          This message is sent to the task registered with MessageChargerTask().
          The message content is a #MessageChargerStatus.

        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 66" name="MESSAGE_CHARGER_EMERGENCY">
      <document>
        <description />
        <documentation>  A message to indicate charger disconnect emergency event.
          This message is sent to the task registered with MessageChargerTask().
          The message content is a #MessageEmergencyMode.

        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 67" name="MESSAGE_AUDIO_PWM_MUTED_FOREVER">
      <document>
        <description />
        <documentation> A message to indicate that audio pwm outputs has been
          muted forever as the external audio amplifier became too hot.
          Chip must be reset before using the audio pwm again.
          This message is sent to the task registered with MessageSystemTask().
          There is no message content.

        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 68" name="MESSAGE_CHARGER_DBP_EXITED">
      <document>
        <description />
        <documentation>  A message to indicate that dead battery provision mode is
          exited i.e. battery has sufficient voltage to operate or timeout in dead
          battery provision mode).
        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 69" name="MESSAGE_CHARGER_DBP_ENTERED">
      <document>
        <description />
        <documentation>  A message to indicate that the dead battery provision mode
          is started i.e. battery has low voltage (i.e. weak battery) to operate.
        </documentation>
        <comment />
      </document>
    </message> 

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 70" name="MESSAGE_SUBSYSTEM_VERSION_INFO">
      <document>
        <description />
        <documentation> A message to report chip subsystem version information. This
          message is sent to the task registered with MessageSystemTask()
          The message content is a #MessagesSubsystemVersionInfo.

        </documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 71" name="MESSAGE_SUBSYSTEM_EVENT_REPORT">
      <document>
        <description />
        <documentation> A message to report chip subsystem event information. This
          message is sent to the task registered with MessageSystemTask()
          The message content is a #MessageSubsystemEventReport
        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 72" name="MESSAGE_IMAGE_UPGRADE_COPY_STATUS">
      <document>
        <description />
        <documentation>  A message to indicate that the image upgrade copy is successful.
          This message is sent to the task registered with MessageSystemTask().
          The message content is a #MessageImageUpgradeCopyStatus.

        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 73" name="MESSAGE_BITSERIAL_EVENT">
      <document>
        <description />
        <documentation> A message to reports Bitserial transfer event. This
        message is sent to the task registered with MessageBitserialTask().
        The message content is a #MessageBitserialEvent
        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 75" name="MESSAGE_IMAGE_UPGRADE_AUDIO_STATUS">
      <document>
        <description />
        <documentation>  A message to indicate that the image upgrade audio is successful.
          This message is sent to the task registered with MessageSystemTask().
          The message content is a #MessageImageUpgradeAudioStatus.

        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 76" name="MESSAGE_IMAGE_UPGRADE_HASH_ALL_SECTIONS_UPDATE_STATUS">
      <document>
        <description />
        <documentation>  A message to indicate that the image upgrade update all sections to the hash context
          is successful.
          This message is sent to the task registered with MessageSystemTask().
          The message content is a #MessageImageUpgradeHashAllSectionsUpdateStatus.

        </documentation>
        <comment />
      </document>
    </message>

    <message msgidx="SYSTEM_MESSAGE_BASE_ + 77" name="MESSAGE_SD_MMC_INSERTED">
      <document>
        <description />
        <documentation> Message to P1 informing about SD card being inserted.
        The message content is a #MessageSdMmcEvent.
        This message is sent to the task registered with MessageSystemTask().

</documentation>
        <comment />
      </document>
    </message>
    <message msgidx="SYSTEM_MESSAGE_BASE_ + 78" name="MESSAGE_SD_MMC_REMOVED">
      <document>
        <description />
        <documentation> Message to P1 informing about SD card being removed.
        The message content is a #MessageSdMmcEvent.
        This message is sent to the task registered with MessageSystemTask().

</documentation>
        <comment />
      </document>
    </message>
    
  </messages>
</api>
