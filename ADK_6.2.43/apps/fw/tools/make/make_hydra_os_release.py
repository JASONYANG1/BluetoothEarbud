#!/usr/bin/env python
# Copyright (c) 2018 Qualcomm Technologies International, Ltd.
#   Part of 6.2

"""
A script for making a release copy of the Apps P1 library file for the ADK.

For usage information run ./make_hydra_os_release.py -h

The script uses the provided x2p file to determine which files should be included in a release.
The x2p file can be generated from an aura or crescendo library build, e.g. RELEASE=aura_p1_d01_lib.
The files are copied to the provided output directory and a number of modifications are made to them.
These modifications are only partially implemented, but eventually should replace the majority of work
done by the ADK setup.py script.
Currently the steps involved in releasing the Apps P1 library to the ADK are:
1. Copy all released files mentioned in the x2p from the build location the output location.
2. Move any autogenerated files in the build directory to a directory in the source tree and patch
   up any references to them.
3. Remove the problematic INSTALL_HYDRA_LOG_PER_MODULE_LEVELS define, this feature will be changed
   so that different defines per C file aren't required. See B-251683.
4. Generate a Makefile so the ADK can treat this as a Makefile project.
   TODO: B-263183 - Decide on the final build system, generating a Makefile was just the path of
   least resistance but might not be ideal long term.
5. TODO: B-261940 - Copy the interface header files into an interface directory.
6. TODO: B-261940 - Create a trapsets.h file from the x2p DEFS list.
7. TODO: B-261933 - Run the unifdef.py script to remove all references we shouldn't be releasing.

The resulting output of the script can be built by changing to the <output>/fw/src directory and
running make with either DEVKIT_ROOT set to your ADK devkit path, or by setting KCC_DIR directly.
"""

import argparse
import re
import os
import posixpath
import xml.etree.ElementTree
import shutil
import errno

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("x2p", help="the x2p file to base the release on.")
    parser.add_argument("output", help=("the output directory, this must not already exist, this "
                                        "script will create it to ensure it's working in a clean "
                                        "environment."))
    args = parser.parse_args()

    create_hydra_os_release(args.x2p, args.output)

def create_hydra_os_release(x2p_file, output_directory):
    """
    Reads the given x2p file and creates a release copy in the output directory
    The output directory is created by this function, it should not already exist.
    """

    os.makedirs(output_directory)

    x2p = X2p(x2p_file)

    copy_released_files(x2p, output_directory)

    # Autogenerated files from the build directory need to be moved to the source directory
    # The x2p file will also need modifying to include the new paths.
    # This way make clean can delete everything in the build directory and our released Makefile
    # doesn't need to regenerate them.
    move_generated_files(x2p, output_directory)

    # The INSTALL_HYDRA_LOG_PER_MODULE_LEVELS define requires each file to have a MODULE define set.
    # The ADK ubuild script doesn't support having a different set of defines per compilation unit
    # so this feature needs to be disabled until there's a way.
    remove_define(x2p, output_directory, "INSTALL_HYDRA_LOG_PER_MODULE_LEVELS")

    generate_makefile(x2p, output_directory)

    x2p_output_file = os.path.join(output_directory, "fw", "src", "hydra_os_app_p1.x2p")
    x2p.write(x2p_output_file)

def copy_released_files(x2p, output_directory):
    """Copy all released files given in the x2p file to the output directory."""
    for _file in x2p.release_files:
        src = os.path.normpath(os.path.join(x2p.project_directory, "fw", "src", _file))
        dest = os.path.normpath(os.path.join(output_directory, "fw", "src", _file))
        create_path_and_copy(src, dest)

def move_generated_files(x2p, output_directory):
    """
    Moves all autogenerated files from
    <output_directory>/fw/build/<release> to <output_directory>/fw/src/gen
    """

    # Relative to the fw/src directory where the build starts from
    # Posix form so it matches in the x2p file
    src_rel = posixpath.join("..", "build", x2p.release_name)
    dest_rel = "gen"

    src = os.path.normpath(os.path.join(output_directory, "fw", "src", src_rel))
    dest = os.path.normpath(os.path.join(output_directory, "fw", "src", dest_rel))

    print "Move " + src + " to " + dest
    shutil.move(src, dest)
    os.rmdir(os.path.join(output_directory, "fw", "build"))

    # Update the x2p file's view
    x2p.move_dir(src_rel, dest_rel)
    x2p.rmdir(posixpath.join("..", "build"))

def remove_define(x2p, output_directory, define):
    """
    Remove "define" from the x2p and preinclude files.
    Note: This function only currently supports removing defines without associated values.
    """
    # Remove the DEF entry from the x2p file
    x2p.remove_define(define)

    # Also remove the define from any preinclude files
    for _file in x2p.preincludes:
        path = os.path.join(output_directory, "fw", "src", _file)
        tmp_path = path + ".tmp"
        with open(path) as src_file, open(tmp_path, "w") as tmp_file:
            for line in src_file:
                # Match a define followed by an immediate space or newline
                if not re.match(r'\s*#define\s+' + define + "\s*\r?\n", line):
                    tmp_file.write(line)
        os.remove(path)
        os.rename(tmp_path, path)

def generate_makefile(x2p, output_directory):
    """
    Create a Makefile for building the Apps P1 library and the init_usb_early_init.a library.
    """
    makefile = os.path.join(output_directory, "fw", "src", "Makefile")
    with open(makefile, "w") as f:
        copyright_header = ("# Copyright (c) 2018 Qualcomm Technologies International, Ltd.\n"
                            "#   Part of 6.2\n")
        f.write(copyright_header)

        kcc_dir = "KCC_DIR?=$(DEVKIT_ROOT)/tools/kcc\n"
        f.write(kcc_dir)
        cc = "CC={}\n".format("$(KCC_DIR)/bin/kcc")
        f.write(cc)
        ar = "AR={}\n".format("$(KCC_DIR)/bin/kar")
        f.write(ar)

        os_abstraction = ("ifeq ($(OS),Windows_NT)\n"
                          "\tRMDIR=rmdir /S /Q\n"
                          "\tFIXPATH=$(subst /,\\,$1)\n"
                          "\tMKDIR=if not exist $(call FIXPATH,$1) mkdir $(call FIXPATH,$1)\n"
                          "else\n"
                          "\tRMDIR=rm -rf\n"
                          "\tFIXPATH=$1\n"
                          "\tMKDIR=mkdir -p $1\n"
                          "endif\n"
                          "MAKE_DIR=$(call MKDIR,${@D})\n")
        f.write(os_abstraction)

        # Exclude init_usb_early_init.c from the P1 library
        c_sources = [_file for _file in x2p.c_files if not _file.endswith("/init_usb_early_init.c")]
        c_source_str = "C_SOURCE={}\n".format(" ".join(c_sources))
        f.write(c_source_str)

        h_source_str = "H_SOURCE={}\n".format(" ".join(x2p.h_files))
        f.write(h_source_str)

        asm_source_str = "ASM_SOURCE={}\n".format(" ".join(x2p.asm_files))
        f.write(asm_source_str)

        build_dir = "BUILD_DIR=../build/{}\n".format(x2p.release_name)
        f.write(build_dir)

        incpaths = "INCPATHS={}\n".format(" ".join(x2p.include_paths))
        f.write(incpaths)

        include_paths = "INCLUDE_PATHS=$(foreach inc,$(INCPATHS),-I$(inc))\n"
        f.write(include_paths)

        asm_include_paths = "ASM_INCLUDE_PATHS=$(foreach inc,$(INCPATHS),-A$(inc))\n"
        f.write(asm_include_paths)

        preincpaths = "PREINCPATHS={}\n".format(" ".join(x2p.preincludes))
        f.write(preincpaths)

        preincludes = "PREINCLUDES=$(foreach pre,$(PREINCPATHS),-preinclude $(pre))\n"
        f.write(preincludes)

        asm_preincludes = "ASM_PREINCLUDES=$(foreach pre,$(PREINCPATHS),-Xa -include -Xa $(pre))\n"
        f.write(asm_preincludes)

        c_objects = "C_OBJECTS=$(patsubst %.c, $(BUILD_DIR)/%.o,$(C_SOURCE))\n"
        f.write(c_objects)

        asm_objects = "ASM_OBJECTS=$(patsubst %.asm, $(BUILD_DIR)/%.o,$(ASM_SOURCE))\n"
        f.write(asm_objects)

        chip_name_opt = "CHIP_NAME_OPT=-k{}\n".format(x2p.chip_name)
        f.write(chip_name_opt)

        warning_opts = "WARNING_OPTS=-Wall -WAccuracyLoss -WnoPointerUnaligned -WnoConstantTest\n"
        f.write(warning_opts)

        c_flags = "CFLAGS=-g -minim $(CHIP_NAME_OPT) -Xc -o2 -Xa -apply-b179745-workaround $(WARNING_OPTS)\n"
        c_flags += "CFLAGS+=$(PREINCLUDES) $(INCLUDE_PATHS)\n"
        c_flags += "CFLAGS+=$(ASM_PREINCLUDES) $(ASM_INCLUDE_PATHS)\n"
        f.write(c_flags)

        all_target = "all: $(BUILD_DIR)/lib{}.a $(BUILD_DIR)/customer/core/init/init_usb_early_init.a\n".format(x2p.output)
        f.write(all_target)

        library_target = "$(BUILD_DIR)/lib{}.a: $(C_OBJECTS) $(ASM_OBJECTS)\n".format(x2p.output)
        library_target += "\t$(AR) ru $@ $^\n"
        f.write(library_target)

        init_usb_target = "$(BUILD_DIR)/customer/core/init/init_usb_early_init.a: $(BUILD_DIR)/customer/core/init/init_usb_early_init.o\n"
        init_usb_target += "\t$(AR) ru $@ $^\n"
        f.write(init_usb_target)

        kcc_command = "$(CC) $(CFLAGS) -o $@ -c $<"
        object_target = "$(BUILD_DIR)/%.o: %.{} $(H_SOURCE)\n\t$(MAKE_DIR)\n\t" + kcc_command + "\n"
        f.write(object_target.format("c"))
        f.write(object_target.format("asm"))

        clean_target = ".PHONY: clean\nclean:\n\t-$(RMDIR) $(call FIXPATH,../build)\n"
        f.write(clean_target)

class X2p(object):
    """
    A class for working with an x2p file.
    """

    def __init__(self, x2p_file):
        # The release name is the RELEASE target specified to make
        self.release_name = os.path.basename(os.path.dirname(os.path.abspath(x2p_file)))

        # The project directory is always 3 directories above the .x2p file
        # e.g. app_ss/main is the project directory of
        # app_ss/main/fw/build/crescendo_p1_d01_lib/crescendo_app_p1.x2p
        directory = os.path.abspath(x2p_file)
        for _ in xrange(4):
            directory = os.path.dirname(directory)
        self.project_directory = directory

        self.tree = xml.etree.ElementTree.parse(x2p_file)

    @property
    def release_files(self):
        # Make the release files relative to the fw/src directory without the ../../fw/src prefix
        return [os.path.relpath(_file.attrib["path"], "../../fw/src") for _file in self.tree.iter("file")]

    def files_of_type(self, ext):
        return [f for f in self.release_files if f.endswith(ext)]

    @property
    def c_files(self):
        return self.files_of_type(".c")

    @property
    def h_files(self):
        return self.files_of_type(".h")

    @property
    def asm_files(self):
        return self.files_of_type(".asm")

    @property
    def include_paths(self):
        return self.tree.find('./configurations/configuration/property[@name="INCPATHS"]').text.split(" ")

    @property
    def preincludes(self):
        return self.tree.find('./configurations/configuration/property[@name="PREINCLUDES"]').text.split(" ")

    @property
    def chip_type(self):
        return self.tree.find('./configurations/configuration/property[@name="CHIP_TYPE"]').text

    @property
    def chip_name(self):
        return self.chip_type[:-3] + "app"

    @property
    def output(self):
        return self.tree.find('./configurations/configuration/property[@name="OUTPUT"]').text

    def move_dir(self, src, dest):
        """
        Move the 'src' directory to 'dest'.
        'src' and 'dest' paths should be relative to the fw/src directory.
        """

        # Update the paths in the xml tree structure
        # The x2p tree starts from the top directory. src and dest are relative to fw/src so need modifying
        src_path = os.path.normpath(os.path.join("fw", "src", src)).split(os.path.sep)
        src_element_path = "./" + '/'.join('folder[@name="' + name + '"]' for name in src_path)
        src_parent_element_path = src_element_path + "/.."
        src_element = self.tree.find(src_element_path)
        parent = self.tree.find(src_parent_element_path)
        parent.remove(src_element)

        dest_path = os.path.normpath(os.path.join("fw", "src", dest)).split(os.path.sep)
        dest_parent_element_path = "./" + '/'.join('folder[@name="' + name + '"]' for name in dest_path[:-1])
        parent = self.tree.find(dest_parent_element_path)
        src_element.attrib["name"] = dest_path[-1]
        parent.append(src_element)

        # Update all file path elements
        # Paths in the x2p start from fw/src but contain the ../../fw/src prefix
        # Posix as all x2p paths are posix
        prefix = posixpath.join("..", "..", "fw", "src")
        src_prefixed = posixpath.normpath(posixpath.join(prefix, src))
        dest_prefixed = posixpath.normpath(posixpath.join(prefix, dest))
        for _file in src_element.findall('.//file'):
            _file.attrib["path"] = _file.attrib["path"].replace(src_prefixed, dest_prefixed)

        # Update INCPATHS and PREINCLUDES
        for incpaths in self.tree.findall('./configurations/configuration/property[@name="INCPATHS"]'):
            pathlist = incpaths.text.split(" ")
            newlist = [path.replace(src, dest) if path.startswith(src) else path for path in pathlist]
            incpaths.text = " ".join(newlist)

        for preincludes in self.tree.findall('./configurations/configuration/property[@name="PREINCLUDES"]'):
            filelist = preincludes.text.split(" ")
            newlist = [_file.replace(src, dest) if _file.startswith(src) else _file for _file in filelist]
            preincludes.text = " ".join(newlist)

    def rmdir(self, directory):
        # The x2p tree starts from the top directory. 'directory' is relative to fw/src so needs modifying.
        path = os.path.normpath(os.path.join("fw", "src", directory)).split(os.path.sep)
        element_path = "./" + '/'.join('folder[@name="' + name + '"]' for name in path)
        parent_element_path = element_path + "/.."
        element = self.tree.find(element_path)
        parent = self.tree.find(parent_element_path)
        parent.remove(element)

    def remove_define(self, define):
        for defs_element in self.tree.findall('./configurations/configuration/property[@name="DEFS"]'):
            deflist = defs_element.text.split(" ")
            defs_element.text = " ".join(d for d in deflist if d != define)

    def write(self, path):
        self.tree.write(path, encoding="UTF-8")

def create_path_and_copy(src, dest):
    try:
        copy_file(src, dest)
    except IOError as e:
        if e.errno != errno.ENOENT:
            raise
        os.makedirs(os.path.dirname(dest))
        shutil.copyfile(src, dest)

def copy_file(src, dest):
    print "Copy " + src + " to " + dest
    # Intentionally use copyfile rather than copy so permissions aren't preserved.
    # The resulting file will be writable.
    shutil.copyfile(src, dest)

if __name__ == "__main__":
    main()
