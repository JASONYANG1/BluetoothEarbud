#!/usr/bin/env python
# Copyright (c) 2016 Qualcomm Technologies International, Ltd.
#   Part of 6.2

#
# Generated Wed Feb 18 17:10:13 2015 by generateDS.py version 2.14a.
#
# Command line options:
#   ('-s', 'apids_sub.py')
#   ('-o', 'apids.py')
#
# Command line arguments:
#   api.xsd
#
# Command line:
#   \Users\sm35\Downloads\generateDS-2.14a\generateDS.py -s "apids_sub.py" -o "apids.py" api.xsd
#
# Current working directory (os.getcwd()):
#   interface
#

"""
These classes add customer trap API code-generation functionality to the 
generic XML access calls provided by their parents.  There are various flavours 
of this:

 - Trap API header creation.  This constructs prototypes for all functions in 
 the API, placing them in their indicated headers and protecting them with
 #if TRAPSET_XXX.  Doxygen markup is added to these prototypes.  This is 
 implemented via functions called "emit_header_code" in various of the classes.
 - IPC signal ID creation.  This constructs a single header fragment that is
 #included into the definition of the enum IPC_SIGNAL_ID in ipc_prim.h.  The
 signals generated include unique IPC signals for every autogenerated trap
 implementation - a "request" signal, plus a "response" signal for blocking
 traps.
 - IPC primitive creation.  This constructs structure definitions for the
 IPC primitives required by the autogenerated trap implementations.  There is
 a unique request primitive for each trap but response primitives are tied to
 the return types.  It might be better to combine request primitives to avoid
 duplication of essentially identical structures, but the only actual 
 duplication is in the DWARF information, since unlike functions structs don't 
 appear explicitly in the assembly code, and having them directly correspond to 
 specific function signatures makes for slightly simpler decoding
 - Trap "glue code" creation.  This constructs the implementations of each
 autogenerated trap.  There are two basic shapes for these function bodies.
 Non-blocking calls declare the corresponding IPC_PRIM, populate its field and
 then pass it into an ipc_send() call.  As well as doing this, blocking function
 bodies declare the response prim and post an ipc_recv call after the ipc_send,
 returning the "ret" field of the received response prim.  
"""

import sys
import re
import os

import apids as supermod

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

TRAP_API_IPC_SIGNAL_IDS_START = 0x8000

#
# Code generation helper functions
#

def dox_comment(emit_header_code_fn):
    def commented_(*args, **kwargs):
        code_lines = ["/**"]
        emitted_lines = emit_header_code_fn(*args, **kwargs)
        for i, line in enumerate(emitted_lines):
            emitted_lines[i] = " * %s" % line
        code_lines += emitted_lines
        code_lines += [" */"]
        return code_lines
    return commented_

def comment(emit_header_code_fn):
    def commented_(*args, **kwargs):
        code_lines = ["/*"]
        emitted_lines = emit_header_code_fn(*args, **kwargs)
        for i, line in enumerate(emitted_lines):
            emitted_lines[i] = " * %s" % line
        code_lines += emitted_lines
        code_lines += [" */"]
        return code_lines
    return commented_


SOURCE_CODE_RMARGIN = 80

def format_line_for_width(string, width=SOURCE_CODE_RMARGIN):
    """
    Split the supplied string into lines at the last space before it goes over
    the indicated margin
    """
    formatted = []
    for line in string.split("\n"):
        while len(line) > width:
            latest_space_at = line[:width].rfind(" ")
            if latest_space_at == -1:
                # No spaces in the line!
                raise ValueError("Can't format line - no spaces before "
                                 "column %d!" % width)
            subline = line[:latest_space_at]
            line = line[len(subline):]
            formatted.append(subline)
        if line:
            formatted.append(line)
    return formatted
    
def clean_for_doxygen(line_list):
    """
    Clean up Doxygen comment
    """
    for iline, line in enumerate(line_list):
        # Doxygen treats #XXX as an attempt to create a link to XXX, whereas
        # the VM API definitions use it to label messages
        line_list[iline] = line.replace("#", r"\#")
        # Doxygen is generally happier if you let it assume that the file you've
        # put your \file or @file tag into is the one you're talking about,
        # rather than giving an argument explicitly, which is often wrong or
        # ambiguous anyway
        line_list[iline] = re.sub(r"[\@\\](file\s+)[\w\.]+", r"\1", line_list[iline])

class ICodeGenerator(object):
    
    def emit_header_code(self):
        """
        Return a list of single-line strings containing code
        """
        raise NotImplementedError("Don't know how to emit code for a "
                                  "'%s'" % self.__class__.__name)

#
# Globals
#

ExternalEncoding = 'ascii'


#
# Data representation classes
#

class api_version_codegen(supermod.api_version, ICodeGenerator):
    def __init__(self, major=None, minor=None):
        super(api_version_codegen, self).__init__(major, minor, )
        
    @comment
    def emit_header_code(self):
        return["Version %d.%d" % (self.get_major(), self.get_minor())]
        
    # TODO Add emission of SLT entry for the version numbers
        
supermod.api_version.subclass = api_version_codegen
# end class api_version_codegen


class api_codegen(supermod.api):
    def __init__(self, version=None, traps=None, trapsets=None, messages=None):
        super(api_codegen, self).__init__(version, traps, trapsets, messages, )

    def set_trapset_filter_via_ifdefs(self, definition_dict):
        self.get_trapsets().set_trapset_filter_via_ifdefs(definition_dict)
                
    @comment
    def emit_warning(self):
        return ["This file is autogenerated from api.xml by api_codegen.py"]
        
    @dox_comment
    def emit_dox_api_group_def(self):
        return [r"\defgroup api Customer Trap API"]
    
    def emit_api_header(self):
        emitted_lines = []
        emitted_lines += self.emit_warning()
        emitted_lines += self.emit_dox_api_group_def() 
        return emitted_lines
        
    def emit_header_code(self):
        """
        Create a dictionary of trap API headers: the keys are the filenames
        and the values are lists of strings containing the source lines for those
        files
        """
        
        emitted_headers = {}
        
        # Create the base header, api.h
        emitted_lines = []
        emitted_lines += self.emit_api_header()
        emitted_lines += self.get_version().emit_header_code()
        emitted_lines += [""]*2
        emitted_lines += self.get_trapsets().emit_header_code()
        emitted_headers["api.h"] = emitted_lines
        
        # Create the rest of the headers from the trap definitions
        emitted_headers.update(self.get_traps().emit_header_code(self.trapsets))
        
        for hdr in emitted_headers.keys():
            hdr_element = None
            for h in self.get_headers().get_header():
                if h.hdr_name == hdr:
                    hdr_element = h
                    break
            if hdr_element is not None:
                preamble = hdr_element.emit_header_code()
            else:
                preamble = [r"/** \file */"]
            emitted_headers[hdr] = preamble + emitted_headers[hdr]
        
        # Add in any "forward" headers (i.e. headers explicitly created in
        # the API definition)
        for hdr in self.get_headers().get_header():
            if hdr.hdr_name not in emitted_headers:
                emitted_headers[hdr.hdr_name] = hdr.emit_header_code()
             
        # Add include guards to everything
        for hdr in emitted_headers:
            preamble = ["#ifndef __%s__" % hdr.replace(".","_").upper()]
            preamble += ["#define __%s__" % hdr.replace(".","_").upper()]
            emitted_headers[hdr] = preamble + emitted_headers[hdr] + ["#endif"]

        
        return emitted_headers
    
    def emit_ipc_signal_ids(self):
        """
        Create a list of source lines to be placed in a header fragment that
        extends the definition of the IPC_SIGNAL_ID enum
        """
        signal_ids = self.emit_warning()
        signal_ids += self.get_traps().emit_ipc_signal_ids(
                                                      self.trapsets.trapset_ids)
        signal_ids += ["IPC_SIGNAL_ID__SENTINEL__"]
        return signal_ids
    
    def emit_ipc_prims(self):
        """
        Create a list of source lines to be placed in a header fragment that
        extends the set of IPC primitive structure definitions
        """
        code = self.emit_warning()
        code += self.get_traps().emit_ipc_prims()
        return code
    
    def emit_ipc_recv_slow_glue(self):
        code = self.emit_warning()
        code += ['#include "memory_map.h"']
        code += self.get_traps().emit_ipc_recv_helper(False, "emit_ipc_recv_glue")
        return code
    
    def emit_ipc_recv_fast_glue(self):
        code = self.emit_warning()
        code += ['#include "memory_map.h"']
        code += self.get_traps().emit_ipc_recv_helper(True, "emit_ipc_recv_glue")
        return code
    
    def emit_ipc_recv_fast_cases(self):
        code = self.emit_warning()
        code += self.get_traps().emit_ipc_recv_helper(True, "emit_ipc_recv_fast_cases")
        return code
    
    def emit_ipc_send_glue(self):
        """
        Create a list of source lines to be placed in a separate .c file that
        contains standard implementatinos of all the trap functions that are
        declared (implicitly or explicitly) as autogenerated in api.xml
        """
        code = self.emit_warning()
        code += ["""#include "ipc/ipc.h" """, """#include "assert.h" """, ""]
        code += self.get_traps().emit_header_includes(self.trapsets)
        code += self.get_traps().emit_ipc_send_glue()
        return code
    
    def emit_slt_entry(self):
        num_words, bitmap_lines = self.get_trapsets().emit_slt_bitmap()
        
        preamble = [
            '#include "hydra/hydra_types.h"',
            "",
            "const uint32 trap_version[3] = {%d, %d, %d};" % 
                                             (self.get_version().get_major(),
                                              self.get_version().get_minor(),
                                              0),
            "",
            "const uint32 trapset_bitmap[%d] =" % (num_words),
            "{"]
        postamble = [
            "};",
            "",
            "const uint32 trapset_bitmap_length = %d;" % (num_words),
            "" ]
    
        return self.emit_warning() + preamble + bitmap_lines + postamble
    
supermod.api.subclass = api_codegen
# end class api_codegen


class traps_codegen(supermod.traps):
    
    NOT_TRAPSET_NAME = "__SPECIAL_INLINE"
    
    def __init__(self, version=None, trap=None):
        super(traps_codegen, self).__init__(version, trap, )

    def emit_header_code(self, trapsets):
        """
        Create a dictionary mapping header filenames to the source lines that
        they will contain, consisting of trap function prototypes.  The
        functions are organised into trapsets and protected by #if TRAPSET_XXX.
        """
        hdr_code = {}
        for trap in self.filtered_trap_list(stages=["DEAD"],  in_not_out=False):
            if trapsets._allow(trap.get_trapset()):
                hdr_attr = trap.get_header()
                if not hdr_attr: # Standard library functions don't have an API
                                 # header for obvious reasons
                    if DESKTOP_BUILD:
                        hdr_name = "csr_stdlib.h"
                    else:
                        # We don't emit header code for the standard library
                        # function implementations unless we're doing a unit
                        # test build
                        continue
                else:
                    hdr_name = "%s.h" % hdr_attr.lower()
                if hdr_name not in hdr_code:
                    hdr_code[hdr_name] = {}
                if trap.get_trapset() not in hdr_code[hdr_name]:
                    hdr_code[hdr_name][trap.get_trapset()] = []
                hdr_code[hdr_name][trap.get_trapset()] += trap.emit_header_code()
                
        emitted_headers = {}
        for hdr_name, trapset_code in hdr_code.iteritems():
            emitted_headers[hdr_name] = []
            for trapset, code in trapset_code.iteritems():
                if trapset != self.NOT_TRAPSET_NAME:
                    emitted_headers[hdr_name] += ["#if TRAPSET_%s" % trapset]
                emitted_headers[hdr_name] += code
                if trapset != self.NOT_TRAPSET_NAME:
                    emitted_headers[hdr_name] += ["#endif /* TRAPSET_%s */" % trapset]
        
        return emitted_headers

    def emit_header_includes(self, trapsets):
        """
        Create a list of #includes containing all the individual trap headers
        for insertion into source files that need to refer to all the trap
        function declarations, such as the trap API IPC glue source file.
        """
        code = []
        hdrs = self.emit_header_code(trapsets)
        for hdr in hdrs:
            code += ["""#include "trap_api/%s" """ % hdr]
        return code
            

    def emit_ipc_signal_ids(self, trapset_ids):
        """
        Create a list of enumerator declarations to identify the calls and
        responses of autogenerated traps over IPC.  These are numbered from a
        well-known start ID so as to make it easy to spot them.  We don't really
        need this, but whatever.
        """
        emitted_sources = []
        for trap in self.filtered_trap_list(stages=["DEAD"], in_not_out=False):
            if trap.is_autogen:
                new_enums = trap.emit_ipc_signal_ids(trapset_ids)
                emitted_sources += new_enums
        return emitted_sources
    
    def emit_ipc_prims(self):
        """
        Emit IPC primitives.  These need to be organised by TRAPSET so that they
        can be #ifdef'd in and out of builds.  We also need to avoid creating
        multiple copies of the same response primitive, as these will frequently
        be shared by multiple responses.
        """
        request_prims = {} # List of prims indexed by TRAPSET
        response_prims = {} # List of prims and the TRAPSETs that use them,
                            #indexed by name
        headers = set()
        for trap in self.filtered_trap_list(stages=["DEAD"], in_not_out=False):
            if trap.is_autogen:
                if trap.is_blocking:
                    ((req_prim_name, req_prim),
                    (rsp_prim_name, rsp_prim)) = trap.emit_ipc_prims()
                    if rsp_prim_name not in response_prims:
                        response_prims[rsp_prim_name] = (rsp_prim, [])
                    response_prims[rsp_prim_name][1].append(trap.get_trapset())
                else:
                    (req_prim_name, req_prim) = trap.emit_ipc_prims()
                
                if trap.get_trapset() not in request_prims:
                    request_prims[trap.get_trapset()] = []
                request_prims[trap.get_trapset()] += req_prim

                headers.add(trap.get_header())

        # Response prims that are only used by one trapset are added to the
        # request prims for that trapset
        reused_rsp_prims = {}
        for name, (prim_code, trapsets) in response_prims.iteritems():
            if len(trapsets) == 1:
                request_prims[trapsets[0]] += prim_code
            else:
                reused_rsp_prims[name] = prim_code

                     
        code = []
        for header in headers:
            code += ["""#include "trap_api/%s.h" """ % header.lower()]
        for trapset, prim_code in request_prims.iteritems():
            if trapset != self.NOT_TRAPSET_NAME:
                code += ["#if TRAPSET_%s" % trapset]
                code += prim_code
                code += ["#endif /* TRAPSET_%s */" % trapset,"",""]
            
        code += ["/*********************************************",
                 " * Prims used by multiple trapsets",
                 " *********************************************/"]
        for prim_code in reused_rsp_prims.itervalues():
            code += prim_code
            code += [""]

        code += ["/*********************************************",
                 " * Union containing all response primitives",
                 " *********************************************/"]
        code += ["typedef union IPC_RSP {"]
        response_prims_groups = {}
        for name, (prim_code, trapsets) in response_prims.iteritems():
            if len(trapsets) == 1:
                if trapsets[0] not in response_prims_groups:
                    response_prims_groups[trapsets[0]] = []
                response_prims_groups[trapsets[0]] += ["    %s %s;" % (name, name.lower())]
            else:
                code += ["    %s %s;" % (name, name.lower())]

        for name in response_prims_groups:
            code += ["#if TRAPSET_%s" % name]
            code += response_prims_groups[name]
            code += ["#endif /* TRAPSET_%s */" % name]
        code += ["} IPC_RSP;"]
        return code

    def emit_ipc_send_glue(self):
        """
        Create a list of source lines containing all the trap function bodies
        organised by trapset and suitably protected.
        """
        emitted_sources = {}
        headers = set()
        for trap in self.filtered_trap_list(stages=["DEAD"], in_not_out=False):
            if trap.is_autogen:
                headers.add(trap.get_header())
                if trap.get_trapset() not in emitted_sources:
                    emitted_sources[trap.get_trapset()] = []
                emitted_sources[trap.get_trapset()] += trap.emit_ipc_send_glue()
                
        code = []
        for hdr in headers:
            code += ["""#include "trap_api/%s.h" """ % hdr.lower()]
        code += [""]
        
        for trapset, prim_code in emitted_sources.iteritems():
            if trapset != self.NOT_TRAPSET_NAME:
                code += ["#if TRAPSET_%s" % trapset]
                code += prim_code
                code += ["#endif /* TRAPSET_%s */" % trapset,"",""]
        
        return code
                
    def emit_ipc_recv_helper(self, fast, emit_fn):
        emitted_sources = {}
        for trap in self.filtered_trap_list(stages=["DEAD"], in_not_out=False):
            if trap.is_autogen and (trap.is_fast == fast):
                if trap.get_trapset() not in emitted_sources:
                    emitted_sources[trap.get_trapset()] = []
                emitted_sources[trap.get_trapset()] += getattr(trap, emit_fn)()
 
        code = []
        for trapset, prim_code in emitted_sources.iteritems():
            # These are the only trapsets we have generic implementations for
            if trapset in ("STREAM", "USB", "USB_HUB", "OPERATOR", "AUDIO", "CORE",
                           "BLUESTACK", "ATT", "RFCOMM", "ENERGY", "NFC", "IIC", "IICSTREAM",
                           "FILE", "MICBIAS", "SD_MMC", "IMAGEUPGRADE", "CHARGER", "CHARGERMESSAGE",
                           "CSB", "IIR", "IIR16BIT", "AUDIO_MCLK", "CRYPTO", "PSU", "UART",
                           "AUDIO_PWM", "XIO", "BITSERIAL", "CAPACITIVE_SENSOR", 
                           "AUDIO_ANC", "WAKE_ON_AUDIO", "PROFILE", "OTP", "HOST"):
                code += ["#if TRAPSET_%s" % trapset]
                code += prim_code
                code += ["#endif /* TRAPSET_%s */" % trapset,"",""]
        
        return code

    def filtered_trap_list(self, stages, in_not_out):
        """
        Return all the traps that have a lifstage which passes a given filter.
        """
        for trap in self.get_trap():
            if (trap.get_lifestage() in stages) == in_not_out:
                yield trap

supermod.traps.subclass = traps_codegen
# end class traps_codegen


class trapsets_codegen(supermod.trapsets):
    def __init__(self, trapset=None):
        super(trapsets_codegen, self).__init__(trapset, )

    def set_trapset_filter_via_ifdefs(self, build_definitions_dict):
        self._build_defs_dict = build_definitions_dict
                 
    def _allow(self, trapset_name):
        """
        Decide whether a given trapset should be included in the filtered list
        or not
        """
        try:
            return self._build_defs_dict.get("TRAPSET_" + trapset_name, False)
        except AttributeError:
            return True
            
        
    @property
    def _filter(self):
        """
        Generator the yields a list of the trapsets that are "allowed" with the
        given inputs.  At the time of writing the filtering is trivial - 
        everything is "allowed"
        """
        for trapset in self.trapset:
            if self._allow(trapset.get_name()):
                yield trapset
    
    @property
    def trapset_ids(self):
        """
        A dictionary mapping trapset names to IDs
        """
        d = {}
        for trapset in self.trapset:
            d[trapset.get_name()] = trapset.get_index()
        return d
        
    @comment
    def emit_trapsets_header(self):
        return ["TRAPSETS"]
        
    def emit_header_code(self):
        """
        Loop over "allowed" trapsets adding their header code fragment.  This
        is for inclusion in the general header api.h
        """
        emitted_lines = []
        emitted_lines += self.emit_trapsets_header()
        for trapset in self._filter:
            emitted_lines += trapset.emit_header_code();
        return emitted_lines
    
    def emit_slt_bitmap(self):
        """
        Emit a bitmap in a uint32 array indicating which trapsets are supported.
        This relies on C supporting incomplete initialisers.  We also indicate
        the number of words required for the array
        """
        
        current_word = 0
        emitted_lines = []
        for trapset in self._filter:
            
            new_word = trapset.get_index() / 32
            while current_word < new_word:
                emitted_lines.append("    0U,")
                current_word += 1
            emitted_lines += ["    (1 << %2d) | /* %s */" % (
                                          trapset.get_index() - new_word * 32, 
                                          trapset.get_name())] 
        emitted_lines.append("    0U")
        return (len(self.trapset) + 31)/32, emitted_lines
        
        
supermod.trapsets.subclass = trapsets_codegen
# end class trapsets_codegen

class header_codegen(supermod.header):
    def __init__(self, extra_header=None, preamble=None):
        super(header_codegen, self).__init__(extra_header, preamble, )
        
    @property
    def hdr_name(self):
        return "%s.h" % self.get_name().lower()
        
    def emit_header_code(self):
        """
        Return the lines that make up the arbitrary preamble given for the header
        within syscalls.in
        """
        code = []
        for hdr in self.get_extra_header():
            code += ["""#include <%s>""" % hdr]
        doxygen_lines = []
        for line in self.get_preamble().split("\n"):
            if (doxygen_lines or 
                    line.lstrip().startswith(r"/**") or
                    line.lstrip().startswith(r"/*!")):
                end_cmnt = line.find("*/")
                if end_cmnt != -1:
                    doxygen_lines.append(line[:end_cmnt+2])
                    clean_for_doxygen(doxygen_lines)
                    code += doxygen_lines
                    doxygen_lines = [] 
                else:
                    doxygen_lines.append(line)
            else:
                code.append(line)
        return code
        
supermod.header.subclass = header_codegen
# end class header_codegen




class messages_codegen(supermod.messages):
    def __init__(self, base=None, message=None):
        super(messages_codegen, self).__init__(base, message, )
supermod.messages.subclass = messages_codegen
# end class messages_codegen


class trapset_codegen(supermod.trapset):
    def __init__(self, name=None, builddefs=None, document=None):
        super(trapset_codegen, self).__init__(name, builddefs, document, )

    def emit_trapset_doxygen_group(self):
        return [r"\defgroup trapset_%s %s" % (self.get_name().lower(),
                                                        self.get_name()),
                r"\ingroup api"]
    @dox_comment
    def emit_trapset_doxygen(self):
        emitted_lines = self.emit_trapset_doxygen_group()
        if self.get_document():
            emitted_lines += self.get_document().emit_doxygen_fragment()
        return emitted_lines
        
    def emit_header_code(self):
        """
        Create a header fragment declaring a Doxygen group for this trapset and
        adding whatever documentation has been supplied for the trapset itself
        in api.xml
        """
        emitted_lines = []
        
        emitted_lines += self.emit_trapset_doxygen()
        return emitted_lines
        
supermod.trapset.subclass = trapset_codegen
# end class trapset_codegen


class trap_codegen(supermod.trap):
    """
    This class contains all the code autogeneration logic for an individual trap
    """
    def __init__(self, header=None, processor=None, trapset=None, name=None, lifestage=None, return_=None, params=None, document=None):
        super(trap_codegen, self).__init__(header, processor, trapset, name, lifestage, return_, params, document, )
        
    def get_ipc_name(self):
        """
        Nasty bit of string manipulation that turns
        
        GetAdcValue into GET_ADC_VALUE
        GetAdc2Value into GET_ADC2_VALUE
        GetADCValue into GET_ADC_VALUE
        etc
        
        in an attempt to give the glue IPC primitives "natural" names
        """
        
        # Find all capital letters' indices
        caps = [m.start() for m in re.finditer(r"[A-Z]", self.get_name())]
        # Split the string into substrings starting with the capitals
        substrings = [""]*len(caps)
        for i,ind in enumerate(caps):
            if i+1 < len(caps):
                substrings[i] = self.get_name()[caps[i]:caps[i+1]]
            else:
                substrings[i] = self.get_name()[caps[i]:]
        
        return "_".join(s.upper() for s in substrings)
        
    @property
    def is_blocking(self):
        """
        Implements the logic for determining whether to implement a given 
        autogenerated trap as blocking (waits for a specific IPC response prim) 
        or non-blocking (just does an IPC send).  If there's no explicit
        "blocking" attribute, the trap is blocking iff its return type is not
        void.
        """
        
        blocking_attr = self.get_blocking()
        if blocking_attr is None:
            return self.get_return().get_type() != "void"
        else:
            return blocking_attr

    @property
    def is_fast(self):
        """
        Is this a fast blocking trap (by default, no)
        """
        fast_attr = self.get_fast()
        if fast_attr is None:
            return False
        else:
            return fast_attr

    @property
    def is_autogen(self):
        """
        Handles the absence of an explicit "autogen" attribute in the trap
        definition by making a trap "autogen" iff it's on P0 
        """
        autogen_attr = self.get_autogen()
        if autogen_attr is None:
            return self.processor == "CSR"
        return autogen_attr != "false"

    @property
    def prim_name(self):
        """
        Name of the IPC primitive associated with this trap (may or may not
        actually be emitted, depending on whether it's needed or not)
        """
        return "IPC_%s" % self.get_ipc_name()
    
    @property
    def rsp_prim_name(self):
        """
        Name of the response primitive for blocking calls.  If the call 
        returns values in pointers we have to have a special prim for this.
        """
        if self.is_blocking:
            if self.get_params().has_out_params:
                return "IPC_%s_RSP" % self.get_ipc_name()
            else:
                return "IPC_%s_RSP" % self.return_type_prim_name
        else:
            return None
        

    @comment
    def emit_trap_name_comment(self):
        return [self.name]
    
    def emit_trap_signature(self):
        """
        Create a source line containing the trap signature.
        
        To support unit test builds, the trap functions which implement C 
        standard library routines (malloc, free, etc) have their names munged
        here to avoid conflicts with the "real" implementations.
        """
        global DESKTOP_BUILD
        
        param_signature = self.get_params().emit_signature()
        
        name = self.get_name()
        if not self.get_header():
            assert DESKTOP_BUILD
            name = name+"_csr"
        signature = "%s %s(%s)" % (self.get_return().emit_signature(), 
                                    name, ", ".join(param_signature))
        return [signature]
                                   
        
        
    @dox_comment
    def emit_doxygen(self):
        """
        Create a list of source lines containing Doxygen mark-up that built
        directly from the documentation in api.xml
        """
        emitted_lines = []
        brief_desc = format_line_for_width(self.get_document().get_description())
        if brief_desc:
            brief_desc[0] = r" \brief %s" % brief_desc[0]
            emitted_lines += brief_desc
        
        if self.get_document().get_documentation():
            emitted_lines += []
            emitted_lines += format_line_for_width(self.get_document().get_documentation())
            
        if self.get_params().param:
            emitted_lines += []
        for param in self.get_params().param:
            param_desc = format_line_for_width(param.get_document().get_description())
            if param_desc:
                param_desc[0] = r" \param %s %s" % (param.get_name(), param_desc[0])
                emitted_lines += param_desc
        
        if self.get_return().get_type():
            emitted_lines += [] 
            ret_desc = format_line_for_width(self.get_return().get_document().get_description())
            if ret_desc:
                ret_desc[0] = r" \return %s" % (ret_desc[0])
                emitted_lines += ret_desc
            
        emitted_lines += [""]
        emitted_lines += [r"\note This trap may %sbe called from a high-priority"
                          " task handler" % ("" if self.is_fast or 
                                                    not self.is_blocking
                                                else "NOT ")]
                 
        emitted_lines += [""]
        emitted_lines += [r"\ingroup trapset_%s" % self.get_trapset().lower()]
                 
        # Add a warning to the documentation for any abnormal lifestage
        if self.get_lifestage():
            emitted_lines += [""]
            emitted_lines += ["WARNING: This trap is %s" % self.get_lifestage()]
                 
        clean_for_doxygen(emitted_lines)
                 
        return emitted_lines
        
    def emit_header_code(self):
        """
        Assemble the trap's Doxygen above its signature to create a full 
        function definition
        """
        emitted_lines = [""]
        emitted_lines += self.emit_doxygen()
        emitted_lines += self.emit_trap_signature()
        emitted_lines[-1] += ";" 
        return emitted_lines
        
    def emit_ipc_signal_ids(self, trapset_ids):
        """
        Generates the lines to be included in the IPC_SIGNALS enum, with the
        given trapset_id
        """
        # Uses the traps universal 32-bit ID to uniquely and permanently 
        # identify the IPC message.  Need to get the trapset's ID first
        if self.get_trapset() != "__SPECIAL_INLINE":
            try:
                trapset_id = trapset_ids[self.get_trapset()]
            except KeyError:  
                print trapset_ids
                raise
            send_id = trapset_id << 16 | int(self.get_tmi())
            # First create an enumerator for the "call" signal ID.  T
            enumerators = ["IPC_SIGNAL_ID_%s = 0x%x," % (self.get_ipc_name(),
                                                        send_id)]
            # then if necessary a response signal ID
            if self.is_blocking:
                recv_id = send_id | 1 << 15
                enumerators += ["IPC_SIGNAL_ID_%s_RSP = 0x%x," % (self.get_ipc_name(),
                                                                 recv_id)]
            return enumerators
        else:
            return []

    @property
    def return_type(self):
        """
        Convenient access to the trap's return type
        """
        return self.get_return().get_type()
    
    @property
    def prim_return_type(self):
        """
        Munge the return type that should appear in the return prim
        """
        return re.sub(r"(Source|Sink|Transform)", "uint16", self.return_type)
    
    @property
    def return_type_prim_name(self):
        """
        Munge return types into a valid string for use in IPC primitive
        names
        """
        return re.sub(r"\s*\*","_PTR", "_".join(self.return_type.upper().split()))
        
    def emit_ipc_prims(self):
        """
        Generates named structure definitions based on the parameters and (if
        necessary, return type) of the trap
        """
        if self.is_autogen:
            req_prim = []
            req_prim += ["typedef struct %s {" % self.prim_name]
            req_prim += ["    IPC_HEADER header;"]
            if not self.get_params().is_void:
                for param in self.get_params().get_param():
                    if param.is_in:
                        req_prim += ["    %s;" % param.in_prim_signature]
            req_prim += ["} %s;" % self.prim_name, ""]
            
            if self.is_blocking:
                rsp_prim = []
                rsp_prim += ["typedef struct %s {" % self.rsp_prim_name]
                rsp_prim += ["    IPC_HEADER header;"]
                if self.return_type != "void":
                    rsp_prim += ["    %s ret;" % self.prim_return_type]
                # Add in any "OUT" params as well
                for param in self.get_params().get_param():
                    if param.is_out:
                        rsp_prim += ["    %s;" % param.out_prim_signature]
                rsp_prim += ["} %s;" % self.rsp_prim_name]
                
                return (self.prim_name, req_prim),(self.rsp_prim_name, rsp_prim)
                
            return self.prim_name, req_prim
        return None
        
    def emit_ipc_send_glue(self):
        """
        Create the autogenerated trap function body.  
        
        This isn't possible if the trap has "return value" parameters that are 
        more than a single integer value we don't have enough information to do 
        the required copy.  In this case this function emits nothing and the
        programmer must provide the implementation. 
        """
        if self.get_params().has_out_non_integer_params:
            return []
        
        if self.get_params().has_bd_addr_parms:
            return []

        code = self.emit_trap_signature()
        code +=     [  "{" ]
        code +=     [  "    IPC_%s ipc_send_prim;"  % self.get_ipc_name()]
        if self.is_blocking:
            code += ([  "    %s ipc_recv_prim;" % self.rsp_prim_name])
            
        if not self.get_params().is_void:
            for param in self.get_params().get_param():
                if param.is_in:
                    if param.prim_field_type in ("Source", "Sink", "Transform"):
                        code += [  "    ipc_send_prim.%s = %s_TO_ID(%s);" % (param.prim_field_name,
                                                                             param.prim_field_type.upper(), 
                                                               param.get_name())]
                    else:
                        code += [  "    ipc_send_prim.%s = %s;" % (param.prim_field_name, 
                                                               param.get_name())]

        code +=     [  "    ipc_send(IPC_SIGNAL_ID_%s, &ipc_send_prim, sizeof(ipc_send_prim));" % self.get_ipc_name()]
        if self.is_blocking:
            if self.is_fast:
                code += [  "    (void)ipc_recv_atomic(IPC_SIGNAL_ID_%s_RSP, &ipc_recv_prim);" % self.get_ipc_name()]
            else:
                code += [  "    assert(!ipc_disallow_high_priority_handler_calls());"]
                code += [  "    (void)ipc_recv(IPC_SIGNAL_ID_%s_RSP, &ipc_recv_prim);" % self.get_ipc_name()]
            for param in self.get_params().get_param():
                if param.is_out and not param.get_array():
                    code += [  "    if (%s != NULL)" % param.get_name()]
                    code += [  "    {"]
                    code += [  "      *%s = ipc_recv_prim.%s;" % (param.get_name(), 
                                                                param.get_name())]
                    code += [  "    }"]
            if self.return_type != "void":
                if self.return_type in ("Source", "Sink", "Transform"):
                    code += [  "    return %s_FROM_ID(ipc_recv_prim.ret);" % 
                                                    self.return_type.upper()]
                else:
                    code += [  "    return ipc_recv_prim.ret;"]
        code +=     [  "}"]
        code += ["",""]
        return code


    def emit_ipc_recv_fast_cases(self):
        code = ["                        case IPC_SIGNAL_ID_%s:" % self.get_ipc_name()]
        code += []
        return code


    def emit_ipc_recv_glue(self):
        """
        Create the autogenerated trap IPC recv body
        """
        is_blocking = self.get_autogen() != "p0_non_block" and self.is_blocking
        code =  ["    case IPC_SIGNAL_ID_%s:" % self.get_ipc_name()]
        code += ["    {"]
        if not self.get_params().is_void and not self.get_params().has_all_out_params:
            code += ["        const %s *ipc_prim = (const %s *)prim;" % (
                                                                self.prim_name,
                                                                self.prim_name)]
        if is_blocking:
            if self.return_type != "void":
                code += ["        rsp_prim.%s.ret = vm_trap_%s" % (
                                                     self.rsp_prim_name.lower(),
                                                     self.name)]
            else:
                code += ["        vm_trap_%s" % self.name]
        else:
            code += [ "        vm_trap_%s" % (self.name)]
        code += ["        ("]
        # Now pass in the arguments, one at a time, in params first, followed by
        # out params
        if not self.get_params().is_void:
            for param in self.get_params().get_param():
                if param.is_in:
                    if param.is_ptr and param.is_const:
                        # There is an issue with accessing P1 SQIF
                        # from P0 when P1 is in shallow sleep.
                        # The workaround it to check all constant pointers
                        # in the traps and modify those that fall into the
                        # P1 SQIF window to access the same data through
                        # the P0 SQIF window. This is OK as long as 
                        # P0 and P1 share the same SQIF
                        # We only want this if
                        # CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 is defined.
                        code += ["#ifdef CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036"]
                        code += ["            " + \
   "MEMORY_MAP_ADJUST_CONST_P1_P0(ipc_prim->%s, %s)" % (param.prim_field_name, 
                                                         param.in_prim_field_type)]
                        code += ["#else"]
                        code += ["            " + \
                                   "ipc_prim->%s" % param.prim_field_name]
                        code += ["#endif /* CHIP_DEF_P1_SQIF_SHALLOW_SLEEP_WA_B_195036 */"]
                        code += ["            ,"]
                    else:
                        code += ["            " + \
                                   "ipc_prim->%s," % param.prim_field_name]
                        
            if is_blocking:
                for param in self.get_params().get_param():
                    if param.is_out:
                        code += ["            &rsp_prim.%s.%s," % (
                                                    self.rsp_prim_name.lower(),
                                                    param.out_prim_field_ref)]
            
        # replace the final comma with a closing bracket
        code[-1] = code[-1].rstrip(",")
        code += ["        );"]
        if is_blocking:
            # Send back the response prim
            code += ["        ipc_send(IPC_SIGNAL_ID_%s_RSP," %
                                                     self.get_ipc_name()]
            code += ["                 &rsp_prim.%s," %
                                                     self.rsp_prim_name.lower()]
            code += ["                 sizeof(rsp_prim.%s));" %
                                                     self.rsp_prim_name.lower()]

        code += ["    }"]
        code += ["        break;"]
        code += []
        
        return code

        
supermod.trap.subclass = trap_codegen
# end class trap_codegen


class message_codegen(supermod.message):
    def __init__(self, msgidx=None, name=None, params=None, document=None):
        super(message_codegen, self).__init__(msgidx, name, params, document, )
supermod.message.subclass = message_codegen
# end class message_codegen


class return__codegen(supermod.return_):
    def __init__(self, type_=None, document=None, extensiontype_=None):
        super(return__codegen, self).__init__(type_, document, extensiontype_, )

    def emit_signature(self):
        return "%s" % self.get_type()

supermod.return_.subclass = return__codegen
# end class return__codegen


class params_codegen(supermod.params):
    def __init__(self, param=None):
        super(params_codegen, self).__init__(param, )
        
    def emit_signature(self):
        params = []
        for param in self.param:
            params += param.emit_signature()
        return params
    
    @property
    def has_out_params(self):
        for param in self.param:
            if param.is_out:
                return True
        return False

    @property
    def has_out_non_integer_params(self):
        for param in self.param:
            if (param.is_out and (param.get_array() or 
                  not param.prim_field_type in ("bool", "int16", "uint16",
                                                "int32", "uint32"))):
                return True
        return False
    
    @property
    def has_bd_addr_parms(self):
        for param in self.param:
            if (param.is_bd_addr): 
                return True
        return False
        
    @property
    def is_void(self):
        return len(self.param) == 1 and self.param[0].get_type() == "void" 
        
    @property
    def has_all_out_params(self):
        return all(param.is_out for param in self.param)

supermod.params.subclass = params_codegen
# end class params_codegen


class param_codegen(supermod.param):
    
    _type_translations = {"tp_bdaddr" : "TP_BD_ADDR_T", "bdaddr" : "BD_ADDR_T"}
    
    def __init__(self, type_=None, document=None, direction='IN', name=None):
        super(param_codegen, self).__init__(type_, document, direction, name, )
        
    def emit_signature(self):
        """
        Create a signature fragment like "uint16 data"
        """
        return ["%s %s" % (self.get_type(), self.get_name())]

    @property
    def in_prim_signature(self):
        return "%s %s" % (self.in_prim_field_type, self.prim_field_name)

    @property
    def out_prim_signature(self):
        return "%s %s" % (self.out_prim_field_type, self.prim_field_name)
        
    @property
    def is_inout(self):
        return self.get_direction() == "IN OUT"
    
    @property
    def prim_field_name(self):
        name = self.get_name()
        if name == "header":
            name = "header_" # to avoid a name clash with the IPC_HEADER field
        return name

    @property
    def is_ptr(self):
        return "*" in self.get_type()

    @property
    def is_void_ptr(self):
        return "void" in self.get_type() and self.is_ptr

    @property
    def is_bd_addr(self):
        keywords = self.get_type().replace('*','').split(" ")
        return ("bdaddr" in keywords) or ("tp_bdaddr" in keywords)

    @property
    def is_const(self):
        return "const" in self.get_type()

    @property
    def is_in(self):
        return self.get_direction() != "OUT"
    
    @property
    def is_out(self):
        return self.get_direction() != "IN"

    @property
    def prim_field_type(self):
        type = self.get_type()
        for otype, ntype in self._type_translations.iteritems():
            type = type.replace(otype,ntype)
        if self.is_out and not self.get_array() and not self.is_void_ptr:
            # If the pointer parameter is used to hold a single value rather
            # than an array, we copy the value into/out of the IPC prim
            type = type.replace("*","").rstrip()
        return type

    @property
    def out_prim_field_type(self):
        return re.sub(r"(Source|Sink|Transform)","uint16", self.prim_field_type)

    @property
    def in_prim_field_type(self):
        return self.out_prim_field_type
        
    @property
    def out_prim_field_ref(self):
        return self.prim_field_name
        
supermod.param.subclass = param_codegen
# end class param_codegen


class keypair_codegen(supermod.keypair):
    def __init__(self, valuetype=None, document=None):
        super(keypair_codegen, self).__init__(valuetype, document, )
supermod.keypair.subclass = keypair_codegen
# end class keypair_codegen


class document_codegen(supermod.document):
    def __init__(self, description=None, documentation=None, comment=None):
        super(document_codegen, self).__init__(description, documentation, comment, )
        
    def emit_doxygen_fragment(self):
        """
        Convert the document to Doxygen format
        """
        emitted_lines = []
        brief_desc = format_line_for_width(self.get_document().get_description())
        if brief_desc:
            brief_desc[0] = r" \brief %s" % brief_desc[0]
            emitted_lines += brief_desc
        if self.get_documentation():
            emitted_lines += format_line_for_width(self.get_documentation())
        return emitted_lines
        
supermod.document.subclass = document_codegen
# end class document_codegen


def get_root_tag(node):
    tag = supermod.Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = None
    rootClass = supermod.GDSClassesMapping.get(tag)
    if rootClass is None and hasattr(supermod, tag):
        rootClass = getattr(supermod, tag)
    return tag, rootClass


def parse(inFilename, silence=False):
    doc = parsexml_(inFilename)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'api_version'
        rootClass = supermod.api_version
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFilename, silence=False):
    doc = parsexml_(inFilename)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'api_version'
        rootClass = supermod.api_version
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'api_version'
        rootClass = supermod.api_version
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFilename, silence=False):
    doc = parsexml_(inFilename)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'api_version'
        rootClass = supermod.api_version
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from ??? import *\n\n')
        sys.stdout.write('import ??? as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


USAGE_TEXT = """
Usage: python api_codegen.py -h|-s <infilename> -o <outdirname>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def write_out_source_files(outdirname, code_lines_dict):
    for source_file_name, source_lines in code_lines_dict.iteritems():
        write_out_source_file(os.path.join(outdirname,source_file_name), 
                              source_lines)

def write_out_source_file(outfilename, code_lines):
    try:
        with open(outfilename, "w") as out:
            out.write("\n".join(code_lines) + "\n")
    except IOError:
        print "Couldn't open %s for writing" % outfilename

def read_defines_file_into_dict(defines_filename):
    """A function to take a last_defines.h file and return a 
    dictionary of settings. Entries are cast to int type if
    possible. Otherwise they are string type.
    """
    defs = {}
    with open(defines_filename, "rU") as defines_file:
        for line in defines_file:
            if line.startswith("#define"):
                line_parse = line.split()
                try:
                    value = int(line_parse[2])
                except ValueError:
                    value = line_parse[2]
                except IndexError:
                    value = 0
                defs[line_parse[1]] = value
    return defs
            

def main():
    global DESKTOP_BUILD
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("--header",dest="header",action="store_true")
    parser.add_option("--ipc-send-glue",dest="ipc_send_glue",action="store_true")
    parser.add_option("--ipc-prims",dest="ipc_prims",action="store_true")
    parser.add_option("--ipc-signals",dest="ipc_signals",action="store_true")
    parser.add_option("--ipc-recv-glue",dest="ipc_recv_glue",action="store_true")
    parser.add_option("--ipc-recv-fast-glue",dest="ipc_recv_fast_glue",action="store_true")
    parser.add_option("--ipc-recv-fast-cases",dest="ipc_recv_fast_cases",action="store_true")
    parser.add_option("--slt", dest="slt",action="store_true")
    parser.add_option("--available", dest="available",action="store_true")
    parser.add_option("-i", "--inname", type="string", dest="inname")
    parser.add_option("-o", "--outname", type="string", dest="outname")
    parser.add_option("-d", "--definition-file", type="string", dest="build_defs_h_name")

    options, args = parser.parse_args()
    infilename = options.inname
    outname = options.outname
    
    api = parse(infilename, silence=True)
    if options.build_defs_h_name:
        api.set_trapset_filter_via_ifdefs(
                      read_defines_file_into_dict(options.build_defs_h_name))
    
    if outname is not None:
        DESKTOP_BUILD = ("linux" in outname or "win32" in outname)
    
    if options.header:
        write_out_source_files(outname, api.emit_header_code())
    elif options.ipc_send_glue:
        write_out_source_file(outname, api.emit_ipc_send_glue())
    elif options.ipc_prims:
        write_out_source_file(outname, api.emit_ipc_prims())
    elif options.ipc_signals:
        write_out_source_file(outname, api.emit_ipc_signal_ids())
    elif options.ipc_recv_glue:
        write_out_source_file(outname, api.emit_ipc_recv_slow_glue())
    elif options.ipc_recv_fast_glue:
        write_out_source_file(outname, api.emit_ipc_recv_fast_glue())
    elif options.ipc_recv_fast_cases:
        write_out_source_file(outname, api.emit_ipc_recv_fast_cases())
    elif options.slt:
        write_out_source_file(outname, api.emit_slt_entry())
    elif options.available:
        for trap in api.get_traps().filtered_trap_list(stages=[""], in_not_out=True):
            sys.stdout.write(trap.get_name()+"\n")


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
