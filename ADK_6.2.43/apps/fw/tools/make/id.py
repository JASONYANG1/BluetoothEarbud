# Copyright (c) 2016 Qualcomm Technologies International, Ltd.
#   Part of 6.2
# FILE
#   id.py  -  generate firmware build identifiers
#
# DESCRIPTION
#   Generate various identifiers required by a particular firmware build.
#
#   Usage:
#       id.py [-v] [-n] [-z] [-e] [-d <directory>] [-h <history file>]
#             -c <configuration> -o number|string|summary
#
#   -v
#       Output more detailed information.
#
#   -n
#       Do not modify the history file.
#
#   -z
#       Record this build identifier as used. This option should be invoked
#       once on successful completion of each build, after all necessary
#       identifiers have been generated. Different identifiers will be
#       produced the next time that this script is invoked for the same
#       configuration.
#
#   -e
#       Fail on error. This is to ensure we don't make releases
#       with open files and the like
#
#   -d <directory>
#       The directory in which this build is being performed. This is used
#       for two purposes; it uniquely identifies a particular build when
#       multiple checkouts exist, and it is treated as the root for obtaining
#       the most recent change number from Perforce. However, it is not used
#       to access or store any files. If this option is omitted then the
#       current working directory is assumed.
#
#   -h <history file>
#       Name of file used to store history of build identifiers for this
#       user. If the file does not exist then it is assumed that this is the
#       first attempt to assign an identifier by this user. If this option
#       is omitted then a default filename in the user's home directory is
#       used instead.
#
#   -c <configuration>
#       The name of this build configuration. This must be constant for all stages of
#       the build and be different for simultaneous builds. This is because
#       it is used to unique identify builds to ensure that the same counter
#       is reused.
#
#   -o number|string|summary
#       Output the specified identifier. If "summary" is specified then all
#       of the identifiers are displayed in user-friendly form.
#
#   Arguments in the IDEXTRAARGS environment variable are prepended to the
#   command-line arguments.
#
#   This script can currently generate the following identifiers:
#
#       Textual build name
#
#           This is a string similar to the long BlueCore build name. It is
#           formatted as follows:
#               YYYY-MM-DD HH:MM <config> <build> <user>@<host>@<change>
#
#       Integral build number
#
#           A simple (32 bit) build number that can be used by tools and is
#           less susceptible to transcription errors when reported by
#           non-developers (customers). This is unique for every build
#           produced, regardless of whether intended for release. It is
#           generated by combining the UNIX user ID (uid) of the current
#           account with an incrementing counter stored in the user's home
#           directory.
#
#   The history file used to maintain the user's current build should contain
#   a line beginning with "next" giving the first unused counter value, zero
#   or more lines beginning with "reserved" listing values that have been
#   reserved for builds yet to complete successfully, and optionally a line
#   beginning with "uid" to override the logon user's uid:
#       next <count>
#       reserved <count> <directory> <configuration> <string>
#       reserved <count> <directory> <configuration> <string>
#       uid <uid>
#
#   If the build is being performed on a host that does not share noo-noo's
#   passwd file then a unique uid must be specified in the history file. This
#   is required to ensure that the generated build identifiers remain unique.
#   The recommended value is the (usual) user's uid on noo-noo (as reported
#   by 'id') plus 1000 or 2000 for building on the user's Windows PC or laptop
#   respectively.

import sys, os, re, time, subprocess, optparse, shutil

try:
    import fcntl
    have_fcntl = True
except ImportError:
    have_fcntl = False # Probably running on windoze where we don't care

# A function to hide tha pain of trying to do `cmd` simply
def call_command(cmd):
    try:
        proc = subprocess.Popen(cmd, stdout = subprocess.PIPE)
        for line in proc.stdout:
            return line.strip()
        # Now read the value of host from proc.stdout
    except subprocess.CalledProcessError:
        return ""

# Default name of history file (in user's home directory)
default_history = '.app_ss_ids'

# Multiplier for uid when constructing numeric build identifier
# (uids 0 to 4094, and approximately 200 builds per working day for 20 years)
multiply_uid = 1000000

# Special user and host names that require uid to be specified explicitly
special_users = ["csr", "root", "appsw"]
special_hosts = ["pc", "2k", "lap"]

# Process command line arguments

usage = "%prog [-v] [-n] [-z] [-e] [-d <directory>] [-h <history file>] \
-c <configuration> -o number|string|summary\n"

parser = optparse.OptionParser(usage=usage)
parser.add_option("-v", action="store_true", dest="verbose", default=False, help="turn on verbose output")
parser.add_option("-n", action="store_true", dest="noexecute", default=False, help="do not modify history file")
parser.add_option("-z", action="store_true", dest="finished", default=False, help="record this build identifier as used")
parser.add_option("-e", action="store_true", dest="fail_on_error", default=False, help="fail on error")
parser.add_option("-c", action="store", type="string", dest="configuration", default="", help="the name of this build configuration")
parser.add_option("-d", action="store", type="string", dest="directory", default="", help="the directory in which this build is being performed")
# We want -h to mean something else
parser.remove_option("-h")
# Unfortunately, this throw away --help as well
parser.add_option("-h", action="store", type="string", dest="history", default="", help="name of file used to store history of build identifiers")
parser.add_option("-o", action="store", type="string", dest="output", default="", help="output the specified identifier")
parser.add_option("--help", action="help", help="show this help message and exit")
(options, args) = parser.parse_args()

argv = sys.argv
failed = False
output_types = ["number", "string", "summary"]

verbose = options.verbose
noexecute = options.noexecute
finished = options.finished
fail_on_error = options.fail_on_error
configuration = options.configuration
directory = options.directory
history = options.history
output = options.output

# Check parameter consistency
if "" == configuration:
    sys.stderr.write("%s: no -c <configuration> option specified\n" % argv[0])
if "" == output:
    sys.stderr.write("%s: no -o <output> option specified\n" % argv[0])
elif not (output in output_types):
    sys.stderr.write("%s: %s is not a supported output format\n" % (argv[0], output))

if failed:
    sys.stderr.write("%s: bad arguments\n" % argv[0])
    sys.stderr.write(
        "%s: usage: %s [-v] [-n] [-z] [-e] [-d <directory>] [-h <history file>] \
        -c <configuration> -o number|string|summary\n" % (argv[0], argv[0]))
    sys.exit(1)

if verbose:
    sys.stderr.write("configuration = %s\n" % configuration)

p4_available = True

try:
    from P4 import P4, P4Exception, Map
except ImportError:
    p4_available = False

# Sort out p4 access
# Ensure we pick up any local Perforce configuration using our normal
# convention, in case the environment we get is a bit naff.
os.environ["P4CONFIG"] = ".p4config"

# P4 may have trouble under DOS, like everything else
# So we give it a helping hand
profile = ""
if "USERPROFILE" in os.environ:
    profile = os.environ["USERPROFILE"]
    if "" != profile:
        profile = profile.replace("\\", "/")
        os.environ["P4TICKETS"] = profile + "/p4tickets.txt"

if p4_available:
    p4 = P4()
    try:
        p4.connect()
    except P4Exception:
        if verbose:
            sys.stderr.write("P4 not available\n")
        p4_available = False

is_cygwin = False
if p4_available and "CYGWINX86" in P4.identify():
    is_cygwin = True

# Normalise the directory
# Use cygpath first if we need to
if is_cygwin:
    directory = call_command(["cygpath",  directory])
directory = os.path.abspath(directory)
if verbose:
    sys.stderr.write("directory = %s\n" % directory)

if p4_available:
    try:
        # Windoze, as usual, can get in a right pickle here
        # So, make it assume that directory is its current working directory
        p4.cwd = directory
        p4_client = p4.run_client('-o')
        # print p4_client
    except P4Exception:
        for e in p4.errors:
            sys.stderr.write("%s: %s\n" % (argv[0], e))
            p4.disconnect()
        sys.exit(1)

if verbose:
    if p4_available:
        sys.stderr.write("p4_available: yes\n")
    else:
        sys.stderr.write("p4_available: no\n")

# Determine most recent Perforce changelist and whether any files are modified
change = 'unknown'
p4_opened = []
if p4_available:
    change = ''
    try:
        p4_changes = p4.run_changes('-m1', "%s/...#have" % directory)
        # print p4_changes
    except P4Exception:
        quit = False
        for e in p4.errors:
            p4.disconnect()
            # We'll just ignore the failure to have set P4CLIENT or P4CONFIG
            if "is not under" in e:
                p4_available = False
            else:
                quit = True
                sys.stderr.write("%s: %s\n" % (argv[0], e))
        if quit:
            sys.exit(1)
if p4_available:
    try:
        p4_change = p4_changes[0]["change"]
        # print p4_change
    except IndexError:
        p4_available = False
    except P4Exception:
        for e in p4.errors:
            sys.stderr.write("%s: %s\n" % (argv[0], e))
        p4.disconnect()
        sys.exit(1)
if p4_available:
    try:
        p4_opened = p4.run("opened", '-m1', "%s/..." % directory);
        # print p4_opened
    except P4Exception:
        for e in p4.errors:
            sys.stderr.write("%s: %s\n" % (argv[0], e))
        p4.disconnect()
        sys.exit(1)
    change = p4_change
    if not noexecute:
        if 0 != len(p4_opened):
            change += '*'
elif change:
    change += '?'

if verbose:
    sys.stderr.write("change=%s\n" % change)

# Try very hard to get a host name
if "HOST" in os.environ:
    host = os.environ["HOST"]
elif "HOSTNAME" in os.environ:
    host = os.environ["HOSTNAME"]
elif "COMPUTERNAME" in os.environ:
    host = os.environ["COMPUTERNAME"]
else:
    # Oh well, try calling external functions
    host = call_command(["hostname"])
    if "" == host:
        host = call_command(["uname", "-n"])

if "" == host:
    sys.stderr.write("%s: unable to determine hostname\n" % argv[0])
    sys.exit(1)

# This might be an FQDN, so lower case and take the bit before the first .
machine_name = host.lower().split(".")[0]
if verbose:
    sys.stderr.write("host=%s\n" % host)

# Try very hard to get a user name
if "USER" in os.environ:
    user = os.environ["USER"]
elif "USERNAME" in os.environ:
    user = os.environ["USERNAME"]
elif "LOGNAME" in os.environ:
    user = os.environ["LOGNAME"]
else:
    sys.stderr.write("%s: unable to determine user name\n" % argv[0])
    sys.exit(1)
user = user.lower()
try:
    uid = os.getuid()
except AttributeError:
    uid = 1000
if verbose:
    sys.stderr.write("username=%s, uid=%d\n" % (user, uid))

if user in special_users or host in special_hosts:
    uid = 0
    if verbose:
        sys.stderr.write("Setting uid to zero for special user/host\n")

# Attempt to determine the user's home directory
# Try the windows USERPROFILE first as cygwin will need to use
# this even though it defines HOME
# Isn't windoze wonderful
if "" != profile:
    home = profile
elif "HOME" in os.environ:
    home = os.environ["HOME"]
else:
    sys.stderr.write("%s: unable to determine user's home directory\n" % argv[0])
    sys.exit(1)
# Now convert any windoze nastiness in home
home = home.replace("\\", "/")
if verbose:
    sys.stderr.write("home=%s\n" % home)

# Now try to read the history file
if "" == history:
    history = home + "/" + default_history
history_bak = history + ".bak"
# To start with we open for appending and reading
# This is the equivalent of the blindingly obvious +>> in perl
try:
    history_file = open(history, "a+")
except IOError:
    sys.stderr.write("%s: unable to open %s\n" % (argv[0], history))
    sys.exit(1)
# At this point we lock the history file
# The lock will be relinquished when we close
if have_fcntl:
    try:
        fcntl.flock(history_file, fcntl.LOCK_EX)
    except IOError:
        sys.stderr.write("unable to lock %s\n" % history)
        sys.exit(1)
# Then we restore the backup if it exists
if os.path.isfile(history_bak):
    if verbose:
        sys.stderr.write("restoring %s from backup\n" % history)
    try:
        history_bak_file = open(history_bak, "r")
    except IOError:
        sys.stderr.write("%s: unable to open %s\n" % (argv[0], history_bak))
        sys.exit(1)
    history_file.truncate(0)
    for line in history_bak_file:
        history_file.write(line)
    history_bak_file.close()
    try:
        os.remove(history_bak)
    except OSError:
        sys.stderr.write("unable to delete %s\n" % history_bak)
        sys.exit(1)

# Go back to the start of the file
history_file.seek(0)
# Now try and parse it
history_reserved = {}
history_others = {} # Perl used to used its ridiculous syntax to call this %history
for line in history_file:
    # Ignore blank lines.  Actually there shouldn't be any, but
    # in some cases they are being added by some stage of the
    # build process.  No one has time to investigate in detail why,
    # and ignoring them is perfectly safe.
    line = line.strip()
    if "" == line:
        continue
    line_parts = line.split()
    if len(line_parts) < 2:
        sys.stderr.write("%s: unexpected line %s in %s\n" % (argv[0], line, history))
        sys.exit(1)
    key = line_parts[0]
    value = line_parts[1]
    if "reserved" == key:
        # The complicated case
        # reserved <count> <directory> <configuration> <string>
        if 5 > len(line_parts):
            sys.stderr.write("%s: badly formed reservation %s in file %s\n" % (argv[0], value, history))
            sys.exit(1)
        count = value
        dir = line_parts[2]
        config = line_parts[3]
        # Python half baked reduce function
        # If the language was any good I could replace the lambda stuff with +,
        # ie reduce (+, line_parts[4:])
        # Not to mention the totally lost plot re higher order functions
        string = " ".join(line_parts[4:])
        if not dir in history_reserved:
            history_reserved[dir] = {}
        history_reserved[dir][config] = [count, string]
    else:
        # Simple (or unrecognised) line
        if not key in history_others:
            history_others[key] = []
        history_others[key].append(" ".join(line_parts[1:]))

# print history_others
# print history_reserved

# Extract indentifiers from the history file (if they exist)
history_string = ""
counter = 0
if directory in history_reserved and configuration in history_reserved[directory]:
    # Build identifiers already allocated
    (counter_str, history_string) = history_reserved[directory][configuration]
    counter = int(counter_str)
    if verbose:
        sys.stderr.write("counter=%d (previously reserved)\n" % counter)
else:
    # Use the next counter value for this build identifier
    if "next" in history_others:
        counter_str = history_others["next"][0]
        counter = int(counter_str)
    else:
        history_others["next"] = ["0"]
        counter = 1
    history_others["next"][0] = counter + 1;
    if verbose:
        sys.stderr.write("counter=%d (new allocation)\n" % counter)

# Extract uid from the history file (if present)
if 0 == uid and not "uid" in history_others:
    sys.stderr.write("Unable to automatically determine the user's uid for generating build\n \
                      identifiers. Please specify a unique value for this build environment by\n \
                      adding a 'uid ####' line to:\n \
                      %s\n \
                      It is recommended that the value (####) be based on the user's uid on the grid\n \
                      (as reported by the 'id' command) with 1000 or 2000 added for building on a\n \
                      Windows PC or laptop respectively.\n" % history)

if "uid" in history_others:
    uid = int(history_others["uid"][0])
uid %= 4000 # Reduce modulo 4k to keep in range
if verbose and "uid" in history_others:
    sys.stderr.write("uid = %d (from %s)\n" % (uid, history))

the_time = time.localtime()
stamp = "%04d-%02d-%02d %02d:%02d" % (the_time.tm_year, the_time.tm_mon, the_time.tm_mday, the_time.tm_hour, the_time.tm_min)

# Construct the various identifiers
if multiply_uid <= counter:
    sys.stderr.write("%s: counter (%d) too large\n" % (argv[0], counter))
    sys.exit(1)
id_numeric = uid * multiply_uid + counter
# Check for overflow
if id_numeric < 0 or id_numeric / multiply_uid < uid:
    sys.stderr.write("uid (%d) too large\n" % uid)
    sys.exit(1)
# die "uid ($uid) too large\n" if 0xFFFFFFFF < $id_numeric;
if "" != history_string:
    id_string = history_string
    # If we didn't know the change last time, substitute it in.
    if "unknown" in id_string:
        id_strs = id_string.split("unknown")
        if change:
            new_strs = [id_strs[0], change, id_strs[1]]
        else:
            new_strs = [id_strs[0], id_strs[1]]
        id_strs = " ".join(new_strs)
else:
    id_string = "%s %s %d %s@%s" % (stamp, configuration, id_numeric, user, host)
    if change:
        id_string = "%s@%s" % (id_string, change)

# Update the history file if required (careful to preserve unrecognised lines)
# We do this except for dummy runs, and when we're finishing
# or not acquiring from a reservation line
if (finished or "" != history_string) and not noexecute:
    # Create a backup file to guard against being interrupted
    history_bak_tmp = history + ".tmp"
    shutil.copy(history, history_bak_tmp)
    try:
        os.rename(history_bak_tmp, history_bak)
    except OSError:
        sys.stderr.write("unable to rename %s to %d\n" % (history_bak_tmp, history_bak))
        sys.exit(1)

    # Update the list of reserved identifiers
    if not directory in history_reserved:
        history_reserved[directory] = {}
    history_reserved[directory][configuration] = [counter, id_string]
    if finished:
        # Remove this configuration from the history table
        del history_reserved[directory][configuration]

    # Write the new history file
    if verbose:
        sys.stderr.write("updating %s\n" % history)
    history_file.seek(0)
    history_file.truncate() # Truncate to current position, ie 0
    # Now print the history of keys and values
    for (key, value) in history_others.iteritems():
        history_file.write("%s %s\n" % (key, value[0]))

    # Now print the reserved history
    for (dir, dict) in history_reserved.iteritems():
        for (config, value) in dict.iteritems():
            count = value[0]
            string = value[1]
            history_file.write("reserved %s %s %s %s\n" % (count, dir, config, string))

    # Update complete so delete the backup file
    try:
        os.remove(history_bak)
    except OSError:
        sys.stderr.write("unable to delete %s\n" % history_bak)
        sys.exit(1)

history_file.close()

if "number" == output:
    sys.stdout.write("%d" % id_numeric)
if "string" == output:
    sys.stdout.write("%s" % id_string)
if "summary" == output:
    sys.stdout.write("Numeric ID = %d\nString ID = %s\n" % (id_numeric, id_string))

# That's all folks!
sys.exit(0)
